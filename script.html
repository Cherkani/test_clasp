<script>
// App State
const AppState = {
  currentPage: 'dashboard',
  tasks: [],
  objectives: [],
  categories: [],
  statuses: [],
  events: [],
  debts: [],
  persons: [],
  isSyncing: false,
  sidebarCollapsed: false,
  timelineView: 'month',
  timelineCurrentDate: new Date(),
  timelineCollapsedDates: {},
  timelineFilters: { statuses: [], categories: [], objectives: [] },
  eventsTimelineView: 'month',
  eventsTimelineCurrentDate: new Date(),
  eventsTimelineCollapsedDates: {},
  financeRecords: [],
  financeSettings: {},
  financeCategories: [],
  stats: null,
  financeMonth: new Date(),
  dashboardCharts: {},
  searchQuery: '',
  referenceTab: 'objectives',
  financeTab: 'transactions',
  mobileSidebarOpen: false,
  taskFilters: { statuses: [], categories: [], objectives: [] },
  financeFilters: { types: [], categories: [] },
  calendarCurrentDate: new Date(),
  debtsPersonTab: 'list',
  reportsPeriod: 'month',
  notes: [],
  notesSubjects: [],
  notesSubject: 'all',
  recurringBills: [],
  };
  
  // Google Apps Script API
  const API = {
    async getTasks() {
      return new Promise((resolve) => {
        google.script.run
          .withSuccessHandler(resolve)
          .withFailureHandler((error) => {
            console.error('Error fetching tasks:', error);
            resolve([]);
          })
          .getDatags();
      });
    },
  
    async saveTasks(tasks) {
      return new Promise((resolve, reject) => {
        google.script.run
          .withSuccessHandler(resolve)
          .withFailureHandler(reject)
          .addDatags(tasks);
      });
    },
  
    async getObjectives() {
      return new Promise((resolve) => {
        google.script.run
          .withSuccessHandler(resolve)
          .withFailureHandler((error) => {
            console.error('Error fetching objectives:', error);
            resolve([]);
          })
          .getObjectives();
      });
    },
  
    async addObjective(objective) {
      return new Promise((resolve, reject) => {
        google.script.run
          .withSuccessHandler(resolve)
          .withFailureHandler(reject)
          .addObjective(objective);
      });
    },
  
    async updateObjectiveHealth() {
      return new Promise((resolve) => {
        google.script.run
          .withSuccessHandler(resolve)
          .withFailureHandler((error) => {
            console.error('Error updating objective health:', error);
            resolve([]);
          })
          .getObjectives();
      });
    },
  
    async updateObjective(objective) {
      return new Promise((resolve, reject) => {
        google.script.run
          .withSuccessHandler(resolve)
          .withFailureHandler(reject)
          .updateObjective(objective);
      });
    },
  
    async deleteObjective(objectiveId) {
      return new Promise((resolve, reject) => {
        google.script.run
          .withSuccessHandler(resolve)
          .withFailureHandler(reject)
          .deleteObjective(objectiveId);
      });
    },
  
    async getCategories() {
      return new Promise((resolve) => {
        google.script.run
          .withSuccessHandler(resolve)
          .withFailureHandler((error) => {
            console.error('Error fetching categories:', error);
            resolve([]);
          })
          .getCategories();
      });
    },
  
    async addCategory(category) {
      return new Promise((resolve, reject) => {
        google.script.run
          .withSuccessHandler(resolve)
          .withFailureHandler(reject)
          .addCategory(category);
      });
    },
  
    async updateCategory(category) {
      return new Promise((resolve, reject) => {
        google.script.run
          .withSuccessHandler(resolve)
          .withFailureHandler(reject)
          .updateCategory(category);
      });
    },
  
    async deleteCategory(categoryId) {
      return new Promise((resolve, reject) => {
        google.script.run
          .withSuccessHandler(resolve)
          .withFailureHandler(reject)
          .deleteCategory(categoryId);
      });
    },
  
    async getStatuses() {
      return new Promise((resolve) => {
        google.script.run
          .withSuccessHandler(resolve)
          .withFailureHandler((error) => {
            console.error('Error fetching statuses:', error);
            resolve([]);
          })
          .getStatuses();
      });
    },
  
    async addStatus(status) {
      return new Promise((resolve, reject) => {
        google.script.run
          .withSuccessHandler(resolve)
          .withFailureHandler(reject)
          .addStatus(status);
      });
    },
  
    async updateStatus(status) {
      return new Promise((resolve, reject) => {
        google.script.run
          .withSuccessHandler(resolve)
          .withFailureHandler(reject)
          .updateStatus(status);
      });
    },
  
    async deleteStatus(statusId) {
      return new Promise((resolve, reject) => {
        google.script.run
          .withSuccessHandler(resolve)
          .withFailureHandler(reject)
          .deleteStatus(statusId);
      });
    },
  
    async getFinanceRecords() {
      return new Promise((resolve) => {
        google.script.run
          .withSuccessHandler(resolve)
          .withFailureHandler((error) => {
            console.error('Error fetching finance records:', error);
            resolve([]);
          })
          .getFinanceRecords();
      });
    },
  
    async saveFinanceRecords(records) {
      return new Promise((resolve, reject) => {
        google.script.run
          .withSuccessHandler(resolve)
          .withFailureHandler(reject)
          .saveFinanceRecords(records);
      });
    },
  
    async getFinanceSettings() {
      return new Promise((resolve) => {
        google.script.run
          .withSuccessHandler(resolve)
          .withFailureHandler((error) => {
            console.error('Error fetching finance settings:', error);
            resolve({});
          })
          .getFinanceSettings();
      });
    },
  
    async saveFinanceSettings(settings) {
      return new Promise((resolve, reject) => {
        google.script.run
          .withSuccessHandler(resolve)
          .withFailureHandler(reject)
          .saveFinanceSettings(settings);
      });
    },
  
    async getFinanceCategories() {
      return new Promise((resolve) => {
        google.script.run
          .withSuccessHandler(resolve)
          .withFailureHandler((error) => {
            console.error('Error fetching finance categories:', error);
            resolve([]);
          })
          .getFinanceCategories();
      });
    },
  
    async addFinanceCategory(category) {
      return new Promise((resolve, reject) => {
        google.script.run
          .withSuccessHandler(resolve)
          .withFailureHandler(reject)
          .addFinanceCategory(category);
      });
    },
  
    async updateFinanceCategory(category) {
      return new Promise((resolve, reject) => {
        google.script.run
          .withSuccessHandler(resolve)
          .withFailureHandler(reject)
          .updateFinanceCategory(category);
      });
    },
  
    async deleteFinanceCategory(categoryId) {
      return new Promise((resolve, reject) => {
        google.script.run
          .withSuccessHandler(resolve)
          .withFailureHandler(reject)
          .deleteFinanceCategory(categoryId);
      });
    },
  
    async getAppData() {
      return new Promise((resolve) => {
        google.script.run
          .withSuccessHandler(resolve)
          .withFailureHandler((error) => {
            console.error('Error fetching app data:', error);
            resolve({
              tasks: [],
              objectives: [],
              categories: [],
              statuses: [],
              financeRecords: [],
              financeSettings: {},
              financeCategories: [],
              events: [],
              debts: [],
              persons: [],
              notes: [],
              recurringBills: [],
              stats: null
            });
          })
          .getAppData();
      });
    },
  
    async getEvents() {
      return new Promise((resolve) => {
        google.script.run
          .withSuccessHandler(resolve)
          .withFailureHandler((error) => {
            console.error('Error fetching events:', error);
            resolve([]);
          })
          .getEvents();
      });
    },
  
    async addEvent(event) {
      return new Promise((resolve, reject) => {
        google.script.run
          .withSuccessHandler(resolve)
          .withFailureHandler(reject)
          .addEvent(event);
      });
    },
  
    async updateEvent(event) {
      return new Promise((resolve, reject) => {
        google.script.run
          .withSuccessHandler(resolve)
          .withFailureHandler(reject)
          .updateEvent(event);
      });
    },
  
    async deleteEvent(eventId) {
      return new Promise((resolve, reject) => {
        google.script.run
          .withSuccessHandler(resolve)
          .withFailureHandler(reject)
          .deleteEvent(eventId);
      });
    },
  
    async getDebts() {
      return new Promise((resolve) => {
        google.script.run
          .withSuccessHandler(resolve)
          .withFailureHandler((error) => {
            console.error('Error fetching debts:', error);
            resolve([]);
          })
          .getDebts();
      });
    },
  
    async getPersons() {
      return new Promise((resolve) => {
        google.script.run
          .withSuccessHandler(resolve)
          .withFailureHandler((error) => {
            console.error('Error fetching persons:', error);
            resolve([]);
          })
          .getPersons();
      });
    },
  
    async addPerson(person) {
      return new Promise((resolve, reject) => {
        google.script.run
          .withSuccessHandler(resolve)
          .withFailureHandler(reject)
          .addPerson(person);
      });
    },
  
    async updatePerson(person) {
      return new Promise((resolve, reject) => {
        google.script.run
          .withSuccessHandler(resolve)
          .withFailureHandler(reject)
          .updatePerson(person);
      });
    },
  
    async deletePerson(personId) {
      return new Promise((resolve, reject) => {
        google.script.run
          .withSuccessHandler(resolve)
          .withFailureHandler(reject)
          .deletePerson(personId);
      });
    },
  
    async getNotes() {
      return new Promise((resolve) => {
        google.script.run
          .withSuccessHandler(resolve)
          .withFailureHandler((error) => {
            console.error('Error fetching notes:', error);
            resolve([]);
          })
          .getNotes();
      });
    },
  
    async addNote(note) {
      return new Promise((resolve, reject) => {
        google.script.run
          .withSuccessHandler(resolve)
          .withFailureHandler(reject)
          .addNote(note);
      });
    },
  
    async updateNote(note) {
      return new Promise((resolve, reject) => {
        google.script.run
          .withSuccessHandler(resolve)
          .withFailureHandler(reject)
          .updateNote(note);
      });
    },
  
    async deleteNote(noteId) {
      return new Promise((resolve, reject) => {
        google.script.run
          .withSuccessHandler(resolve)
          .withFailureHandler(reject)
          .deleteNote(noteId);
      });
    },
  
    async getRecurringBills() {
      return new Promise((resolve) => {
        google.script.run
          .withSuccessHandler(resolve)
          .withFailureHandler((error) => {
            console.error('Error fetching recurring bills:', error);
            resolve([]);
          })
          .getRecurringBills();
      });
    },
  
    async addRecurringBill(bill) {
      return new Promise((resolve, reject) => {
        google.script.run
          .withSuccessHandler(resolve)
          .withFailureHandler(reject)
          .addRecurringBill(bill);
      });
    },
  
    async updateRecurringBill(bill) {
      return new Promise((resolve, reject) => {
        google.script.run
          .withSuccessHandler(resolve)
          .withFailureHandler(reject)
          .updateRecurringBill(bill);
      });
    },
  
    async deleteRecurringBill(billId) {
      return new Promise((resolve, reject) => {
        google.script.run
          .withSuccessHandler(resolve)
          .withFailureHandler(reject)
          .deleteRecurringBill(billId);
      });
    },
  
    async processRecurringBills() {
      return new Promise((resolve, reject) => {
        google.script.run
          .withSuccessHandler(resolve)
          .withFailureHandler(reject)
          .processRecurringBills();
      });
    },
  
    async addDebt(debt) {
      return new Promise((resolve, reject) => {
        google.script.run
          .withSuccessHandler(resolve)
          .withFailureHandler(reject)
          .addDebt(debt);
      });
    },
  
    async updateDebt(debt) {
      return new Promise((resolve, reject) => {
        google.script.run
          .withSuccessHandler(resolve)
          .withFailureHandler(reject)
          .updateDebt(debt);
      });
    },
  
    async deleteDebt(debtId) {
      return new Promise((resolve, reject) => {
        google.script.run
          .withSuccessHandler(resolve)
          .withFailureHandler(reject)
          .deleteDebt(debtId);
      });
    },
  
    async createGoogleCalendarEvent(event) {
      return new Promise((resolve, reject) => {
        google.script.run
          .withSuccessHandler(resolve)
          .withFailureHandler((error) => {
            console.error('Error creating Google Calendar event:', error);
            resolve({ success: false, error: error.toString() });
          })
          .createGoogleCalendarEvent(event);
      });
    }
  };
  
  const DataStore = {
    apply(data) {
      if (!data) {
        console.error('DataStore.apply: data is null or undefined');
        return;
      }
      AppState.tasks = data.tasks || [];
      AppState.objectives = data.objectives || [];
      AppState.categories = data.categories || [];
      AppState.statuses = data.statuses || [];
      AppState.financeRecords = data.financeRecords || [];
      AppState.financeSettings = data.financeSettings || {};
      AppState.financeCategories = data.financeCategories || [];
      AppState.events = data.events || [];
      AppState.debts = data.debts || [];
      AppState.persons = data.persons || [];
      AppState.notes = data.notes || [];
      AppState.recurringBills = data.recurringBills || [];
      AppState.stats = data.stats || null;
    },
  
    async refresh() {
      try {
        const data = await API.getAppData();
        if (data) {
          this.apply(data);
        } else {
          console.error('DataStore.refresh: getAppData returned null');
        }
      } catch (error) {
        console.error('DataStore.refresh error:', error);
      }
    }
  };
  
  // Save Manager for Optimistic Updates
  const SaveManager = {
    pendingSaves: 0,
    snapshots: new Map(),
  
    startSave(operationId, snapshot) {
      this.pendingSaves++;
      if (snapshot) {
        this.snapshots.set(operationId, snapshot);
      }
      this.updateSyncButton();
    },
  
    endSave(operationId, success = true) {
      this.pendingSaves = Math.max(0, this.pendingSaves - 1);
      if (operationId && this.snapshots.has(operationId)) {
        if (!success) {
          // Rollback on failure
          const snapshot = this.snapshots.get(operationId);
          this.rollback(snapshot);
        }
        this.snapshots.delete(operationId);
      }
      this.updateSyncButton();
    },
  
    rollback(snapshot) {
      if (snapshot.tasks) AppState.tasks = snapshot.tasks;
      if (snapshot.objectives) AppState.objectives = snapshot.objectives;
      if (snapshot.categories) AppState.categories = snapshot.categories;
      if (snapshot.statuses) AppState.statuses = snapshot.statuses;
      if (snapshot.financeRecords) AppState.financeRecords = snapshot.financeRecords;
      if (snapshot.financeSettings) AppState.financeSettings = snapshot.financeSettings;
      if (snapshot.events) AppState.events = snapshot.events;
      if (snapshot.debts) AppState.debts = snapshot.debts;
      if (snapshot.persons) AppState.persons = snapshot.persons;
      if (snapshot.notes) AppState.notes = snapshot.notes;
      if (snapshot.recurringBills) AppState.recurringBills = snapshot.recurringBills;
      Router.render();
      Sidebar.render();
    },
  
    createSnapshot() {
      return {
        tasks: JSON.parse(JSON.stringify(AppState.tasks)),
        objectives: JSON.parse(JSON.stringify(AppState.objectives)),
        categories: JSON.parse(JSON.stringify(AppState.categories)),
        statuses: JSON.parse(JSON.stringify(AppState.statuses)),
        financeRecords: JSON.parse(JSON.stringify(AppState.financeRecords)),
        financeSettings: JSON.parse(JSON.stringify(AppState.financeSettings)),
        events: JSON.parse(JSON.stringify(AppState.events)),
        debts: JSON.parse(JSON.stringify(AppState.debts)),
        persons: JSON.parse(JSON.stringify(AppState.persons)),
        notes: JSON.parse(JSON.stringify(AppState.notes)),
        recurringBills: JSON.parse(JSON.stringify(AppState.recurringBills))
      };
    },
  
    updateSyncButton() {
      AppState.isSyncing = this.pendingSaves > 0;
      // Update sidebar sync button
      const syncBtn = document.querySelector('.sync-button');
      if (syncBtn) {
        syncBtn.className = `sync-button sync-button-compact ${this.pendingSaves > 0 ? 'syncing' : ''}`;
        const isCollapsed = AppState.sidebarCollapsed;
        if (this.pendingSaves > 0) {
          syncBtn.innerHTML = '<svg fill="none" stroke="currentColor" viewBox="0 0 24 24" class="animate-spin"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M4 4v5h.582m15.356 2A8.001 8.001 0 004.582 9m0 0H9m11 11v-5h-.581m0 0a8.003 8.003 0 01-15.357-2m15.357 2H15"></path></svg>' + (isCollapsed ? '' : ' Saving...');
        } else {
          syncBtn.innerHTML = '<svg fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M5 13l4 4L19 7"></path></svg>' + (isCollapsed ? '' : ' Synced');
        }
      }
    },
  
    async saveWithOptimisticUpdate(operationId, updateFn, saveFn, onSuccess, onError) {
      // Create snapshot for rollback
      const snapshot = this.createSnapshot();
      
      // Start save tracking first to show loading state
      this.startSave(operationId, snapshot);
      
      // Optimistically update UI
      updateFn();
      Router.render();
      
      try {
        // Save in background
        await saveFn();
        this.endSave(operationId, true);
        if (onSuccess) onSuccess();
      } catch (error) {
        console.error('Save failed:', error);
        this.endSave(operationId, false);
        if (onError) onError(error);
        else Toast.error('Failed to save. Changes have been reverted.');
      }
    }
  };
  
  let chartLoadPromise = null;
  
  function ensureChartLibrary() {
    if (typeof Chart !== 'undefined') {
      return Promise.resolve(true);
    }
    if (chartLoadPromise) {
      return chartLoadPromise;
    }
    chartLoadPromise = new Promise((resolve) => {
      const script = document.createElement('script');
      script.src = 'https://cdn.jsdelivr.net/npm/chart.js@4.4.1/dist/chart.umd.min.js';
      script.onload = () => resolve(true);
      script.onerror = () => resolve(false);
      document.head.appendChild(script);
    });
    return chartLoadPromise;
  }
  
  function updateTaskReferences(field, oldValue, newValue) {
    let changed = false;
    AppState.tasks = AppState.tasks.map(task => {
      if (task[field] === oldValue) {
        changed = true;
        return { ...task, [field]: newValue };
      }
      return task;
    });
    return changed;
  }
  
  const DateUtils = {
    parseDate(value) {
      if (!value) return null;
      const date = new Date(value);
      if (Number.isNaN(date.getTime())) return null;
      date.setHours(0, 0, 0, 0);
      return date;
    },
  
    formatDate(date) {
      return `${date.getFullYear()}-${String(date.getMonth() + 1).padStart(2, '0')}-${String(date.getDate()).padStart(2, '0')}`;
    },
  
    addDays(date, days) {
      const next = new Date(date);
      next.setDate(next.getDate() + days);
      return next;
    }
  };
  
  function getTaskRange(task) {
    const start = DateUtils.parseDate(task.startDate || task.endDate);
    const end = DateUtils.parseDate(task.endDate || task.startDate);
    if (!start && !end) return { start: null, end: null };
    if (start && !end) return { start, end: new Date(start) };
    if (!start && end) return { start: new Date(end), end };
    if (end < start) return { start: end, end: start };
    return { start, end };
  }
  
  function getTaskDueInfo(task) {
    if (task.status === 'completed') {
      return { label: 'Completed', status: 'completed' };
    }
    const dueDate = DateUtils.parseDate(task.endDate || task.startDate);
    if (!dueDate) {
      return { label: 'No due date', status: 'none' };
    }
    const today = new Date();
    today.setHours(0, 0, 0, 0);
    const diffDays = Math.round((dueDate.getTime() - today.getTime()) / (1000 * 60 * 60 * 24));
    if (diffDays < 0) {
      const days = Math.abs(diffDays);
      return { label: `Overdue by ${days} day${days === 1 ? '' : 's'}`, status: 'overdue' };
    }
    if (diffDays === 0) {
      return { label: 'Due today', status: 'today' };
    }
    if (diffDays <= 7) {
      return { label: `Due in ${diffDays} days`, status: 'upcoming' };
    }
    return { label: `Due ${DateUtils.formatDate(dueDate)}`, status: 'future' };
  }
  
  function getTaskDurationDays(task) {
    const { start, end } = getTaskRange(task);
    if (!start || !end) return 0;
    return Math.max(0, Math.round((end.getTime() - start.getTime()) / (1000 * 60 * 60 * 24)));
  }
  
  function getTaskOccurrences(tasks, rangeStart, rangeEnd) {
    const occurrences = [];
    tasks.forEach(task => {
      const range = getTaskRange(task);
      if (!range.start || !range.end) return;
      const repeatType = task.repeatType || 'none';
      const repeatUntil = DateUtils.parseDate(task.repeatUntil) || range.end;
      const durationDays = Math.max(0, Math.round((range.end.getTime() - range.start.getTime()) / (1000 * 60 * 60 * 24)));
  
      const addOccurrence = (startDate) => {
        const endDate = DateUtils.addDays(startDate, durationDays);
        if (endDate < rangeStart || startDate > rangeEnd) return;
        occurrences.push({
          ...task,
          occurrenceStart: DateUtils.formatDate(startDate),
          occurrenceEnd: DateUtils.formatDate(endDate),
          isRecurringInstance: repeatType !== 'none'
        });
      };
  
      if (repeatType === 'daily' || repeatType === 'monthly') {
        let cursor = new Date(range.start);
        const dayOfMonth = range.start.getDate();
        while (cursor <= rangeEnd && cursor <= repeatUntil) {
          addOccurrence(cursor);
          if (repeatType === 'daily') {
            cursor = DateUtils.addDays(cursor, 1);
          } else {
            cursor = new Date(cursor.getFullYear(), cursor.getMonth() + 1, dayOfMonth);
          }
        }
      } else {
        addOccurrence(range.start);
      }
    });
    return occurrences;
  }
  
  // Helper functions for ID-based relationships
  function getObjectiveById(id) {
    if (!id) return null;
    return AppState.objectives.find(obj => obj.id === id) || null;
  }
  
  function getObjectiveName(id) {
    const obj = getObjectiveById(id);
    return obj ? obj.name : '';
  }
  
  function getObjectiveColor(id) {
    if (!id) return '';
    const obj = getObjectiveById(id);
    return obj ? obj.color : '';
  }
  
  function getFinanceRecordById(id) {
    if (!id) return null;
    return AppState.financeRecords.find(record => record.id === id) || null;
  }
  
  function getFinanceRecordName(id) {
    const record = getFinanceRecordById(id);
    return record ? record.note : '';
  }
  
  const ColorPalette = {
    colors: ['#4f46e5', '#22c55e', '#f59e0b', '#ef4444', '#14b8a6', '#ec4899', '#6366f1', '#0ea5e9'],
    getNext(existingColors = []) {
      const normalized = existingColors.map(color => (color || '').toLowerCase());
      const next = this.colors.find(color => !normalized.includes(color.toLowerCase()));
      return next || this.colors[normalized.length % this.colors.length];
    }
  };
  
  // DOM Utilities
  const DOM = {
    create(tag, className = '', content = '') {
      const el = document.createElement(tag);
      if (className) el.className = className;
      if (content) el.textContent = content;
      return el;
    },
  
    createIcon(name) {
      const icon = this.create('span', 'nav-item-icon');
      icon.innerHTML = this.getIconSVG(name);
      return icon;
    },
  
    getIconSVG(name) {
      const icons = {
        home: '<svg fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M3 12l2-2m0 0l7-7 7 7M5 10v10a1 1 0 001 1h3m10-11l2 2m-2-2v10a1 1 0 01-1 1h-3m-6 0a1 1 0 001-1v-4a1 1 0 011-1h2a1 1 0 011 1v4a1 1 0 001 1m-6 0h6"></path></svg>',
        tasks: '<svg fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9 5H7a2 2 0 00-2 2v12a2 2 0 002 2h10a2 2 0 002-2V7a2 2 0 00-2-2h-2M9 5a2 2 0 002 2h2a2 2 0 002-2M9 5a2 2 0 012-2h2a2 2 0 012 2m-6 9l2 2 4-4"></path></svg>',
        calendar: '<svg fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M8 7V3m8 4V3m-9 8h10M5 21h14a2 2 0 002-2V7a2 2 0 00-2-2H5a2 2 0 00-2 2v12a2 2 0 002 2z"></path></svg>',
        timeline: '<svg fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 8v4l3 3m6-3a9 9 0 11-18 0 9 9 0 0118 0z"></path></svg>',
        target: '<svg fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9 19v-6a2 2 0 00-2-2H5a2 2 0 00-2 2v6a2 2 0 002 2h2a2 2 0 002-2zm0 0V9a2 2 0 012-2h2a2 2 0 012 2v10m-6 0a2 2 0 002 2h2a2 2 0 002-2m0 0V5a2 2 0 012-2h2a2 2 0 012 2v14a2 2 0 01-2 2h-2a2 2 0 01-2-2z"></path></svg>',
        finance: '<svg fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 8c-1.657 0-3 .895-3 2s1.343 2 3 2 3 .895 3 2-1.343 2-3 2m0-8c1.11 0 2.08.402 2.599 1M12 8V7m0 1v8m0 0v1m0-1c-1.11 0-2.08-.402-2.599-1M21 12a9 9 0 11-18 0 9 9 0 0118 0z"></path></svg>',
        wallet: '<svg fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M3 10h18M7 15h1m4 0h1m-7 4h12a3 3 0 003-3V8a3 3 0 00-3-3H6a3 3 0 00-3 3v8a3 3 0 003 3z"></path></svg>',
        flag: '<svg fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M3 21v-4m0 0V5a2 2 0 012-2h6.5l1 1H21l-3 6 3 6h-8.5l-1-1H5a2 2 0 00-2 2zm9-13.5V9"></path></svg>',
        star: '<svg fill="currentColor" viewBox="0 0 24 24"><path d="M12 2l3.09 6.26L22 9.27l-5 4.87 1.18 6.88L12 17.77l-6.18 3.25L7 14.14 2 9.27l6.91-1.01L12 2z"></path></svg>',
        sparkle: '<svg fill="currentColor" viewBox="0 0 24 24"><path d="M12 0l2.4 7.2L22 9.6l-7.6 2.4L12 22l-2.4-10L2 9.6l7.6-2.4L12 0z"></path></svg>',
        sync: '<svg fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M4 4v5h.582m15.356 2A8.001 8.001 0 004.582 9m0 0H9m11 11v-5h-.581m0 0a8.003 8.003 0 01-15.357-2m15.357 2H15"></path></svg>',
        check: '<svg fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M5 13l4 4L19 7"></path></svg>',
        loading: '<svg fill="none" stroke="currentColor" viewBox="0 0 24 24" class="animate-spin"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M4 4v5h.582m15.356 2A8.001 8.001 0 004.582 9m0 0H9m11 11v-5h-.581m0 0a8.003 8.003 0 01-15.357-2m15.357 2H15"></path></svg>',
        close: '<svg fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6 18L18 6M6 6l12 12"></path></svg>',
        chevronLeft: '<svg fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M15 19l-7-7 7-7"></path></svg>',
        chevronRight: '<svg fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9 5l7 7-7 7"></path></svg>',
        tag: '<svg fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M7 7h.01M7 3h5c.512 0 1.024.195 1.414.586l7 7a2 2 0 010 2.828l-7 7a2 2 0 01-2.828 0l-7-7A1.994 1.994 0 013 12V7a4 4 0 014-4z"></path></svg>',
        plus: '<svg fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 4v16m8-8H4"></path></svg>',
        menu: '<svg fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M4 6h16M4 12h16M4 18h16"></path></svg>',
        event: '<svg fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M8 7V3m8 4V3m-9 8h10M5 21h14a2 2 0 002-2V7a2 2 0 00-2-2H5a2 2 0 00-2 2v12a2 2 0 002 2z"></path></svg>',
        reports: '<svg fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9 19v-6a2 2 0 00-2-2H5a2 2 0 00-2 2v6a2 2 0 002 2h2a2 2 0 002-2zm0 0V9a2 2 0 012-2h2a2 2 0 012 2v10m-6 0a2 2 0 002 2h2a2 2 0 002-2m0 0V5a2 2 0 012-2h2a2 2 0 012 2v14a2 2 0 01-2 2h-2a2 2 0 01-2-2z"></path></svg>',
        notes: '<svg fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M11 5H6a2 2 0 00-2 2v11a2 2 0 002 2h11a2 2 0 002-2v-5m-1.414-9.414a2 2 0 112.828 2.828L11.828 15H9v-2.828l8.586-8.586z"></path></svg>',
        recurring: '<svg fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M4 4v5h.582m15.356 2A8.001 8.001 0 004.582 9m0 0H9m11 11v-5h-.581m0 0a8.003 8.003 0 01-15.357-2m15.357 2H15"></path></svg>'
      };
      return icons[name] || '';
    }
  };
  
  const SelectUtils = {
    addCreateOption(select, label, onCreate) {
      const option = DOM.create('option', '');
      option.value = '__create__';
      option.textContent = `+ Add ${label}`;
      select.appendChild(option);
      select.dataset.prevValue = select.value;
      select.addEventListener('change', () => {
        if (select.value === '__create__') {
          select.value = select.dataset.prevValue || '';
          onCreate();
        } else {
          select.dataset.prevValue = select.value;
        }
      });
    }
  };
  
  const TaskFilters = {
    applySearch(tasks) {
      const query = AppState.searchQuery.trim().toLowerCase();
      if (!query) return tasks;
      return tasks.filter(task => {
        const objectiveName = getObjectiveName(task.objectiveId);
        const haystack = [
          task.task,
          task.category,
          task.status,
          objectiveName,
          task.priority
        ]
          .filter(Boolean)
          .join(' ')
          .toLowerCase();
        return haystack.includes(query);
      });
    },
  
    applyListFilters(tasks) {
      const filters = AppState.taskFilters;
      if (!filters) return tasks;
      return tasks.filter(task => {
        if (filters.statuses.length > 0 && !filters.statuses.includes(task.status)) {
          return false;
        }
        if (filters.categories.length > 0 && !filters.categories.includes(task.category)) {
          return false;
        }
        if (filters.objectives.length > 0 && task.objectiveId && !filters.objectives.includes(task.objectiveId.toString())) {
          return false;
        }
        if (filters.objectives.length > 0 && !task.objectiveId) {
          return false;
        }
        return true;
      });
    },
  
    applyFilters(tasks) {
      return this.applySearch(this.applyListFilters(tasks));
    },
  
    hasActiveFilters() {
      const filters = AppState.taskFilters;
      return Boolean(AppState.searchQuery.trim()) ||
        (filters.statuses.length > 0 || filters.categories.length > 0 || filters.objectives.length > 0);
    },
  
    toggleFilter(type, value) {
      const filters = AppState.taskFilters[type];
      const index = filters.indexOf(value);
      if (index >= 0) {
        filters.splice(index, 1);
      } else {
        filters.push(value);
      }
      Router.render();
    },
  
    clearFilters() {
      AppState.taskFilters = { statuses: [], categories: [], objectives: [] };
      Router.render();
    },
  
    renderFilterBar(title = 'Task Filters') {
      const bar = DOM.create('div', 'filter-bar finance-filter-bar');
      const heading = DOM.create('div', 'filter-title', title);
      bar.appendChild(heading);
  
      const statusGroup = this.renderFilterGroup('Status', AppState.statuses, 'statuses');
      const categoryGroup = this.renderFilterGroup('Category', AppState.categories, 'categories');
      const objectiveGroup = this.renderFilterGroup('Objective', AppState.objectives, 'objectives');
      bar.appendChild(statusGroup);
      bar.appendChild(categoryGroup);
      bar.appendChild(objectiveGroup);
  
      const clearBtn = DOM.create('button', 'btn btn-secondary btn-sm');
      clearBtn.textContent = 'Clear Filters';
      clearBtn.onclick = () => this.clearFilters();
      bar.appendChild(clearBtn);
  
      return bar;
    },
  
    renderFilterGroup(label, items, filterKey) {
      const group = DOM.create('div', 'filter-group');
      group.appendChild(DOM.create('div', 'filter-label', label));
      const options = DOM.create('div', 'filter-options');
      const safeItems = Array.isArray(items) ? items : [];
      safeItems.forEach(item => {
        // For objectives, use ID but display name
        let value, displayText;
        if (filterKey === 'objectives' && item && item.id) {
          value = item.id.toString();
          displayText = item.name || '';
        } else {
          value = item && item.name ? item.name : item;
          displayText = value;
        }
        if (!value || !displayText) return;
        const option = DOM.create('label', 'filter-option');
        const checkbox = DOM.create('input', '');
        checkbox.type = 'checkbox';
        checkbox.checked = AppState.taskFilters[filterKey].includes(value);
        checkbox.onchange = () => this.toggleFilter(filterKey, value);
        const text = DOM.create('span', '', displayText);
        option.appendChild(checkbox);
        option.appendChild(text);
        options.appendChild(option);
      });
      if (safeItems.length === 0) {
        options.appendChild(DOM.create('span', 'filter-empty', 'No options'));
      }
      group.appendChild(options);
      return group;
    }
  };
  
  const Toast = {
    container: null,
  
    init() {
      if (this.container) return;
      this.container = DOM.create('div', 'toast-container');
      document.body.appendChild(this.container);
    },
  
    show(message, type = 'info') {
      if (!this.container) this.init();
      const toast = DOM.create('div', `toast toast-${type}`);
      toast.textContent = message;
      this.container.appendChild(toast);
  
      requestAnimationFrame(() => {
        toast.classList.add('show');
      });
  
      setTimeout(() => {
        toast.classList.remove('show');
        setTimeout(() => toast.remove(), 300);
      }, 3000);
    },
  
    success(message) {
      this.show(message, 'success');
    },
  
    error(message) {
      this.show(message, 'error');
    }
  };
  
  // Sidebar Component
  const Sidebar = {
    render() {
      const sidebar = DOM.create('aside', 'sidebar');
      const isMobile = window.innerWidth <= 768;
      if (!isMobile && AppState.sidebarCollapsed) sidebar.classList.add('collapsed');
      if (isMobile && AppState.mobileSidebarOpen) sidebar.classList.add('open');
  
      // Header
      const header = DOM.create('div', 'sidebar-header');
      const logo = DOM.create('div', 'sidebar-logo');
      logo.innerHTML = '<span style="font-size: 1.75rem; display: inline-block; background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); -webkit-background-clip: text; -webkit-text-fill-color: transparent; background-clip: text;">⚡</span>';
      if (!AppState.sidebarCollapsed) {
        const logoText = DOM.create('div', '');
        logoText.innerHTML = '<p style="font-weight: 700; margin: 0; background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); -webkit-background-clip: text; -webkit-text-fill-color: transparent; background-clip: text;">FlowTrack</p><p style="font-size: 0.75rem; color: #64748b; margin: 0; margin-top: 2px;">Track work & money</p>';
        logo.appendChild(logoText);
      }
      header.appendChild(logo);
  
      // Toggle button
      const toggleBtn = DOM.create('button', 'sidebar-toggle');
      toggleBtn.innerHTML = AppState.sidebarCollapsed ? DOM.getIconSVG('chevronRight') : DOM.getIconSVG('chevronLeft');
      toggleBtn.onclick = () => {
        AppState.sidebarCollapsed = !AppState.sidebarCollapsed;
        this.render();
      };
      header.appendChild(toggleBtn);
      sidebar.appendChild(header);
  
  
  
      // Navigation
      const nav = DOM.create('nav', 'sidebar-nav');
      const navList = DOM.create('ul', 'nav-list');
  
      const navGroups = [
      {
        title: 'Overview',
        items: [
          { id: 'dashboard', label: 'Dashboard', icon: 'home' }
        ]
      },
        {
          title: 'Workspace',
          items: [
            { id: 'timeline', label: 'Tasks', icon: 'tasks' },
            { id: 'events', label: 'Events', icon: 'event' },
            { id: 'calendar', label: 'Calendar', icon: 'calendar' },
            { id: 'reference', label: 'Reference', icon: 'flag' }
          ]
        },
        {
          title: 'Money',
          items: [
            { id: 'finance', label: 'Finance', icon: 'finance' },
            { id: 'debts', label: 'Debts', icon: 'wallet' }
          ]
        },
        {
          title: 'Tools',
          items: [
            { id: 'notes', label: 'Notes & Journal', icon: 'notes' }
          ]
        }
      ];
  
      navGroups.forEach(group => {
        if (!AppState.sidebarCollapsed) {
          const section = DOM.create('li', 'nav-section-title', group.title);
          navList.appendChild(section);
        }
        group.items.forEach(item => {
          const li = DOM.create('li', 'nav-item');
          if (AppState.currentPage === item.id) {
            li.classList.add('active');
          }
          li.onclick = () => Router.navigate(item.id);
          li.appendChild(DOM.createIcon(item.icon));
          const text = DOM.create('span', 'nav-item-text', item.label);
          li.appendChild(text);
          navList.appendChild(li);
        });
      });
  
      nav.appendChild(navList);
      sidebar.appendChild(nav);
  
      // Decorative stars and sparkles
      if (!AppState.sidebarCollapsed) {
        const decorations = DOM.create('div', 'sidebar-decorations');
        decorations.innerHTML = `
          <div class="sidebar-star" style="position: absolute; top: 15%; right: 10%; font-size: 0.6rem; opacity: 0.4; animation: float 4s ease-in-out infinite;">⭐</div>
          <div class="sidebar-star" style="position: absolute; top: 35%; left: 8%; font-size: 0.5rem; opacity: 0.3; animation: float 5s ease-in-out infinite 0.5s;">✨</div>
          <div class="sidebar-star" style="position: absolute; top: 60%; right: 12%; font-size: 0.7rem; opacity: 0.35; animation: float 6s ease-in-out infinite 1s;">⭐</div>
          <div class="sidebar-star" style="position: absolute; top: 80%; left: 10%; font-size: 0.55rem; opacity: 0.4; animation: float 4.5s ease-in-out infinite 1.5s;">✨</div>
        `;
        sidebar.appendChild(decorations);
      }
  
      // Sync Section
      const syncSection = DOM.create('div', 'sync-section');
      const syncBtn = DOM.create('button', `sync-button sync-button-compact ${AppState.isSyncing ? 'syncing' : ''}`);
      syncBtn.onclick = () => this.sync();
      
      if (AppState.isSyncing) {
        syncBtn.innerHTML = DOM.getIconSVG('loading') + (AppState.sidebarCollapsed ? '' : ' Syncing...');
      } else {
        syncBtn.innerHTML = DOM.getIconSVG('check') + (AppState.sidebarCollapsed ? '' : ' Synced');
      }
      
      syncSection.appendChild(syncBtn);
      sidebar.appendChild(syncSection);
  
      // Replace existing sidebar
      const existing = document.querySelector('.sidebar');
      if (existing) existing.replaceWith(sidebar);
      else document.body.insertBefore(sidebar, document.body.firstChild);
  
      const existingToggle = document.querySelector('.mobile-menu-toggle');
      if (existingToggle) existingToggle.remove();
      const existingOverlay = document.querySelector('.mobile-menu-overlay');
      if (existingOverlay) existingOverlay.remove();
  
      if (isMobile) {
        const toggle = DOM.create('button', 'mobile-menu-toggle');
        toggle.innerHTML = DOM.getIconSVG('menu');
        toggle.onclick = () => {
          AppState.mobileSidebarOpen = !AppState.mobileSidebarOpen;
          this.render();
        };
        document.body.appendChild(toggle);
  
        if (AppState.mobileSidebarOpen) {
          const overlay = DOM.create('div', 'mobile-menu-overlay');
          overlay.onclick = () => {
            AppState.mobileSidebarOpen = false;
            this.render();
          };
          document.body.appendChild(overlay);
        }
      }
    },
  
    async sync() {
      // Wait for any pending saves to complete
      while (SaveManager.pendingSaves > 0) {
        await new Promise(resolve => setTimeout(resolve, 100));
      }
      
      AppState.isSyncing = true;
      this.render();
      
      try {
        await DataStore.refresh();
        this.render();
        Router.render();
        Toast.success('Sync complete');
      } catch (error) {
        console.error('Sync error:', error);
        Toast.error('Sync failed. Try again.');
      } finally {
        AppState.isSyncing = false;
        this.render();
      }
    }
  };
  
  // Router
  const Router = {
    navigate(page) {
      const referenceTabs = ['objectives', 'categories', 'statuses'];
      if (referenceTabs.includes(page)) {
        AppState.referenceTab = page;
        AppState.currentPage = 'reference';
      } else {
        AppState.currentPage = page;
      }
      if (window.innerWidth <= 768) {
        AppState.mobileSidebarOpen = false;
      }
      Sidebar.render();
      this.render();
    },
  
    render() {
      const content = document.querySelector('.main-content .content-wrapper') || DOM.create('div', 'content-wrapper');
      
      let pageContent;
      switch (AppState.currentPage) {
        case 'dashboard':
          pageContent = Dashboard.render();
          break;
        case 'tasks':
          // Redirect to timeline (Task view)
          AppState.currentPage = 'timeline';
          pageContent = TimelinePage.render();
          break;
        case 'events':
          pageContent = EventsTimelinePage.render();
          break;
        case 'calendar':
          pageContent = CalendarPage.render();
          break;
        case 'timeline':
          pageContent = TimelinePage.render();
          break;
        case 'finance':
          pageContent = FinancePage.render();
          break;
        case 'debts':
          pageContent = DebtsPage.render();
          break;
        case 'reference':
          pageContent = ReferencePage.render();
          break;
        case 'notes':
          pageContent = NotesPage.render();
          break;
        case 'recurring':
          AppState.financeTab = 'recurring';
          AppState.currentPage = 'finance';
          pageContent = FinancePage.render();
          break;
        case 'objectives':
          AppState.referenceTab = 'objectives';
          pageContent = ReferencePage.render();
          break;
        case 'categories':
          AppState.referenceTab = 'categories';
          pageContent = ReferencePage.render();
          break;
        case 'statuses':
          AppState.referenceTab = 'statuses';
          pageContent = ReferencePage.render();
          break;
        default:
          pageContent = Dashboard.render();
      }
  
      const main = DOM.create('div', 'app-main');
      main.appendChild(pageContent);
  
      content.innerHTML = '';
      content.appendChild(main);
  
      const mainContent = document.querySelector('.main-content');
      if (!mainContent) {
        const main = DOM.create('main', 'main-content');
        main.appendChild(content);
        document.body.appendChild(main);
      } else {
        const existing = mainContent.querySelector('.content-wrapper');
        if (existing) existing.replaceWith(content);
        else mainContent.appendChild(content);
      }
    }
  };
  
  const FlowBar = {
    render() {
      const bar = DOM.create('div', 'flow-bar');
      const left = DOM.create('div', 'flow-bar-left');
  
      bar.appendChild(left);
      return bar;
    }
  };
  
  // Dashboard Page
  const Dashboard = {
    render() {
      const container = DOM.create('div', '');
  
      const header = DOM.create('div', 'page-header');
      const titleWrap = DOM.create('div', '');
      titleWrap.appendChild(DOM.create('h1', 'page-title', 'Dashboard'));
      titleWrap.appendChild(DOM.create('p', 'page-subtitle', 'Overview of your tasks & finances'));
      header.appendChild(titleWrap);
      container.appendChild(header);

      // Better switcher (toggle-style)
      const currentTab = AppState.dashboardTab || 'dashboard';
      const switcherContainer = DOM.create('div', 'dashboard-switcher-container');
      
      const switcher = DOM.create('div', 'dashboard-switcher');
      
      const dashboardOption = DOM.create('button', 'dashboard-switcher-option');
      dashboardOption.textContent = 'Dashboard';
      dashboardOption.type = 'button';
      if (currentTab === 'dashboard') {
        dashboardOption.classList.add('active');
      }
      dashboardOption.onclick = () => {
        AppState.dashboardTab = 'dashboard';
        Router.render();
      };
      
      const reportsOption = DOM.create('button', 'dashboard-switcher-option');
      reportsOption.textContent = 'Reports & Analytics';
      reportsOption.type = 'button';
      if (currentTab === 'reports') {
        reportsOption.classList.add('active');
      }
      reportsOption.onclick = () => {
        AppState.dashboardTab = 'reports';
        Router.render();
      };
      
      switcher.appendChild(dashboardOption);
      switcher.appendChild(reportsOption);
      switcherContainer.appendChild(switcher);
      container.appendChild(switcherContainer);

      // Show content based on selected tab
      if (currentTab === 'reports') {
        return this.renderReportsContent(container);
      }
  
      const layout = DOM.create('div', 'dashboard-layout');
      const mainColumn = DOM.create('div', 'dashboard-main');
      const sideColumn = DOM.create('aside', 'dashboard-side');
  
      // Time & Money Summary
      mainColumn.appendChild(this.renderTimeMoneySummary());
      
      // Charts at the top
      mainColumn.appendChild(this.renderFinanceCharts());
      mainColumn.appendChild(this.renderWorkCharts());

      // Add objective health overview
      mainColumn.appendChild(this.renderObjectiveHealthOverview());

      // Add category performance overview
      mainColumn.appendChild(this.renderCategoryPerformanceOverview());
  
      const filteredTasks = TaskFilters.applySearch(AppState.tasks);
      const fallbackStats = {
        total: AppState.tasks.length,
        completed: AppState.tasks.filter(t => t.status === 'completed').length,
        overdue: AppState.tasks.filter(t => t.status === 'overdue').length,
        pending: AppState.tasks.filter(t => t.status === 'pending').length
      };
      const baseStats = AppState.stats?.tasks || fallbackStats;
      const statsData = AppState.searchQuery.trim()
        ? {
            total: filteredTasks.length,
            completed: filteredTasks.filter(t => t.status === 'completed').length,
            overdue: filteredTasks.filter(t => t.status === 'overdue').length,
            pending: filteredTasks.filter(t => t.status === 'pending').length
          }
        : baseStats;
      const stats = DOM.create('div', 'card');
      stats.innerHTML = `
        <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(200px, 1fr)); gap: 1rem;">
          <div>
            <div style="font-size: 2rem; font-weight: bold; color: #3b82f6;">${statsData.total}</div>
            <div style="color: #6b7280;">Total Tasks</div>
          </div>
          <div>
            <div style="font-size: 2rem; font-weight: bold; color: #10b981;">${statsData.completed}</div>
            <div style="color: #6b7280;">Completed</div>
          </div>
          <div>
            <div style="font-size: 2rem; font-weight: bold; color: #ef4444;">${statsData.overdue}</div>
            <div style="color: #6b7280;">Overdue</div>
          </div>
          <div>
            <div style="font-size: 2rem; font-weight: bold; color: #f59e0b;">${statsData.pending}</div>
            <div style="color: #6b7280;">Pending</div>
          </div>
        </div>
      `;
      mainColumn.appendChild(stats);
  
      const recentTasks = DOM.create('div', 'card');
      recentTasks.appendChild(DOM.create('h2', '', 'Recent Tasks'));

      const taskList = DOM.create('div', 'dashboard-recent-tasks');
      const recentTasksList = AppState.tasks
        .filter(task => task.status === 'completed')
        .sort((a, b) => new Date(b.endDate || b.startDate) - new Date(a.endDate || a.startDate))
        .slice(0, 5);

      if (recentTasksList.length === 0) {
        taskList.appendChild(DOM.create('p', 'empty-state', 'No completed tasks yet.'));
      } else {
        recentTasksList.forEach(task => {
          const item = Dashboard.renderTask(task);
          item.onclick = () => TaskModal.show(task);
          taskList.appendChild(item);
        });
      }

      recentTasks.appendChild(taskList);
      mainColumn.appendChild(recentTasks);

      sideColumn.appendChild(this.renderFinanceSummary());
      sideColumn.appendChild(this.renderDebtsSummary());
      sideColumn.appendChild(this.renderEventsSummary());
      sideColumn.appendChild(this.renderFinanceRecent());
      sideColumn.appendChild(this.renderFinanceInsights());
      sideColumn.appendChild(this.renderWorkInsights());
  
      // Add insights panel
      const insightsPanel = InsightsPanel.render();
      if (insightsPanel) {
        sideColumn.appendChild(insightsPanel);
      }
  
      layout.appendChild(mainColumn);
      layout.appendChild(sideColumn);
      container.appendChild(layout);
  
      this.drawCharts();
  
      return container;
    },

    renderReportsContent(container) {
      // Time period selector
      const periodSelector = DOM.create('div', 'reference-tabs');
      periodSelector.style.marginBottom = '1.5rem';
      const periods = [
        { id: 'month', label: 'This Month' },
        { id: 'year', label: 'This Year' },
        { id: 'all', label: 'All Time' }
      ];
      const currentPeriod = AppState.reportsPeriod || 'month';
      periods.forEach(period => {
        const btn = DOM.create('button', 'reference-tab');
        btn.textContent = period.label;
        if (currentPeriod === period.id) btn.classList.add('active');
        btn.onclick = () => {
          AppState.reportsPeriod = period.id;
          Router.render();
        };
        periodSelector.appendChild(btn);
      });
      container.appendChild(periodSelector);

      // Category Performance (merged from CategoryPerformancePage)
      container.appendChild(this.renderCategoryPerformanceFull());

      // Reports content from ReportsPage
      container.appendChild(ReportsPage.renderSpendingTrends());
      container.appendChild(ReportsPage.renderCategoryBreakdown());
      container.appendChild(ReportsPage.renderTaskCompletion());
      container.appendChild(ReportsPage.renderProductivityTrends());

      requestAnimationFrame(() => {
        ReportsPage.drawCharts();
      });

      return container;
    },

    renderCategoryPerformanceFull() {
      const card = DOM.create('div', 'card');
      card.appendChild(DOM.create('h2', '', '📊 Category Performance'));

      const stats = AppState.stats?.categories || {};
      const categoriesGrid = DOM.create('div', 'categories-performance-grid');

      const sortedCategories = Object.entries(stats)
        .filter(([name, data]) => data.taskCount > 0)
        .sort((a, b) => b[1].taskCount - a[1].taskCount);

      if (sortedCategories.length === 0) {
        const emptyState = DOM.create('div', 'empty-state');
        emptyState.style.textAlign = 'center';
        emptyState.style.padding = '3rem';
        emptyState.style.color = '#6b7280';
        emptyState.innerHTML = '<p>No category data available yet.</p><p>Complete some tasks to see performance analytics.</p>';
        categoriesGrid.appendChild(emptyState);
      } else {
        sortedCategories.forEach(([categoryName, categoryStats]) => {
          const categoryCard = this.renderCategoryPerformanceCard(categoryName, categoryStats);
          categoriesGrid.appendChild(categoryCard);
        });
      }

      card.appendChild(categoriesGrid);
      return card;
    },

    renderCategoryPerformanceCard(categoryName, stats) {
      const card = DOM.create('div', 'category-performance-card');
      card.style.borderLeftColor = stats.color || '#3b82f6';
  
      const header = DOM.create('div', 'category-header');
      header.appendChild(DOM.create('h3', 'category-name', categoryName));
  
      // Performance indicators
      const indicators = DOM.create('div', 'category-indicators');
      indicators.innerHTML = `
        <div class="indicator">
          <span class="indicator-value">${stats.completionRate}%</span>
          <span class="indicator-label">Completion Rate</span>
        </div>
        <div class="indicator">
          <span class="indicator-value">${stats.taskCount}</span>
          <span class="indicator-label">Total Tasks</span>
        </div>
        <div class="indicator">
          <span class="indicator-value">${FinancePage.formatCurrency(stats.totalValue)}</span>
          <span class="indicator-label">Value Delivered</span>
        </div>
      `;
  
      // ROI indicator
      const roiIndicator = DOM.create('div', 'roi-indicator');
      const roiValue = typeof stats.roi === 'number' ? `${stats.roi.toFixed(1)}x` : stats.roi;
      const roiColor = typeof stats.roi === 'number' ?
        (stats.roi >= 2 ? '#10b981' : stats.roi >= 1 ? '#f59e0b' : '#ef4444') : '#6b7280';
  
      roiIndicator.innerHTML = `
        <div class="indicator">
          <span class="indicator-value" style="color: ${roiColor}">${roiValue}</span>
          <span class="indicator-label">ROI</span>
        </div>
      `;
  
      // Task breakdown
      const breakdown = DOM.create('div', 'category-breakdown');
      const totalTasks = stats.taskCount;
      const completedTasks = stats.completedCount;
      const overdueTasks = stats.overdueCount;
      const pendingTasks = totalTasks - completedTasks - overdueTasks;
  
      breakdown.innerHTML = `
        <div class="breakdown-item">
          <span class="breakdown-label">Completed:</span>
          <span class="breakdown-value completed">${completedTasks}</span>
        </div>
        <div class="breakdown-item">
          <span class="breakdown-label">Pending:</span>
          <span class="breakdown-value pending">${pendingTasks}</span>
        </div>
        <div class="breakdown-item">
          <span class="breakdown-label">Overdue:</span>
          <span class="breakdown-value overdue">${overdueTasks}</span>
        </div>
        <div class="breakdown-item">
          <span class="breakdown-label">Avg Duration:</span>
          <span class="breakdown-value">${stats.averageDuration} days</span>
        </div>
      `;
  
      // Spending info
      const spendingInfo = DOM.create('div', 'category-spending');
      spendingInfo.innerHTML = `
        <div class="spending-item">
          <span class="spending-label">Spending:</span>
          <span class="spending-value">${FinancePage.formatCurrency(stats.totalSpending)}</span>
        </div>
      `;
  
      card.appendChild(header);
      card.appendChild(indicators);
      card.appendChild(roiIndicator);
      card.appendChild(breakdown);
      card.appendChild(spendingInfo);
  
      // Click to view tasks in this category
      card.onclick = () => {
        // Filter tasks by this category and navigate to timeline
        AppState.timelineFilters.categories = [categoryName];
        Router.navigate('timeline');
      };
  
      return card;
    },
  
    renderFinanceSummary() {
      const card = DOM.create('div', 'card dashboard-finance');
      const monthControl = this.renderFinanceMonthControl();
      const monthKey = FinancePage.getMonthKey(AppState.financeMonth);
      const records = FinancePage.getMonthlyRecordsFor(AppState.financeMonth);
      const totals = FinancePage.getTotals(records);
      
      // Calculate subscription spending from payment transactions
      const subscriptionTotal = records
        .filter(record => record.type === 'expense' && record.recurringBillType === 'subscription')
        .reduce((sum, record) => sum + (Number(record.amount) || 0), 0);
      
      const budget = FinancePage.getMonthlyBudget(monthKey);
      const remaining = budget > 0 ? budget - totals.expenses : null;
      const exceeded = remaining !== null && remaining < 0;
  
      card.appendChild(DOM.create('h2', '', 'Finance Snapshot'));
      card.appendChild(monthControl);
  
      const summary = DOM.create('div', 'dashboard-finance-summary');
      summary.innerHTML = `
        <div>
          <div class="dashboard-finance-label">Income</div>
          <div class="dashboard-finance-value income">${FinancePage.formatCurrency(totals.income)}</div>
        </div>
        <div>
          <div class="dashboard-finance-label">Expenses</div>
          <div class="dashboard-finance-value expense">${FinancePage.formatCurrency(totals.expenses)}</div>
        </div>
        <div>
          <div class="dashboard-finance-label">Subscriptions</div>
          <div class="dashboard-finance-value expense">${FinancePage.formatCurrency(subscriptionTotal)}</div>
        </div>
        <div>
          <div class="dashboard-finance-label">Net</div>
          <div class="dashboard-finance-value">${FinancePage.formatCurrency(totals.net)}</div>
        </div>
        <div>
          <div class="dashboard-finance-label">Budget</div>
          <div class="dashboard-finance-value ${exceeded ? 'expense' : 'income'}">
            ${budget > 0 ? FinancePage.formatCurrency(remaining) : 'Not set'}
          </div>
          <div class="dashboard-finance-sub">${budget > 0 ? (exceeded ? 'Over budget' : 'Remaining') : 'Set budget in Finance'}</div>
        </div>
      `;
      card.appendChild(summary);
  
      const progress = DOM.create('div', 'dashboard-finance-progress');
      if (budget > 0) {
        const percent = Math.min(100, Math.round((totals.expenses / budget) * 100));
        progress.innerHTML = `
          <div class="dashboard-finance-progress-bar">
            <span style="width: ${percent}%;" class="${exceeded ? 'danger' : 'good'}"></span>
          </div>
          <div class="dashboard-finance-progress-text">${percent}% of budget used</div>
        `;
      } else {
        progress.innerHTML = '<div class="dashboard-finance-progress-text">Set a monthly budget to track progress.</div>';
      }
      card.appendChild(progress);
  
      return card;
    },
  
    renderDebtsSummary() {
      const card = DOM.create('div', 'card');
      card.appendChild(DOM.create('h2', '', 'Debts Summary'));
      
      const totals = AppState.debts.reduce((acc, debt) => {
        if (debt.status === 'pending') {
          if (debt.direction === 'owed') acc.owedToMe += debt.amount;
          else acc.iOwe += debt.amount;
        }
        return acc;
      }, { owedToMe: 0, iOwe: 0 });
  
      const summary = DOM.create('div', 'dashboard-finance-summary');
      summary.innerHTML = `
        <div>
          <div class="dashboard-finance-label">Owed to Me</div>
          <div class="dashboard-finance-value income">${totals.owedToMe.toFixed(2)} MAD</div>
        </div>
        <div>
          <div class="dashboard-finance-label">I Owe</div>
          <div class="dashboard-finance-value expense">${totals.iOwe.toFixed(2)} MAD</div>
        </div>
        <div>
          <div class="dashboard-finance-label">Net</div>
          <div class="dashboard-finance-value ${totals.owedToMe - totals.iOwe >= 0 ? 'income' : 'expense'}">
            ${(totals.owedToMe - totals.iOwe).toFixed(2)} MAD
          </div>
        </div>
      `;
      card.appendChild(summary);
  
      const viewBtn = DOM.create('button', 'btn btn-secondary btn-sm');
      viewBtn.textContent = 'View All Debts';
      viewBtn.style.marginTop = '1rem';
      viewBtn.style.width = '100%';
      viewBtn.onclick = () => Router.navigate('debts');
      card.appendChild(viewBtn);
  
      return card;
    },
  
    renderEventsSummary() {
      const card = DOM.create('div', 'card');
      card.appendChild(DOM.create('h2', '', 'Upcoming Events'));
      
      const now = new Date();
      const upcomingEvents = AppState.events
        .filter(event => {
          const eventDate = DateUtils.parseDate(event.startDate || event.endDate);
          return eventDate && eventDate >= now;
        })
        .sort((a, b) => {
          const dateA = DateUtils.parseDate(a.startDate || a.endDate);
          const dateB = DateUtils.parseDate(b.startDate || b.endDate);
          return (dateA || new Date()) - (dateB || new Date());
        })
        .slice(0, 5);
  
      if (upcomingEvents.length === 0) {
        const empty = DOM.create('div', 'empty-state');
        empty.textContent = 'No upcoming events.';
        card.appendChild(empty);
      } else {
        const list = DOM.create('div', 'dashboard-finance-list');
        upcomingEvents.forEach(event => {
          const item = DOM.create('div', 'dashboard-finance-item');
          const title = DOM.create('div', 'dashboard-finance-item-title', event.title);
          const date = DOM.create('div', 'dashboard-finance-item-date', 
            `${event.startDate || ''} ${event.startTime || ''}`
          );
          item.appendChild(title);
          item.appendChild(date);
          item.onclick = () => {
            Router.navigate('events');
          };
          list.appendChild(item);
        });
        card.appendChild(list);
      }
  
      const addBtn = DOM.create('button', 'btn btn-primary btn-sm');
      addBtn.textContent = '+ New Event';
      addBtn.style.marginTop = '1rem';
      addBtn.style.width = '100%';
      addBtn.onclick = () => {
        EventModal.show();
      };
      card.appendChild(addBtn);
  
      return card;
    },
  
    renderFinanceMonthControl() {
      const wrapper = DOM.create('div', 'dashboard-finance-month');
      const label = DOM.create('label', 'dashboard-finance-label', 'Month');
      const monthInput = DOM.create('input', 'form-input');
      monthInput.type = 'month';
      monthInput.value = FinancePage.getMonthKey(AppState.financeMonth);
      monthInput.onchange = (event) => {
        AppState.financeMonth = new Date(`${event.target.value}-01`);
        Router.render();
      };
  
      label.appendChild(monthInput);
      wrapper.appendChild(label);
      return wrapper;
    },
  
    renderFinanceRecent() {
      const card = DOM.create('div', 'card dashboard-finance');
      card.appendChild(DOM.create('h2', '', 'Recent Transactions'));
  
      const records = FinancePage.getMonthlyRecordsFor(AppState.financeMonth)
        .slice(-5)
        .reverse();
      if (records.length === 0) {
        const empty = DOM.create('div', 'empty-state');
        empty.textContent = 'No transactions yet.';
        card.appendChild(empty);
        return card;
      }
  
      const list = DOM.create('div', 'dashboard-finance-list');
      records.forEach(record => {
        const row = DOM.create('div', 'dashboard-finance-item');
        const title = record.category || record.note || 'Uncategorized';
        row.innerHTML = `
          <div>
            <div class="dashboard-finance-item-title">${title}</div>
            <div class="dashboard-finance-item-date">${record.date}</div>
          </div>
          <div class="dashboard-finance-item-amount ${record.type}">
            ${record.type === 'expense' ? '-' : '+'}${FinancePage.formatCurrency(record.amount)}
          </div>
        `;
        list.appendChild(row);
      });
      card.appendChild(list);
      return card;
    },
  
    renderFinanceCharts() {
      const card = DOM.create('div', 'card');
      card.appendChild(DOM.create('h2', '', '💰 Time & Money Overview'));

      const grid = DOM.create('div', 'dashboard-chart-grid');

      // Hours vs Income Chart
      const hoursIncomeCard = DOM.create('div', 'dashboard-chart-card');
      hoursIncomeCard.appendChild(DOM.create('div', 'dashboard-chart-title', 'Hours Worked vs Income Earned'));
      const hoursIncomeCanvas = DOM.create('canvas', '');
      hoursIncomeCanvas.id = 'hoursIncomeChart';
      hoursIncomeCard.appendChild(hoursIncomeCanvas);
      grid.appendChild(hoursIncomeCard);

      // Hourly Rate Trend
      const hourlyRateCard = DOM.create('div', 'dashboard-chart-card');
      hourlyRateCard.appendChild(DOM.create('div', 'dashboard-chart-title', 'Hourly Rate Trend'));
      const hourlyRateCanvas = DOM.create('canvas', '');
      hourlyRateCanvas.id = 'hourlyRateChart';
      hourlyRateCard.appendChild(hourlyRateCanvas);
      grid.appendChild(hourlyRateCard);

      // Income vs Expenses
      const trendCard = DOM.create('div', 'dashboard-chart-card');
      trendCard.appendChild(DOM.create('div', 'dashboard-chart-title', 'Income vs Expenses'));
      const trendCanvas = DOM.create('canvas', '');
      trendCanvas.id = 'financeTrendChart';
      trendCard.appendChild(trendCanvas);
      grid.appendChild(trendCard);

      card.appendChild(grid);
      return card;
    },
  
  renderObjectiveHealthOverview() {
    const card = DOM.create('div', 'card');
    card.appendChild(DOM.create('h2', '', '🎯 Objectives Overview'));

    const objectives = AppState.objectives || [];
    if (objectives.length === 0) {
      card.appendChild(DOM.create('p', 'empty-state', 'No objectives yet. Create your first objective to get started.'));
      return card;
    }
  
    const grid = DOM.create('div', 'objectives-health-grid');
  
    objectives.forEach(objective => {
      const objectiveCard = DOM.create('div', 'objective-health-card');
  
      const header = DOM.create('div', 'objective-health-header');
      header.appendChild(DOM.create('h4', 'objective-health-name', objective.name));
  
      // Progress bar
      const tasksWithObjective = AppState.tasks.filter(t => t.objectiveId === objective.id);
      const completedTasks = tasksWithObjective.filter(t => t.status === 'completed').length;
      const progressPercent = tasksWithObjective.length > 0 ? Math.round((completedTasks / tasksWithObjective.length) * 100) : 0;
  
      const progressBar = DOM.create('div', 'objective-progress');
      progressBar.innerHTML = `
        <div class="progress-bar">
          <div class="progress-fill" style="width: ${progressPercent}%"></div>
        </div>
        <span class="progress-text">${progressPercent}% Complete (${completedTasks}/${tasksWithObjective.length} tasks)</span>
      `;
  
      // Hours progress
      const completedHours = tasksWithObjective
        .filter(t => t.status === 'completed')
        .reduce((sum, task) => sum + (Number(task.estimatedHours) || 0), 0);
      const totalHours = tasksWithObjective.reduce((sum, task) => sum + (Number(task.estimatedHours) || 0), 0);
      
      const hoursInfo = DOM.create('div', 'objective-value');
      if (totalHours > 0) {
        const hoursPercent = Math.round((completedHours / totalHours) * 100);
        hoursInfo.innerHTML = `
          <span class="value-amount">${completedHours.toFixed(1)}h / ${totalHours.toFixed(1)}h</span>
          <span class="value-label">Hours (${hoursPercent}%)</span>
        `;
      } else {
        hoursInfo.innerHTML = `
          <span class="value-amount">—</span>
          <span class="value-label">Hours</span>
        `;
      }

      objectiveCard.appendChild(header);
      objectiveCard.appendChild(progressBar);
      objectiveCard.appendChild(hoursInfo);
  
      // Make clickable to navigate to objectives page
      objectiveCard.onclick = () => Router.navigate('objectives');
  
      grid.appendChild(objectiveCard);
    });
  
    card.appendChild(grid);
    return card;
    },
  
  renderCategoryPerformanceOverview() {
    const card = DOM.create('div', 'card');
    card.appendChild(DOM.create('h2', '', '📊 Category Performance'));

    const categoriesStats = AppState.stats?.categories || {};
    const categories = Object.entries(categoriesStats)
      .filter(([name, stats]) => stats && stats.taskCount > 0)
      .sort((a, b) => b[1].completionRate - a[1].completionRate) // Best performing first
      .slice(0, 6); // Show top 6 categories

    if (Object.keys(categoriesStats).length === 0) {
      card.appendChild(DOM.create('p', 'empty-state', 'Category analytics will appear once you add the new columns to your sheets.'));
      return card;
    }

    if (categories.length === 0) {
      card.appendChild(DOM.create('p', 'empty-state', 'Complete some tasks to see category performance metrics.'));
      return card;
    }
  
      const grid = DOM.create('div', 'categories-performance-overview');
  
      categories.forEach(([categoryName, stats]) => {
        const categoryCard = DOM.create('div', 'category-overview-card');
  
        const header = DOM.create('div', 'category-overview-header');
        header.appendChild(DOM.create('h4', 'category-overview-name', categoryName));
  
        const metrics = DOM.create('div', 'category-overview-metrics');
        metrics.innerHTML = `
          <div class="metric">
            <span class="metric-value">${stats.completionRate}%</span>
            <span class="metric-label">Complete</span>
          </div>
          <div class="metric">
            <span class="metric-value">${stats.taskCount}</span>
            <span class="metric-label">Tasks</span>
          </div>
          <div class="metric">
            <span class="metric-value">${typeof stats.roi === 'number' ? stats.roi.toFixed(1) + 'x' : '—'}</span>
            <span class="metric-label">ROI</span>
          </div>
        `;
  
      categoryCard.appendChild(header);
      categoryCard.appendChild(metrics);

      grid.appendChild(categoryCard);
      });
  
      card.appendChild(grid);
      return card;
    },
  
    renderWorkCharts() {
      const card = DOM.create('div', 'card');
      card.appendChild(DOM.create('h2', '', '⏱️ Time & Progress'));

      const grid = DOM.create('div', 'dashboard-chart-grid');

      // Hours by Objective
      const hoursObjectiveCard = DOM.create('div', 'dashboard-chart-card');
      hoursObjectiveCard.appendChild(DOM.create('div', 'dashboard-chart-title', 'Hours by Objective'));
      const hoursObjectiveCanvas = DOM.create('canvas', '');
      hoursObjectiveCanvas.id = 'hoursByObjectiveChart';
      hoursObjectiveCard.appendChild(hoursObjectiveCanvas);
      grid.appendChild(hoursObjectiveCard);

      // Value vs Hours (ROI)
      const roiCard = DOM.create('div', 'dashboard-chart-card');
      roiCard.appendChild(DOM.create('div', 'dashboard-chart-title', 'Value Delivered vs Hours Invested'));
      const roiCanvas = DOM.create('canvas', '');
      roiCanvas.id = 'valueHoursChart';
      roiCard.appendChild(roiCanvas);
      grid.appendChild(roiCard);

      // Task Completion Trend
      const productivityCard = DOM.create('div', 'dashboard-chart-card');
      productivityCard.appendChild(DOM.create('div', 'dashboard-chart-title', 'Task Completion Trend'));
      const productivityCanvas = DOM.create('canvas', '');
      productivityCanvas.id = 'productivityTrendChart';
      productivityCard.appendChild(productivityCanvas);
      grid.appendChild(productivityCard);

      card.appendChild(grid);
      return card;
    },

    renderTimeMoneySummary() {
      const card = DOM.create('div', 'card');
      card.appendChild(DOM.create('h2', '', '📊 Time & Money Summary'));

      // Current month data
      const now = new Date();
      const currentMonth = new Date(now.getFullYear(), now.getMonth(), 1);
      const monthRecords = FinancePage.getMonthlyRecordsFor(currentMonth);
      const monthTasks = this.getTasksForMonth(currentMonth).filter(t => t.status === 'completed');
      
      // Calculate metrics
      const totalIncome = monthRecords
        .filter(r => r.type === 'income')
        .reduce((sum, r) => sum + (Number(r.amount) || 0), 0);
      
      const totalHours = monthTasks.reduce((sum, task) => sum + (Number(task.estimatedHours) || 0), 0);
      
      const totalValue = monthTasks.reduce((sum, task) => {
        const value = Number(task.actualValue) || Number(task.estimatedValue) || 0;
        return sum + (task.isIncome !== false ? value : 0);
      }, 0);
      
      const hourlyRate = totalHours > 0 ? totalValue / totalHours : 0;
      
      // Hours needed for income
      const incomeRecords = monthRecords.filter(r => r.type === 'income' && r.hoursNeeded > 0);
      const totalHoursNeeded = incomeRecords.reduce((sum, r) => sum + (Number(r.hoursNeeded) || 0), 0);
      const hoursProgress = totalHoursNeeded > 0 ? Math.min(100, Math.round((totalHours / totalHoursNeeded) * 100)) : 0;

      const grid = DOM.create('div', 'dashboard-metrics-grid');
      grid.style.display = 'grid';
      grid.style.gridTemplateColumns = 'repeat(auto-fit, minmax(200px, 1fr))';
      grid.style.gap = '1rem';
      grid.style.marginTop = '1rem';

      // Income
      const incomeCard = DOM.create('div', 'metric-card');
      incomeCard.innerHTML = `
        <div class="metric-label">Total Income</div>
        <div class="metric-value income">${FinancePage.formatCurrency(totalIncome)}</div>
        <div class="metric-hint">This month</div>
      `;
      grid.appendChild(incomeCard);

      // Hours Worked
      const hoursCard = DOM.create('div', 'metric-card');
      hoursCard.innerHTML = `
        <div class="metric-label">Hours Worked</div>
        <div class="metric-value">${totalHours.toFixed(1)}h</div>
        <div class="metric-hint">${totalHoursNeeded > 0 ? `${hoursProgress}% of target` : 'Completed tasks'}</div>
      `;
      grid.appendChild(hoursCard);

      // Hourly Rate
      const rateCard = DOM.create('div', 'metric-card');
      rateCard.innerHTML = `
        <div class="metric-label">Hourly Rate</div>
        <div class="metric-value">${hourlyRate > 0 ? FinancePage.formatCurrency(hourlyRate) + '/hr' : '—'}</div>
        <div class="metric-hint">${totalHours > 0 ? 'From completed tasks' : 'No data yet'}</div>
      `;
      grid.appendChild(rateCard);

      // Value Delivered
      const valueCard = DOM.create('div', 'metric-card');
      valueCard.innerHTML = `
        <div class="metric-label">Value Delivered</div>
        <div class="metric-value">${FinancePage.formatCurrency(totalValue)}</div>
        <div class="metric-hint">From completed tasks</div>
      `;
      grid.appendChild(valueCard);

      // Hours Target Progress
      if (totalHoursNeeded > 0) {
        const progressCard = DOM.create('div', 'metric-card');
        progressCard.innerHTML = `
          <div class="metric-label">Hours Progress</div>
          <div class="metric-value">${hoursProgress}%</div>
          <div class="metric-hint">${totalHours.toFixed(1)}h / ${totalHoursNeeded.toFixed(1)}h</div>
        `;
        grid.appendChild(progressCard);
      }

      card.appendChild(grid);
      return card;
    },
  
    renderFinanceInsights() {
      const card = DOM.create('div', 'card dashboard-finance');
      card.appendChild(DOM.create('h2', '', 'Finance Insights'));
  
      const currentMonth = AppState.financeMonth;
      const prevMonth = new Date(currentMonth.getFullYear(), currentMonth.getMonth() - 1, 1);
      const currentRecords = FinancePage.getMonthlyRecordsFor(currentMonth);
      const prevRecords = FinancePage.getMonthlyRecordsFor(prevMonth);
      const currentTotals = FinancePage.getTotals(currentRecords);
      const prevTotals = FinancePage.getTotals(prevRecords);
      const budget = FinancePage.getMonthlyBudget(FinancePage.getMonthKey(currentMonth));
  
      // Calculate subscription spending
      const currentSubscriptions = currentRecords
        .filter(record => record.type === 'expense' && record.recurringBillType === 'subscription')
        .reduce((sum, record) => sum + (Number(record.amount) || 0), 0);
      const prevSubscriptions = prevRecords
        .filter(record => record.type === 'expense' && record.recurringBillType === 'subscription')
        .reduce((sum, record) => sum + (Number(record.amount) || 0), 0);
  
      const budgetScore = budget > 0 ? Math.max(0, Math.round(((budget - currentTotals.expenses) / budget) * 100)) : null;
      const savingsRate = currentTotals.income > 0
        ? Math.round((currentTotals.net / currentTotals.income) * 100)
        : null;
  
      const trendIncome = this.formatTrend(currentTotals.income, prevTotals.income);
      const trendExpense = this.formatTrend(currentTotals.expenses, prevTotals.expenses);
      const trendSubscriptions = this.formatTrend(currentSubscriptions, prevSubscriptions);
  
      const summary = DOM.create('div', 'dashboard-insights-grid');
      summary.innerHTML = `
        <div>
          <div class="dashboard-finance-label">Budget Score</div>
          <div class="dashboard-finance-value ${budgetScore !== null && budgetScore < 0 ? 'expense' : 'income'}">
            ${budgetScore !== null ? `${budgetScore}%` : 'N/A'}
          </div>
        </div>
        <div>
          <div class="dashboard-finance-label">Savings Rate</div>
          <div class="dashboard-finance-value">${savingsRate !== null ? `${savingsRate}%` : 'N/A'}</div>
        </div>
        <div>
          <div class="dashboard-finance-label">Income Trend</div>
          <div class="dashboard-finance-value">${trendIncome}</div>
        </div>
        <div>
          <div class="dashboard-finance-label">Expense Trend</div>
          <div class="dashboard-finance-value">${trendExpense}</div>
        </div>
        <div>
          <div class="dashboard-finance-label">Subscriptions</div>
          <div class="dashboard-finance-value expense">${FinancePage.formatCurrency(currentSubscriptions)}</div>
        </div>
        <div>
          <div class="dashboard-finance-label">Subscription Trend</div>
          <div class="dashboard-finance-value">${trendSubscriptions}</div>
        </div>
      `;
      card.appendChild(summary);
  
      const categoryList = this.renderFinanceCategoryBreakdown(currentRecords);
      card.appendChild(categoryList);
  
      return card;
    },
  
    renderFinanceCategoryBreakdown(records) {
      const wrapper = DOM.create('div', 'dashboard-insights-list');
      const title = DOM.create('div', 'dashboard-finance-label', 'Top Spending Categories');
      wrapper.appendChild(title);
  
      const expenses = records.filter(record => record.type === 'expense');
      if (expenses.length === 0) {
        wrapper.appendChild(DOM.create('div', 'dashboard-insights-empty', 'No expenses yet.'));
        return wrapper;
      }
  
      const totals = {};
      expenses.forEach(record => {
        const key = record.category || 'Uncategorized';
        totals[key] = (totals[key] || 0) + (Number(record.amount) || 0);
      });
  
      Object.entries(totals)
        .sort((a, b) => b[1] - a[1])
        .slice(0, 3)
        .forEach(([category, amount]) => {
          const row = DOM.create('div', 'dashboard-insights-row');
          row.innerHTML = `<span>${category}</span><span>${FinancePage.formatCurrency(amount)}</span>`;
          wrapper.appendChild(row);
        });
  
      return wrapper;
    },
  
    renderWorkInsights() {
      const card = DOM.create('div', 'card dashboard-finance');
      card.appendChild(DOM.create('h2', '', 'Work Insights'));
  
      // Use all tasks instead of filtering by month
      const allTasks = AppState.tasks;
      const currentMonth = new Date();
      const objectiveDueThisMonth = this.getObjectivesDueInMonth(currentMonth);
      const completionRate = this.getCompletionRate(allTasks);
      const overdueCount = allTasks.filter(task => task.status === 'overdue').length;
      const productivityScore = this.getProductivityScore(allTasks, overdueCount);
  
      const summary = DOM.create('div', 'dashboard-insights-grid');
      summary.innerHTML = `
        <div>
          <div class="dashboard-finance-label">Completion Rate</div>
          <div class="dashboard-finance-value">${completionRate}%</div>
        </div>
        <div>
          <div class="dashboard-finance-label">Overdue Tasks</div>
          <div class="dashboard-finance-value expense">${overdueCount}</div>
        </div>
        <div>
          <div class="dashboard-finance-label">Productivity Score</div>
          <div class="dashboard-finance-value">${productivityScore}</div>
        </div>
        <div>
          <div class="dashboard-finance-label">Objectives Due This Month</div>
          <div class="dashboard-finance-value">${objectiveDueThisMonth.length}</div>
        </div>
      `;
      card.appendChild(summary);
  
      card.appendChild(this.renderObjectiveProgress(objectiveDueThisMonth));
      card.appendChild(this.renderUpcomingObjectives());
  
      return card;
    },
  
    renderObjectiveProgress(objectives) {
      const wrapper = DOM.create('div', 'dashboard-insights-list');
      wrapper.appendChild(DOM.create('div', 'dashboard-finance-label', 'Objectives This Month'));
  
      if (objectives.length === 0) {
        wrapper.appendChild(DOM.create('div', 'dashboard-insights-empty', 'No objectives due this month.'));
        return wrapper;
      }
  
      objectives.slice(0, 3).forEach(objective => {
        const { completed, total } = this.getObjectiveCompletion(objective.name);
        const percent = total > 0 ? Math.round((completed / total) * 100) : 0;
        const row = DOM.create('div', 'dashboard-insights-row');
        row.innerHTML = `<span>${objective.name}</span><span>${percent}%</span>`;
        wrapper.appendChild(row);
      });
  
      return wrapper;
    },
  
    renderUpcomingObjectives() {
      const wrapper = DOM.create('div', 'dashboard-insights-list');
      wrapper.appendChild(DOM.create('div', 'dashboard-finance-label', 'Upcoming Objective Deadlines'));
  
      const upcoming = this.getObjectivesDueSoon(30);
      if (upcoming.length === 0) {
        wrapper.appendChild(DOM.create('div', 'dashboard-insights-empty', 'No upcoming deadlines.'));
        return wrapper;
      }
  
      upcoming.slice(0, 3).forEach(objective => {
        const row = DOM.create('div', 'dashboard-insights-row');
        row.innerHTML = `<span>${objective.name}</span><span>${objective.dueDate}</span>`;
        wrapper.appendChild(row);
      });
      return wrapper;
    },
  
    getTasksForMonth(date, tasks = AppState.tasks) {
      const { start, end } = this.getMonthRange(date);
      return tasks.filter(task => {
        const range = getTaskRange(task);
        if (!range.start || !range.end) return false;
        return range.start <= end && range.end >= start;
      });
    },
  
    getObjectivesDueInMonth(date) {
      const { start, end } = this.getMonthRange(date);
      return AppState.objectives.filter(objective => {
        if (!objective.dueDate) return false;
        const due = this.parseDate(objective.dueDate);
        return due && due >= start && due <= end;
      });
    },
  
    getObjectivesDueSoon(days) {
      const now = new Date();
      const end = new Date(now);
      end.setDate(now.getDate() + days);
      return AppState.objectives
        .filter(objective => objective.dueDate)
        .filter(objective => {
          const due = this.parseDate(objective.dueDate);
          return due && due >= now && due <= end;
        })
        .sort((a, b) => a.dueDate.localeCompare(b.dueDate));
    },
  
    getObjectiveCompletion(objectiveName) {
      const objective = AppState.objectives.find(obj => obj.name === objectiveName);
      const tasks = objective ? AppState.tasks.filter(task => task.objectiveId === objective.id) : [];
      const completed = tasks.filter(task => task.status === 'completed').length;
      return { completed, total: tasks.length };
    },
  
    getCompletionRate(tasks) {
      if (tasks.length === 0) return 0;
      const completed = tasks.filter(task => task.status === 'completed').length;
      return Math.round((completed / tasks.length) * 100);
    },
  
    getProductivityScore(tasks, overdueCount) {
      if (tasks.length === 0) return 0;
      const weightMap = { high: 3, medium: 2, low: 1 };
      const totals = tasks.reduce((acc, task) => {
        const weight = weightMap[task.priority] || 2;
        acc.total += weight;
        if (task.status === 'completed') acc.completed += weight;
        return acc;
      }, { total: 0, completed: 0 });
  
      const baseScore = totals.total > 0 ? Math.round((totals.completed / totals.total) * 100) : 0;
      const penalty = overdueCount * 5;
      return Math.max(0, baseScore - penalty);
    },
  
    getMonthRange(date) {
      const start = new Date(date.getFullYear(), date.getMonth(), 1);
      const end = new Date(date.getFullYear(), date.getMonth() + 1, 0, 23, 59, 59, 999);
      return { start, end };
    },
  
    parseDate(value) {
      return DateUtils.parseDate(value);
    },
  
    formatTrend(current, previous) {
      if (previous === 0) return current === 0 ? '0%' : 'New';
      const delta = current - previous;
      const percent = Math.round((delta / previous) * 100);
      const sign = percent > 0 ? '+' : '';
      return `${sign}${percent}%`;
    },
  
    drawCharts() {
      requestAnimationFrame(async () => {
        const ready = await ensureChartLibrary();
        if (!ready) return;
        this.destroyCharts();
        this.drawHoursIncomeChart();
        this.drawHourlyRateChart();
        this.drawFinanceTrendChart();
        this.drawHoursByObjectiveChart();
        this.drawValueHoursChart();
        this.drawProductivityTrendChart();
      });
    },
  
    destroyCharts() {
      Object.values(AppState.dashboardCharts).forEach(chart => {
        if (chart) chart.destroy();
      });
      AppState.dashboardCharts = {};
    },
  
    drawHoursIncomeChart() {
      const canvas = document.getElementById('hoursIncomeChart');
      if (!canvas) return;
      
      const months = this.getLastMonths(6);
      const hoursData = [];
      const incomeData = [];
      
      months.forEach(month => {
        // Get tasks completed in this month
        const monthTasks = this.getTasksForMonth(month.date)
          .filter(task => task.status === 'completed');
        const totalHours = monthTasks.reduce((sum, task) => sum + (Number(task.estimatedHours) || 0), 0);
        hoursData.push(totalHours);
        
        // Get income from finance records in this month
        const monthRecords = FinancePage.getMonthlyRecordsFor(month.date);
        const income = monthRecords
          .filter(r => r.type === 'income')
          .reduce((sum, r) => sum + (Number(r.amount) || 0), 0);
        incomeData.push(income);
      });

      AppState.dashboardCharts.hoursIncome = new Chart(canvas, {
        type: 'bar',
        data: {
          labels: months.map(month => month.label),
          datasets: [
            {
              label: 'Hours Worked',
              data: hoursData,
              backgroundColor: 'rgba(59, 130, 246, 0.6)',
              yAxisID: 'y'
            },
            {
              label: 'Income Earned',
              data: incomeData,
              backgroundColor: 'rgba(16, 185, 129, 0.6)',
              yAxisID: 'y1',
              type: 'line',
              borderColor: '#10b981',
              borderWidth: 2,
              tension: 0.3
            }
          ]
        },
        options: {
          plugins: { legend: { position: 'bottom' } },
          scales: {
            y: {
              type: 'linear',
              position: 'left',
              beginAtZero: true,
              title: { display: true, text: 'Hours' }
            },
            y1: {
              type: 'linear',
              position: 'right',
              beginAtZero: true,
              title: { display: true, text: 'Income ($)' },
              grid: { drawOnChartArea: false }
            }
          }
        }
      });
    },

    drawHourlyRateChart() {
      const canvas = document.getElementById('hourlyRateChart');
      if (!canvas) return;
      
      const months = this.getLastMonths(6);
      const hourlyRates = [];
      
      months.forEach(month => {
        const monthTasks = this.getTasksForMonth(month.date)
          .filter(task => task.status === 'completed');
        const totalHours = monthTasks.reduce((sum, task) => sum + (Number(task.estimatedHours) || 0), 0);
        const totalValue = monthTasks.reduce((sum, task) => {
          const value = Number(task.actualValue) || Number(task.estimatedValue) || 0;
          return sum + (task.isIncome !== false ? value : 0);
        }, 0);
        
        const rate = totalHours > 0 ? totalValue / totalHours : 0;
        hourlyRates.push(rate);
      });

      AppState.dashboardCharts.hourlyRate = new Chart(canvas, {
        type: 'line',
        data: {
          labels: months.map(month => month.label),
          datasets: [{
            label: 'Hourly Rate ($/hr)',
            data: hourlyRates,
            borderColor: '#f59e0b',
            backgroundColor: 'rgba(245, 158, 11, 0.2)',
            tension: 0.3,
            fill: true
          }]
        },
        options: {
          plugins: { legend: { position: 'bottom' } },
          scales: { y: { beginAtZero: true, title: { display: true, text: 'Rate ($/hr)' } } }
        }
      });
    },
  
    drawFinanceTrendChart() {
      const canvas = document.getElementById('financeTrendChart');
      if (!canvas) return;
      const months = this.getLastMonths(6);
      const income = [];
      const expenses = [];
  
      months.forEach(month => {
        const records = FinancePage.getMonthlyRecordsFor(month.date);
        const totals = FinancePage.getTotals(records);
        income.push(totals.income);
        expenses.push(totals.expenses);
      });
  
      AppState.dashboardCharts.financeTrend = new Chart(canvas, {
        type: 'line',
        data: {
          labels: months.map(month => month.label),
          datasets: [
            {
              label: 'Income',
              data: income,
              borderColor: '#10b981',
              backgroundColor: 'rgba(16, 185, 129, 0.2)',
              tension: 0.3
            },
            {
              label: 'Expenses',
              data: expenses,
              borderColor: '#ef4444',
              backgroundColor: 'rgba(239, 68, 68, 0.2)',
              tension: 0.3
            }
          ]
        },
        options: {
          plugins: { legend: { position: 'bottom' } },
          scales: { y: { beginAtZero: true } }
        }
      });
    },
  
    drawHoursByObjectiveChart() {
      const canvas = document.getElementById('hoursByObjectiveChart');
      if (!canvas) return;
      
      const objectiveHours = {};
      AppState.objectives.forEach(objective => {
        const tasks = AppState.tasks.filter(t => t.objectiveId === objective.id);
        const completedHours = tasks
          .filter(t => t.status === 'completed')
          .reduce((sum, task) => sum + (Number(task.estimatedHours) || 0), 0);
        const totalHours = tasks.reduce((sum, task) => sum + (Number(task.estimatedHours) || 0), 0);
        
        if (totalHours > 0) {
          objectiveHours[objective.name] = {
            completed: completedHours,
            total: totalHours
          };
        }
      });

      const labels = Object.keys(objectiveHours);
      const completedData = labels.map(name => objectiveHours[name].completed);
      const totalData = labels.map(name => objectiveHours[name].total);

      if (labels.length === 0) {
        labels.push('No Data');
        completedData.push(0);
        totalData.push(1);
      }

      AppState.dashboardCharts.hoursByObjective = new Chart(canvas, {
        type: 'bar',
        data: {
          labels,
          datasets: [
            {
              label: 'Completed Hours',
              data: completedData,
              backgroundColor: 'rgba(16, 185, 129, 0.6)'
            },
            {
              label: 'Total Hours',
              data: totalData,
              backgroundColor: 'rgba(59, 130, 246, 0.4)'
            }
          ]
        },
        options: {
          plugins: { legend: { position: 'bottom' } },
          scales: { y: { beginAtZero: true, title: { display: true, text: 'Hours' } } }
        }
      });
    },

    drawValueHoursChart() {
      const canvas = document.getElementById('valueHoursChart');
      if (!canvas) return;
      
      const objectiveData = [];
      AppState.objectives.forEach(objective => {
        const tasks = AppState.tasks.filter(t => t.objectiveId === objective.id);
        const completedTasks = tasks.filter(t => t.status === 'completed');
        const totalHours = completedTasks.reduce((sum, task) => sum + (Number(task.estimatedHours) || 0), 0);
        const totalValue = completedTasks.reduce((sum, task) => {
          const value = Number(task.actualValue) || Number(task.estimatedValue) || 0;
          return sum + (task.isIncome !== false ? value : 0);
        }, 0);
        
        if (totalHours > 0 || totalValue > 0) {
          objectiveData.push({
            name: objective.name,
            hours: totalHours,
            value: totalValue
          });
        }
      });

      const labels = objectiveData.map(d => d.name);
      const hoursData = objectiveData.map(d => d.hours);
      const valueData = objectiveData.map(d => d.value);

      if (labels.length === 0) {
        labels.push('No Data');
        hoursData.push(0);
        valueData.push(0);
      }

      AppState.dashboardCharts.valueHours = new Chart(canvas, {
        type: 'bar',
        data: {
          labels,
          datasets: [
            {
              label: 'Hours',
              data: hoursData,
              backgroundColor: 'rgba(59, 130, 246, 0.6)',
              yAxisID: 'y'
            },
            {
              label: 'Value ($)',
              data: valueData,
              backgroundColor: 'rgba(139, 92, 246, 0.6)',
              yAxisID: 'y1',
              type: 'line',
              borderColor: '#8b5cf6',
              borderWidth: 2,
              tension: 0.3
            }
          ]
        },
        options: {
          plugins: { legend: { position: 'bottom' } },
          scales: {
            y: {
              type: 'linear',
              position: 'left',
              beginAtZero: true,
              title: { display: true, text: 'Hours' }
            },
            y1: {
              type: 'linear',
              position: 'right',
              beginAtZero: true,
              title: { display: true, text: 'Value ($)' },
              grid: { drawOnChartArea: false }
            }
          }
        }
      });
    },
  
    drawProductivityTrendChart() {
      const canvas = document.getElementById('productivityTrendChart');
      if (!canvas) return;
      const months = this.getLastMonths(6);
      const scores = months.map(month => {
        const tasks = this.getTasksForMonth(month.date);
        const overdue = tasks.filter(task => task.status === 'overdue').length;
        return this.getProductivityScore(tasks, overdue);
      });
  
      AppState.dashboardCharts.productivityTrend = new Chart(canvas, {
        type: 'line',
        data: {
          labels: months.map(month => month.label),
          datasets: [{
            label: 'Productivity Score',
            data: scores,
            borderColor: '#3b82f6',
            backgroundColor: 'rgba(59, 130, 246, 0.2)',
            tension: 0.3
          }]
        },
        options: {
          plugins: { legend: { position: 'bottom' } },
          scales: { y: { beginAtZero: true, max: 100 } }
        }
      });
    },
  
    getLastMonths(count) {
      const months = [];
      const start = new Date();
      for (let i = count - 1; i >= 0; i -= 1) {
        const date = new Date(start.getFullYear(), start.getMonth() - i, 1);
        months.push({
          date,
          label: date.toLocaleDateString('en-US', { month: 'short', year: '2-digit' })
        });
      }
      return months;
    },
  
    renderTask(task) {
      const item = DOM.create('div', 'task-item');
      const objectiveColor = getObjectiveColor(task.objectiveId);
      item.style.borderLeftColor = objectiveColor || task.color || '#3b82f6';
      
      const header = DOM.create('div', 'task-header');
      const titleWrap = DOM.create('div', 'task-title-wrap');
      titleWrap.appendChild(DOM.create('div', 'task-title', task.task));
      const actions = DOM.create('div', 'task-actions');
      const editBtn = DOM.create('button', 'btn btn-secondary btn-xs');
      editBtn.textContent = 'Edit';
      editBtn.onclick = (event) => {
        event.stopPropagation();
        TaskModal.show(task);
      };
      const deleteBtn = DOM.create('button', 'btn btn-danger btn-xs');
      deleteBtn.textContent = 'Delete';
      deleteBtn.onclick = async (event) => {
        event.stopPropagation();
        await TaskActions.deleteTask(task);
      };
      actions.appendChild(editBtn);
      actions.appendChild(deleteBtn);
      titleWrap.appendChild(actions);
      header.appendChild(titleWrap);
      const headerBadges = DOM.create('div', 'task-header-badges');
      if (task.priority) {
        headerBadges.appendChild(DOM.create('span', `task-priority ${task.priority}`, task.priority));
      }
      headerBadges.appendChild(DOM.create('span', `task-status ${task.status}`, task.status));
      header.appendChild(headerBadges);
      item.appendChild(header);
  
      const badges = DOM.create('div', 'task-badges');
      if (task.category) {
        badges.appendChild(DOM.create('span', 'task-badge', task.category));
      }
      if (task.objectiveId) {
        const objectiveName = getObjectiveName(task.objectiveId);
        const objectiveBadge = DOM.create('span', 'task-badge objective', `🎯 ${objectiveName}`);
        objectiveBadge.style.borderColor = objectiveColor || '#3b82f6';
        objectiveBadge.style.color = objectiveColor || '#3b82f6';
        badges.appendChild(objectiveBadge);
      }
  
      if (task.relatedEventIds) {
        const eventIds = task.relatedEventIds.split(',').filter(id => id.trim());
        if (eventIds.length > 0) {
          const relatedEvent = AppState.events.find(e => e.id == eventIds[0]);
          if (relatedEvent) {
            const eventBadge = DOM.create('span', 'task-badge event', `📅 ${relatedEvent.title}`);
            eventBadge.style.borderColor = relatedEvent.color || '#3b82f6';
            eventBadge.style.color = relatedEvent.color || '#3b82f6';
            if (eventIds.length > 1) {
              eventBadge.textContent += ` +${eventIds.length - 1}`;
            }
            badges.appendChild(eventBadge);
          }
        }
      }
      if (task.repeatType && task.repeatType !== 'none') {
        const repeatLabel = task.repeatType === 'daily' ? 'Repeats daily' : 'Repeats monthly';
        badges.appendChild(DOM.create('span', 'task-badge repeat', repeatLabel));
      }
    if (task.impactType && task.impactType !== 'non-monetary') {
      const impactLabel = task.impactType === 'money' ? '💰 Financial' : '📈 Long-term';
      badges.appendChild(DOM.create('span', `task-badge impact ${task.impactType}`, impactLabel));
    }
    if (task.impactType && task.impactType !== 'non-monetary') {
      const value = task.actualValue || task.estimatedValue || 0;
      const isIncome = task.isIncome !== false; // Default to true for financial tasks
      const valueText = value > 0 ?
        `${isIncome ? '💰' : '💸'} ${FinancePage.formatCurrency(value)}` :
        `${isIncome ? '💰' : '💸'} Financial`;
      badges.appendChild(DOM.create('span', 'task-badge value', valueText));

      // Show hourly rate if hours are estimated
      if (task.estimatedHours && task.estimatedHours > 0 && value > 0) {
        const hourlyRate = value / task.estimatedHours;
        const rateBadge = DOM.create('span', 'task-badge rate');
        rateBadge.textContent = `$${hourlyRate.toFixed(0)}/hr`;
        rateBadge.style.backgroundColor = isIncome ? '#10b981' : '#f59e0b';
        rateBadge.style.color = 'white';
        badges.appendChild(rateBadge);
      }

      // Show ROI if both estimated and actual values exist
      if (task.actualValue && task.estimatedValue && task.estimatedValue > 0) {
        const roi = ((task.actualValue - task.estimatedValue) / task.estimatedValue * 100).toFixed(1);
        const roiColor = roi >= 0 ? '#10b981' : '#ef4444';
        const roiBadge = DOM.create('span', 'task-badge roi');
        roiBadge.textContent = `${roi >= 0 ? '+' : ''}${roi}%`;
        roiBadge.style.backgroundColor = roiColor;
        roiBadge.style.color = 'white';
        badges.appendChild(roiBadge);
      }
    }
      if (badges.childNodes.length > 0) {
        item.appendChild(badges);
      }
  
      const meta = DOM.create('div', 'task-meta-grid');
      const { start, end } = getTaskRange(task);
      if (start || end) {
        const dateText = start && end && start.getTime() !== end.getTime()
          ? `${DateUtils.formatDate(start)} → ${DateUtils.formatDate(end)}`
          : DateUtils.formatDate(start || end);
        meta.appendChild(DOM.create('div', 'task-meta-item', `Dates: ${dateText}`));
      }
      if (task.startTime || task.endTime) {
        const range = [task.startTime, task.endTime].filter(Boolean).join(' - ');
        meta.appendChild(DOM.create('div', 'task-meta-item', `Time: ${range}`));
      }
      const durationDays = getTaskDurationDays(task);
      if (durationDays > 0) {
        meta.appendChild(DOM.create('div', 'task-meta-item', `Duration: ${durationDays + 1} days`));
      }
      const dueInfo = getTaskDueInfo(task);
      meta.appendChild(DOM.create('div', `task-meta-item task-due ${dueInfo.status}`, dueInfo.label));
    if (task.impactType && task.impactType !== 'non-monetary') {
      const impactLabel = task.impactType === 'money' ? 'Financial Impact' : 'Long-term Value';
      meta.appendChild(DOM.create('div', 'task-meta-item', `Impact: ${impactLabel}`));
    }
      item.appendChild(meta);
  
      return item;
    }
  };
  
  const TaskActions = {
    async deleteTask(task) {
      if (!confirm(`Delete task "${task.task}"?`)) return;
      
      const operationId = `delete-task-${task.id}`;
      await SaveManager.saveWithOptimisticUpdate(
        operationId,
        () => {
          AppState.tasks = AppState.tasks.filter(item => item.id !== task.id);
        },
        async () => {
          await API.saveTasks(AppState.tasks);
        },
        () => {
          Toast.success('Task deleted');
        },
        (error) => {
          Toast.error('Error deleting task. Please try again.');
        }
      );
    }
  };
  
  // Tasks Page
  const TasksPage = {
    render() {
      const container = DOM.create('div', '');
      
      const header = DOM.create('div', 'page-header');
      header.style.display = 'flex';
      header.style.justifyContent = 'space-between';
      header.style.alignItems = 'center';
      
      const titleSection = DOM.create('div', '');
      titleSection.appendChild(DOM.create('h1', 'page-title', 'Tasks'));
      titleSection.appendChild(DOM.create('p', 'page-subtitle', 'Manage your tasks'));
      header.appendChild(titleSection);
      
      const addBtn = DOM.create('button', 'btn btn-primary');
      addBtn.textContent = '+ Add Task';
      addBtn.onclick = () => TaskModal.show();
      header.appendChild(addBtn);
      
      container.appendChild(header);
  
      container.appendChild(this.renderSummary());
      container.appendChild(this.renderInsights());
      container.appendChild(TaskFilters.renderFilterBar('Task Filters'));
  
      const taskList = DOM.create('div', 'task-list');
      const filteredTasks = TaskFilters.applyFilters(AppState.tasks);
      if (filteredTasks.length === 0) {
        const emptyState = DOM.create('div', 'empty-state');
        emptyState.style.textAlign = 'center';
        emptyState.style.padding = '3rem';
        emptyState.style.color = '#6b7280';
        emptyState.innerHTML = '<p style="font-size: 1.125rem; margin-bottom: 0.5rem;">No tasks found</p><p>Try a different search or clear the search box</p>';
        taskList.appendChild(emptyState);
      } else {
        filteredTasks.forEach(task => {
          const item = Dashboard.renderTask(task);
          item.onclick = () => TaskModal.show(task);
          taskList.appendChild(item);
        });
      }
      
      container.appendChild(taskList);
  
      return container;
    },
  
    getSummaryStats() {
      const tasks = AppState.tasks;
      const today = new Date();
      today.setHours(0, 0, 0, 0);
      const isOverdue = (task) => {
        if (task.status === 'completed') return false;
        const dueDate = DateUtils.parseDate(task.endDate || task.startDate);
        return dueDate && dueDate < today;
      };
      const isDueToday = (task) => {
        if (task.status === 'completed') return false;
        const dueDate = DateUtils.parseDate(task.endDate || task.startDate);
        return dueDate && dueDate.getTime() === today.getTime();
      };
      const isUpcoming = (task) => {
        if (task.status === 'completed') return false;
        const dueDate = DateUtils.parseDate(task.endDate || task.startDate);
        if (!dueDate) return false;
        const diff = Math.round((dueDate.getTime() - today.getTime()) / (1000 * 60 * 60 * 24));
        return diff > 0 && diff <= 7;
      };
  
      const completed = tasks.filter(task => task.status === 'completed').length;
      const overdue = tasks.filter(isOverdue).length;
      const dueToday = tasks.filter(isDueToday).length;
      const upcoming = tasks.filter(isUpcoming).length;
      const highPriorityPending = tasks.filter(task => task.priority === 'high' && task.status !== 'completed').length;
      const missingDates = tasks.filter(task => !(task.startDate || task.endDate)).length;
      const durations = tasks
        .map(task => getTaskDurationDays(task))
        .filter(duration => duration > 0)
        .map(duration => duration + 1);
      const avgDuration = durations.length
        ? Math.round(durations.reduce((sum, duration) => sum + duration, 0) / durations.length)
        : 0;
  
      const objectiveLoad = tasks.reduce((acc, task) => {
        if (task.status === 'completed') return acc;
        const key = task.objectiveId ? getObjectiveName(task.objectiveId) : 'No objective';
        acc[key] = (acc[key] || 0) + 1;
        return acc;
      }, {});
      const topObjective = Object.entries(objectiveLoad)
        .sort((a, b) => b[1] - a[1])[0];
  
      const categoryLoad = tasks.reduce((acc, task) => {
        if (task.status === 'completed') return acc;
        const key = task.category || 'No category';
        acc[key] = (acc[key] || 0) + 1;
        return acc;
      }, {});
      const topCategory = Object.entries(categoryLoad)
        .sort((a, b) => b[1] - a[1])[0];
  
      return {
        total: tasks.length,
        completed,
        overdue,
        dueToday,
        upcoming,
        highPriorityPending,
        missingDates,
        avgDuration,
        completionRate: tasks.length ? Math.round((completed / tasks.length) * 100) : 0,
        topObjective: topObjective ? { name: topObjective[0], count: topObjective[1] } : null,
        topCategory: topCategory ? { name: topCategory[0], count: topCategory[1] } : null
      };
    },
  
    renderSummary() {
      const summary = this.getSummaryStats();
  
      const grid = DOM.create('div', 'task-summary-grid');
      const cards = [
        { label: 'Total Tasks', value: summary.total },
        { label: 'Completed', value: summary.completed },
        { label: 'Overdue', value: summary.overdue },
        { label: 'Due Today', value: summary.dueToday },
        { label: 'Due Soon', value: summary.upcoming }
      ];
  
      cards.forEach(card => {
        const cardEl = DOM.create('div', 'task-summary-card');
        cardEl.appendChild(DOM.create('div', 'task-summary-value', card.value.toString()));
        cardEl.appendChild(DOM.create('div', 'task-summary-label', card.label));
        grid.appendChild(cardEl);
      });
  
      return grid;
    },
  
    renderInsights() {
      const stats = this.getSummaryStats();
      const card = DOM.create('div', 'card');
      card.appendChild(DOM.create('h2', '', 'Smart Task Insights'));
  
      const metrics = DOM.create('div', 'insights-metrics');
      const metricItems = [
        { label: 'Completion Rate', value: `${stats.completionRate}%` },
        { label: 'Avg Duration', value: stats.avgDuration ? `${stats.avgDuration} days` : '—' },
        { label: 'High Priority Pending', value: stats.highPriorityPending.toString() },
        { label: 'Missing Dates', value: stats.missingDates.toString() },
        { label: 'Top Objective', value: stats.topObjective ? `${stats.topObjective.name} (${stats.topObjective.count})` : '—' },
        { label: 'Top Category', value: stats.topCategory ? `${stats.topCategory.name} (${stats.topCategory.count})` : '—' }
      ];
  
      metricItems.forEach(item => {
        const metric = DOM.create('div', 'insights-metric');
        metric.appendChild(DOM.create('div', 'insights-metric-value', item.value));
        metric.appendChild(DOM.create('div', 'insights-metric-label', item.label));
        metrics.appendChild(metric);
      });
      card.appendChild(metrics);
  
      const list = DOM.create('div', 'insights-list');
      const advice = [];
      if (stats.total === 0) {
        advice.push('Add tasks to unlock workload predictions.');
      } else {
        advice.push(stats.overdue > 0
          ? `You have ${stats.overdue} overdue task${stats.overdue === 1 ? '' : 's'} — focus on the highest priority first.`
          : 'No overdue tasks — great pacing this week.');
        if (stats.dueToday > 0) {
          advice.push(`${stats.dueToday} task${stats.dueToday === 1 ? '' : 's'} due today — protect time blocks.`);
        }
        if (stats.upcoming > 0) {
          advice.push(`${stats.upcoming} task${stats.upcoming === 1 ? '' : 's'} due in the next 7 days.`);
        }
        if (stats.highPriorityPending > 0) {
          advice.push(`High priority pending: ${stats.highPriorityPending}. Consider tackling one next.`);
        }
        if (stats.missingDates > 0) {
          advice.push(`Add dates to ${stats.missingDates} task${stats.missingDates === 1 ? '' : 's'} to sharpen predictions.`);
        }
        if (stats.topObjective && stats.topObjective.name !== 'No objective') {
          advice.push(`Most active objective: ${stats.topObjective.name} (${stats.topObjective.count} open task${stats.topObjective.count === 1 ? '' : 's'}).`);
        }
        if (stats.completionRate < 50 && stats.total > 0) {
          advice.push('Completion rate is below 50%. Consider breaking tasks into smaller steps.');
        }
      }
  
      advice.forEach(text => {
        const item = DOM.create('div', 'insights-item', text);
        list.appendChild(item);
      });
      card.appendChild(list);
      return card;
    }
  };
  
  // Calendar Page
  const CalendarPage = {
    render() {
      const container = DOM.create('div', '');
      
      const header = DOM.create('div', 'page-header');
      const titleWrap = DOM.create('div', '');
      titleWrap.appendChild(DOM.create('h1', 'page-title', 'Calendar'));
      titleWrap.appendChild(DOM.create('p', 'page-subtitle', 'Tasks and events by day'));
      header.appendChild(titleWrap);
  
      const navControls = DOM.create('div', 'calendar-nav');
      const prevBtn = DOM.create('button', 'btn btn-secondary btn-sm');
      prevBtn.innerHTML = DOM.getIconSVG('chevronLeft');
      prevBtn.onclick = () => this.navigateMonth(-1);
      const monthLabel = DOM.create('div', 'calendar-month-label');
      monthLabel.textContent = this.formatMonth(AppState.calendarCurrentDate);
      const nextBtn = DOM.create('button', 'btn btn-secondary btn-sm');
      nextBtn.innerHTML = DOM.getIconSVG('chevronRight');
      nextBtn.onclick = () => this.navigateMonth(1);
      const todayBtn = DOM.create('button', 'btn btn-secondary btn-sm');
      todayBtn.textContent = 'Today';
      todayBtn.onclick = () => this.goToToday();
      navControls.append(prevBtn, monthLabel, nextBtn, todayBtn);
      header.appendChild(navControls);
      container.appendChild(header);
  
      const calendar = DOM.create('div', 'calendar');
      const days = ['Sun', 'Mon', 'Tue', 'Wed', 'Thu', 'Fri', 'Sat'];
      days.forEach(day => {
        const dayHeader = DOM.create('div', 'calendar-day calendar-header');
        dayHeader.style.textAlign = 'center';
        dayHeader.style.fontWeight = 'bold';
        dayHeader.textContent = day;
        calendar.appendChild(dayHeader);
      });
  
      const viewDate = new Date(AppState.calendarCurrentDate);
      const startOfMonth = new Date(viewDate.getFullYear(), viewDate.getMonth(), 1);
      const endOfMonth = new Date(viewDate.getFullYear(), viewDate.getMonth() + 1, 0);
      const startOffset = startOfMonth.getDay();
  
      for (let i = 0; i < startOffset; i++) {
        const blank = DOM.create('div', 'calendar-day other-month');
        calendar.appendChild(blank);
      }
  
      const filteredTasks = TaskFilters.applySearch(AppState.tasks);
      const today = new Date();
      today.setHours(0, 0, 0, 0);
  
      for (let dayIndex = 1; dayIndex <= endOfMonth.getDate(); dayIndex++) {
        const date = new Date(viewDate.getFullYear(), viewDate.getMonth(), dayIndex);
        const cell = DOM.create('div', 'calendar-day');
        if (date.getTime() === today.getTime()) cell.classList.add('today');
        const label = DOM.create('div', 'calendar-day-number', dayIndex);
        cell.appendChild(label);
  
        const { tasksCount, eventsCount } = this.getCountsForDate(date, filteredTasks, AppState.events);
        if (tasksCount || eventsCount) {
          const badges = DOM.create('div', 'calendar-day-badges');
          if (tasksCount) {
            badges.appendChild(DOM.create('span', 'calendar-badge task', `${tasksCount} task${tasksCount === 1 ? '' : 's'}`));
          }
          if (eventsCount) {
            badges.appendChild(DOM.create('span', 'calendar-badge event', `${eventsCount} event${eventsCount === 1 ? '' : 's'}`));
          }
          cell.appendChild(badges);
        } else {
          cell.appendChild(DOM.create('div', 'calendar-day-empty', '—'));
        }
  
        cell.onclick = () => TaskModal.show(null, null, DateUtils.formatDate(date));
        calendar.appendChild(cell);
      }
  
      container.appendChild(calendar);
      return container;
    },
  
    navigateMonth(delta) {
      const next = new Date(AppState.calendarCurrentDate);
      next.setMonth(next.getMonth() + delta);
      AppState.calendarCurrentDate = next;
      Router.render();
    },
  
    goToToday() {
      AppState.calendarCurrentDate = new Date();
      Router.render();
    },
  
    formatMonth(date) {
      return date.toLocaleDateString(undefined, { month: 'long', year: 'numeric' });
    },
  
    getCountsForDate(date, tasks, events) {
      const dayStart = new Date(date);
      dayStart.setHours(0, 0, 0, 0);
      const dayEnd = new Date(dayStart);
      dayEnd.setHours(23, 59, 59, 999);
  
      const tasksCount = tasks.filter(task => {
        const start = DateUtils.parseDate(task.startDate || task.endDate);
        const end = DateUtils.parseDate(task.endDate || task.startDate);
        if (!start && !end) return false;
        const startDate = start || end;
        const endDate = end || start;
        return startDate <= dayEnd && endDate >= dayStart;
      }).length;
  
      const eventsCount = events.filter(eventItem => {
        const start = DateUtils.parseDate(eventItem.startDate || eventItem.endDate);
        const end = DateUtils.parseDate(eventItem.endDate || eventItem.startDate);
        if (!start && !end) return false;
        const startDate = start || end;
        const endDate = end || start;
        return startDate <= dayEnd && endDate >= dayStart;
      }).length;
  
      return { tasksCount, eventsCount };
    }
  };
  
  // Timeline Page (Task View)
  const TimelinePage = {
    render() {
      const container = DOM.create('div', '');
  
      const header = DOM.create('div', 'page-header');
      header.style.display = 'flex';
      header.style.justifyContent = 'space-between';
      header.style.alignItems = 'center';
  
      // Left section: Title and navigation
      const leftSection = DOM.create('div', '');
      leftSection.style.display = 'flex';
      leftSection.style.alignItems = 'center';
      leftSection.style.gap = '1rem';
      
      const titleSection = DOM.create('div', '');
      titleSection.appendChild(DOM.create('h1', 'page-title', 'Task'));
      titleSection.appendChild(DOM.create('p', 'page-subtitle', 'Calendar view of your tasks'));
      leftSection.appendChild(titleSection);
  
      const navControls = DOM.create('div', 'timeline-nav');
      navControls.style.display = 'flex';
      navControls.style.alignItems = 'center';
      navControls.style.gap = '0.5rem';
  
      const prevBtn = DOM.create('button', 'btn btn-secondary btn-sm');
      prevBtn.innerHTML = DOM.getIconSVG('chevronLeft');
      prevBtn.onclick = () => this.navigateTimeline(-1);
      navControls.appendChild(prevBtn);
  
      const monthYear = DOM.create('div', 'timeline-month-year');
      monthYear.textContent = this.formatViewLabel(AppState.timelineCurrentDate);
      monthYear.style.fontSize = '1.125rem';
      monthYear.style.fontWeight = '600';
      monthYear.style.minWidth = '140px';
      monthYear.style.textAlign = 'center';
      navControls.appendChild(monthYear);
  
      const nextBtn = DOM.create('button', 'btn btn-secondary btn-sm');
      nextBtn.innerHTML = DOM.getIconSVG('chevronRight');
      nextBtn.onclick = () => this.navigateTimeline(1);
      navControls.appendChild(nextBtn);
  
      const todayBtn = DOM.create('button', 'btn btn-secondary btn-sm');
      todayBtn.textContent = 'Today';
      todayBtn.onclick = () => this.goToToday();
      navControls.appendChild(todayBtn);
  
      leftSection.appendChild(navControls);
  
      // Right section: View toggle
      const rightSection = DOM.create('div', '');
      rightSection.style.display = 'flex';
      rightSection.style.gap = '0.5rem';
      rightSection.className = 'timeline-view-toggle';
  
      // On mobile, force day view and hide toggle buttons
      if (window.innerWidth <= 768) {
        AppState.timelineView = 'day';
      }
  
      const currentView = AppState.timelineView || 'month';
  
      const monthBtn = DOM.create('button', `btn btn-sm ${currentView === 'month' ? 'btn-primary' : 'btn-secondary'}`);
      monthBtn.textContent = 'Month';
      monthBtn.onclick = () => this.setView('month');
      rightSection.appendChild(monthBtn);
  
      const weekBtn = DOM.create('button', `btn btn-sm ${currentView === 'week' ? 'btn-primary' : 'btn-secondary'}`);
      weekBtn.textContent = 'Week';
      weekBtn.onclick = () => this.setView('week');
      rightSection.appendChild(weekBtn);
  
      const dayBtn = DOM.create('button', `btn btn-sm ${currentView === 'day' ? 'btn-primary' : 'btn-secondary'}`);
      dayBtn.textContent = 'Day';
      dayBtn.onclick = () => this.setView('day');
      rightSection.appendChild(dayBtn);
  
      header.appendChild(leftSection);
      header.appendChild(rightSection);
      container.appendChild(header);
  
      // Filter bar
      const filterBar = this.renderFilterBar();
      container.appendChild(filterBar);
  
      const timelineWrapper = DOM.create('div', 'timeline-wrapper');
      timelineWrapper.style.overflowX = 'auto';
      timelineWrapper.style.marginTop = '1rem';
      // On mobile, always use day view
      const viewToUse = window.innerWidth <= 768 ? 'day' : (AppState.timelineView || 'month');
      timelineWrapper.setAttribute('data-view', viewToUse);
  
      const timeline = DOM.create('div', 'timeline-container');
      this.renderTimeline(timeline);
      timelineWrapper.appendChild(timeline);
  
      container.appendChild(timelineWrapper);
  
      return container;
    },
  
    setView(view) {
      // On mobile, always use day view
      const isMobile = window.innerWidth <= 768;
      AppState.timelineView = isMobile ? 'day' : view;
      Router.render();
    },
  
    navigateTimeline(delta) {
      const currentDate = new Date(AppState.timelineCurrentDate);
      const view = AppState.timelineView || 'month';
      if (view === 'day') {
        currentDate.setDate(currentDate.getDate() + delta);
      } else if (view === 'week') {
        currentDate.setDate(currentDate.getDate() + (delta * 7));
      } else {
        currentDate.setMonth(currentDate.getMonth() + delta);
      }
      AppState.timelineCurrentDate = currentDate;
      Router.render();
    },
  
    goToToday() {
      AppState.timelineCurrentDate = new Date();
      Router.render();
    },
  
    formatMonthYear(date) {
      return date.toLocaleDateString('en-US', { year: 'numeric', month: 'long' });
    },
  
    formatViewLabel(date) {
      const view = AppState.timelineView || 'month';
      if (view === 'day') {
        return date.toLocaleDateString('en-US', {
          weekday: 'long',
          year: 'numeric',
          month: 'long',
          day: 'numeric'
        });
      }
      if (view === 'week') {
        const start = new Date(date);
        start.setDate(date.getDate() - date.getDay());
        const end = new Date(start);
        end.setDate(start.getDate() + 6);
        const startLabel = start.toLocaleDateString('en-US', { month: 'short', day: 'numeric' });
        const endLabel = end.toLocaleDateString('en-US', { month: 'short', day: 'numeric', year: 'numeric' });
        return `${startLabel} - ${endLabel}`;
      }
      return this.formatMonthYear(date);
    },
  
    renderFilterBar() {
      const filterBar = DOM.create('div', 'timeline-filter-bar');
      filterBar.style.display = 'flex';
      filterBar.style.flexWrap = 'wrap';
      filterBar.style.gap = '1rem';
      filterBar.style.marginBottom = '1rem';
      filterBar.style.padding = '1rem';
      filterBar.style.backgroundColor = '#f9fafb';
      filterBar.style.borderRadius = '0.5rem';
  
      // Status filter
      const statusFilter = DOM.create('div', 'filter-group');
      statusFilter.appendChild(DOM.create('label', '', 'Status:'));
      const statusContainer = DOM.create('div', '');
      statusContainer.style.display = 'flex';
      statusContainer.style.flexWrap = 'wrap';
      statusContainer.style.gap = '0.5rem';
  
      AppState.statuses.forEach(status => {
        const checkbox = DOM.create('input', '');
        checkbox.type = 'checkbox';
        checkbox.id = `status-${status.id}`;
        checkbox.checked = AppState.timelineFilters.statuses.includes(status.name);
        checkbox.onchange = () => this.toggleFilter('statuses', status.name);
  
        const label = DOM.create('label', '');
        label.htmlFor = `status-${status.id}`;
        label.style.display = 'flex';
        label.style.alignItems = 'center';
        label.style.gap = '0.25rem';
        label.style.padding = '0.25rem 0.5rem';
        label.style.borderRadius = '0.25rem';
        label.style.backgroundColor = status.color;
        label.style.color = 'white';
        label.style.fontSize = '0.75rem';
        label.style.cursor = 'pointer';
  
        label.appendChild(checkbox);
        label.appendChild(DOM.create('span', '', status.name));
        statusContainer.appendChild(label);
      });
  
      statusFilter.appendChild(statusContainer);
      filterBar.appendChild(statusFilter);
  
      // Category filter
      const categoryFilter = DOM.create('div', 'filter-group');
      categoryFilter.appendChild(DOM.create('label', '', 'Category:'));
      const categoryContainer = DOM.create('div', '');
      categoryContainer.style.display = 'flex';
      categoryContainer.style.flexWrap = 'wrap';
      categoryContainer.style.gap = '0.5rem';
  
      AppState.categories.forEach(category => {
        const checkbox = DOM.create('input', '');
        checkbox.type = 'checkbox';
        checkbox.id = `category-${category.id}`;
        checkbox.checked = AppState.timelineFilters.categories.includes(category.name);
        checkbox.onchange = () => this.toggleFilter('categories', category.name);
  
        const label = DOM.create('label', '');
        label.htmlFor = `category-${category.id}`;
        label.style.display = 'flex';
        label.style.alignItems = 'center';
        label.style.gap = '0.25rem';
        label.style.padding = '0.25rem 0.5rem';
        label.style.borderRadius = '0.25rem';
        label.style.backgroundColor = category.color;
        label.style.color = 'white';
        label.style.fontSize = '0.75rem';
        label.style.cursor = 'pointer';
  
        label.appendChild(checkbox);
        label.appendChild(DOM.create('span', '', category.name));
        categoryContainer.appendChild(label);
      });
  
      categoryFilter.appendChild(categoryContainer);
      filterBar.appendChild(categoryFilter);
  
      // Clear filters button
      const clearBtn = DOM.create('button', 'btn btn-secondary btn-sm');
      clearBtn.textContent = 'Clear Filters';
      clearBtn.onclick = () => this.clearFilters();
      filterBar.appendChild(clearBtn);
  
      return filterBar;
    },
  
    toggleFilter(type, value) {
      const filters = AppState.timelineFilters[type];
      const index = filters.indexOf(value);
      if (index > -1) {
        filters.splice(index, 1);
      } else {
        filters.push(value);
      }
      Router.render();
    },
  
    clearFilters() {
      AppState.timelineFilters = { statuses: [], categories: [], objectives: [] };
      Router.render();
    },
  
    applyFilters(tasks) {
      const filters = AppState.timelineFilters;
      const filtered = tasks.filter(task => {
        // Status filter
        if (filters.statuses.length > 0 && !filters.statuses.includes(task.status)) {
          return false;
        }
        // Category filter
        if (filters.categories.length > 0 && !filters.categories.includes(task.category)) {
          return false;
        }
        // Objective filter
        if (filters.objectives.length > 0 && task.objectiveId && !filters.objectives.includes(task.objectiveId.toString())) {
          return false;
        }
        if (filters.objectives.length > 0 && !task.objectiveId) {
          return false;
        }
        return true;
      });
      return TaskFilters.applySearch(filtered);
    },
  
    handleDragStart(e, task) {
      e.dataTransfer.setData('application/json', JSON.stringify(task));
      e.dataTransfer.effectAllowed = 'move';
      e.target.classList.add('timeline-task-dragging');
    },
  
    handleDragEnd(e) {
      e.target.classList.remove('timeline-task-dragging');
    },
  
    async handleDrop(e, newDate) {
      try {
        const task = JSON.parse(e.dataTransfer.getData('application/json'));
        if (task.repeatType && task.repeatType !== 'none') {
          Toast.error('Edit recurring tasks in the task form.');
          return;
        }
        const dateStr = newDate.getFullYear() + '-' +
          String(newDate.getMonth() + 1).padStart(2, '0') + '-' +
          String(newDate.getDate()).padStart(2, '0');
  
        const durationDays = getTaskDurationDays(task);
        const endDate = DateUtils.formatDate(DateUtils.addDays(newDate, durationDays));
        const updatedTask = { ...task, startDate: dateStr, endDate };
  
        const operationId = `update-task-date-${task.id}`;
        await SaveManager.saveWithOptimisticUpdate(
          operationId,
          () => {
            const taskIndex = AppState.tasks.findIndex(t => t.id === task.id);
            if (taskIndex !== -1) {
              AppState.tasks[taskIndex] = updatedTask;
            }
          },
          async () => {
            await API.saveTasks(AppState.tasks);
          },
          () => {
            // Silent success for drag and drop
          },
          (error) => {
            Toast.error('Error updating task date. Please try again.');
          }
        );
      } catch (error) {
        console.error('Error updating task date:', error);
        Toast.error('Error updating task date. Please try again.');
      }
    },
  
    async updateTaskData(taskId, updates) {
      const taskIndex = AppState.tasks.findIndex(t => t.id === taskId);
      if (taskIndex === -1) return;
      
      const operationId = `update-task-data-${taskId}`;
      await SaveManager.saveWithOptimisticUpdate(
        operationId,
        () => {
          const updatedTask = { ...AppState.tasks[taskIndex], ...updates };
          AppState.tasks[taskIndex] = updatedTask;
        },
        async () => {
          await API.saveTasks(AppState.tasks);
        },
        () => {
          // Silent success
        },
        (error) => {
          Toast.error('Error updating task');
        }
      );
    },
  
    isToday(date) {
      const today = new Date();
      return date.getDate() === today.getDate() &&
             date.getMonth() === today.getMonth() &&
             date.getFullYear() === today.getFullYear();
    },
  
    renderTimeline(container) {
      // On mobile, always use day view
      const view = window.innerWidth <= 768 ? 'day' : (AppState.timelineView || 'month');
      const currentDate = AppState.timelineCurrentDate;
      let startDate, endDate, days = [];
  
      if (view === 'day') {
        startDate = DateUtils.parseDate(currentDate);
        endDate = DateUtils.parseDate(currentDate);
        days = [new Date(startDate)];
      } else if (view === 'week') {
        // Get current week for the selected month
        const dayOfWeek = currentDate.getDay();
        startDate = new Date(currentDate);
        startDate.setDate(currentDate.getDate() - dayOfWeek);
        startDate = DateUtils.parseDate(startDate);
        endDate = DateUtils.addDays(startDate, 6);
  
        for (let i = 0; i < 7; i++) {
          const date = new Date(startDate);
          date.setDate(startDate.getDate() + i);
          days.push(date);
        }
      } else {
        // Get current month
        startDate = new Date(currentDate.getFullYear(), currentDate.getMonth(), 1);
        endDate = new Date(currentDate.getFullYear(), currentDate.getMonth() + 1, 0);
        startDate = DateUtils.parseDate(startDate);
        endDate = DateUtils.parseDate(endDate);
  
        // Add days from previous month to fill first week
        const firstDay = startDate.getDay();
        for (let i = firstDay - 1; i >= 0; i--) {
          const date = new Date(startDate);
          date.setDate(startDate.getDate() - i - 1);
          days.push(date);
        }
  
        // Add all days of current month
        for (let i = 1; i <= endDate.getDate(); i++) {
          const date = new Date(currentDate.getFullYear(), currentDate.getMonth(), i);
          days.push(date);
        }
  
        // Add days from next month to fill last week
        const lastDay = endDate.getDay();
        for (let i = 1; i <= 6 - lastDay; i++) {
          const date = new Date(endDate);
          date.setDate(endDate.getDate() + i);
          days.push(date);
        }
      }
  
      // Timeline body with tasks
      const body = DOM.create('div', 'timeline-body');
  
      // Apply filters and group tasks by date
      const filteredTasks = this.applyFilters(AppState.tasks);
      const rangeStart = days[0];
      const rangeEnd = days[days.length - 1];
      const occurrences = getTaskOccurrences(filteredTasks, rangeStart, rangeEnd);
      const tasksByDate = {};
      occurrences.forEach(task => {
        const start = DateUtils.parseDate(task.occurrenceStart || task.startDate);
        const end = DateUtils.parseDate(task.occurrenceEnd || task.endDate || task.startDate);
        if (!start || !end) return;
        let cursor = new Date(start);
        while (cursor <= end) {
          const dateKey = this.getDateKey(cursor);
          if (!tasksByDate[dateKey]) {
            tasksByDate[dateKey] = [];
          }
          tasksByDate[dateKey].push(task);
          cursor = DateUtils.addDays(cursor, 1);
        }
      });
  
      // Create timeline rows for each day
      days.forEach(day => {
        const dayColumn = DOM.create('div', 'timeline-day-column');
        const dateKey = this.getDateKey(day);
        const dayTasks = tasksByDate[dateKey] || [];
        const isCurrentMonth = day.getMonth() === AppState.timelineCurrentDate.getMonth();
        const isCollapsed = !!AppState.timelineCollapsedDates[dateKey];
  
        // Styling for different day types
        if (!isCurrentMonth) {
          dayColumn.classList.add('timeline-day-other-month');
        } else if (this.isToday(day)) {
          dayColumn.classList.add('timeline-day-today');
        } else if (day.getDay() === 0 || day.getDay() === 6) {
          dayColumn.classList.add('timeline-day-weekend');
        }
  
        const dayHeader = DOM.create('div', 'timeline-day-column-header');
        const headerInfo = DOM.create('div', 'timeline-day-header-info');
        headerInfo.appendChild(DOM.create('div', 'timeline-day-name',
          ['Sun', 'Mon', 'Tue', 'Wed', 'Thu', 'Fri', 'Sat'][day.getDay()]));
        headerInfo.appendChild(DOM.create('div', 'timeline-day-number', day.getDate()));
        dayHeader.appendChild(headerInfo);
  
        const dateStr = DateUtils.formatDate(day);
        const addBtn = DOM.create('button', 'timeline-day-add');
        addBtn.innerHTML = DOM.getIconSVG('plus');
        addBtn.onclick = (e) => {
          e.stopPropagation();
          TaskModal.show(null, null, dateStr);
        };
        dayHeader.appendChild(addBtn);
  
        const collapseButton = DOM.create('button', 'timeline-day-toggle');
        collapseButton.textContent = isCollapsed ? 'Show' : 'Hide';
        collapseButton.onclick = (e) => {
          e.stopPropagation();
          const nextCollapsed = !dayColumn.classList.contains('collapsed');
          dayColumn.classList.toggle('collapsed', nextCollapsed);
          AppState.timelineCollapsedDates[dateKey] = nextCollapsed;
          collapseButton.textContent = nextCollapsed ? 'Show' : 'Hide';
        };
        dayHeader.appendChild(collapseButton);
        dayColumn.appendChild(dayHeader);
  
        // Make day droppable for drag and drop
        dayColumn.ondragover = (e) => {
          e.preventDefault();
          dayColumn.classList.add('timeline-day-drop-target');
        };
        dayColumn.ondragleave = (e) => {
          dayColumn.classList.remove('timeline-day-drop-target');
        };
        dayColumn.ondrop = (e) => {
          e.preventDefault();
          dayColumn.classList.remove('timeline-day-drop-target');
          this.handleDrop(e, day);
        };
  
        // Make day clickable to add task
        dayColumn.onclick = (e) => {
          if (e.target === dayColumn || e.target.classList.contains('timeline-day-empty')) {
            TaskModal.show(null, null, dateStr);
          }
        };
        dayColumn.style.cursor = 'pointer';
  
        // Add hover effect for add indicator
        dayColumn.onmouseenter = () => {
          if (dayTasks.length === 0) {
            const addIndicator = dayColumn.querySelector('.add-task-indicator');
            if (addIndicator) addIndicator.style.opacity = '1';
          }
        };
        dayColumn.onmouseleave = () => {
          const addIndicator = dayColumn.querySelector('.add-task-indicator');
          if (addIndicator) addIndicator.style.opacity = '0';
        };
  
        if (isCollapsed) {
          dayColumn.classList.add('collapsed');
        }
  
        const tasksContainer = DOM.create('div', 'timeline-day-tasks');
        const collapsedSummary = DOM.create('div', 'timeline-day-collapsed-summary', `${dayTasks.length} tasks hidden`);
        dayColumn.appendChild(collapsedSummary);
  
        if (view === 'day') {
          this.renderDaySchedule(tasksContainer, dayTasks, day);
        } else {
          dayTasks.forEach(task => {
            tasksContainer.appendChild(this.renderTaskCard(task));
          });
  
          // Add empty state if no tasks
          if (dayTasks.length === 0) {
            const emptyDay = DOM.create('div', 'timeline-day-empty');
            const addIndicator = DOM.create('div', 'add-task-indicator');
            addIndicator.innerHTML = DOM.getIconSVG('plus');
            addIndicator.style.opacity = '0';
            addIndicator.style.position = 'absolute';
            addIndicator.style.top = '0.5rem';
            addIndicator.style.right = '0.5rem';
            addIndicator.style.width = '20px';
            addIndicator.style.height = '20px';
            addIndicator.style.color = '#6b7280';
            addIndicator.style.transition = 'opacity 0.2s';
            emptyDay.appendChild(addIndicator);
  
            const text = DOM.create('div', '');
            text.textContent = 'Click to add task';
            text.style.fontSize = '0.75rem';
            text.style.color = '#9ca3af';
            emptyDay.appendChild(text);
  
            tasksContainer.appendChild(emptyDay);
          }
        }
  
        dayColumn.appendChild(tasksContainer);
  
        body.appendChild(dayColumn);
      });
      
      container.appendChild(body);
    },
  
    renderTaskCard(task) {
      const taskBar = DOM.create('div', 'timeline-task-bar');
      const statusColor = AppState.statuses.find(s => s.name === task.status)?.color || '#3b82f6';
      const objectiveColor = getObjectiveColor(task.objectiveId);
      const accentColor = objectiveColor || statusColor;
      taskBar.style.backgroundColor = accentColor;
      taskBar.style.borderLeftColor = accentColor;
  
      const taskContent = DOM.create('div', 'timeline-task-content');
  
      const title = DOM.create('div', 'timeline-task-title');
      title.textContent = task.task.length > 25 ? task.task.substring(0, 25) + '...' : task.task;
      title.title = task.task;
      taskContent.appendChild(title);
  
      const meta = DOM.create('div', 'timeline-task-meta');
      const rangeStart = task.occurrenceStart || task.startDate;
      const rangeEnd = task.occurrenceEnd || task.endDate || task.startDate;
      const rangeInfo = rangeStart && rangeEnd ? ` • ${rangeStart} → ${rangeEnd}` : '';
      const timeInfo = task.startTime || task.endTime
        ? ` • ${(task.startTime || '')}${task.endTime ? `-${task.endTime}` : ''}`
        : '';
      const categoryInfo = task.category ? ` • ${task.category}` : '';
      const objectiveName = task.objectiveId ? getObjectiveName(task.objectiveId) : '';
      const objectiveInfo = objectiveName ? ` • ${objectiveName}` : '';
      const priorityInfo = task.priority ? ` • ${task.priority}` : '';
      const repeatInfo = task.repeatType && task.repeatType !== 'none' ? ` • ${task.repeatType}` : '';
      meta.textContent = `${task.status}${rangeInfo}${timeInfo}${categoryInfo}${objectiveInfo}${priorityInfo}${repeatInfo}`;
      taskContent.appendChild(meta);
  
      taskBar.appendChild(taskContent);
  
      if (!task.repeatType || task.repeatType === 'none') {
        taskBar.draggable = true;
        taskBar.ondragstart = (e) => this.handleDragStart(e, task);
        taskBar.ondragend = (e) => this.handleDragEnd(e);
      }
  
      taskBar.onclick = (e) => {
        if (!e.defaultPrevented) TaskModal.show(task);
      };
  
      const tooltipRange = rangeStart && rangeEnd ? `${rangeStart} → ${rangeEnd}` : '';
      const repeatInfoText = task.repeatType && task.repeatType !== 'none'
        ? `\nRepeat: ${task.repeatType}${task.repeatUntil ? ' until ' + task.repeatUntil : ''}`
        : '';
      const timeRangeText = task.startTime || task.endTime
        ? `\nTime: ${task.startTime || ''}${task.endTime ? ' - ' + task.endTime : ''}`
        : '';
      const hourlyInfo = task.estimatedHours && task.estimatedHours > 0 && (task.estimatedValue || task.actualValue) ?
        `\nHourly Rate: $${((task.actualValue || task.estimatedValue || 0) / task.estimatedHours).toFixed(2)}/hour` : '';

      const objName = task.objectiveId ? getObjectiveName(task.objectiveId) : '';
      taskBar.title = `${task.task}\nStatus: ${task.status}${tooltipRange ? '\nRange: ' + tooltipRange : ''}${timeRangeText}${repeatInfoText}${task.category ? '\nCategory: ' + task.category : ''}${objName ? '\nObjective: ' + objName : ''}${task.priority ? '\nPriority: ' + task.priority : ''}${hourlyInfo}`;
  
      const statusIndicator = DOM.create('div', `timeline-task-status ${task.status}`);
      taskBar.appendChild(statusIndicator);
  
      return taskBar;
    },
  
    renderDaySchedule(container, dayTasks, selectedDate) {
      const allDayTasks = [];
      const tasksByHour = {};
      const selectedKey = this.getDateKey(selectedDate);
  
      dayTasks.forEach(task => {
        const rangeStart = DateUtils.parseDate(task.startDate || task.occurrenceStart);
        const rangeEnd = DateUtils.parseDate(task.endDate || task.occurrenceEnd || task.startDate);
        const startMinutes = this.getTaskStartMinutes(task);
        const endMinutes = this.getTaskEndMinutes(task);
  
        if (!startMinutes && !endMinutes) {
          allDayTasks.push(task);
          return;
        }
  
        let startHour = 0;
        let endHour = 23;
  
        if (rangeStart && this.getDateKey(rangeStart) === selectedKey && startMinutes !== null) {
          startHour = Math.floor(startMinutes / 60);
        }
        if (rangeEnd && this.getDateKey(rangeEnd) === selectedKey && endMinutes !== null) {
          endHour = Math.max(startHour, Math.ceil(endMinutes / 60));
        }
  
        for (let hour = startHour; hour <= endHour; hour += 1) {
          if (!tasksByHour[hour]) tasksByHour[hour] = [];
          tasksByHour[hour].push(task);
        }
      });
  
      if (allDayTasks.length > 0) {
        const allDaySection = DOM.create('div', 'timeline-day-all-day');
        const allDayLabel = DOM.create('div', 'timeline-day-all-day-label', 'All Day');
        allDaySection.appendChild(allDayLabel);
        allDayTasks.forEach(task => allDaySection.appendChild(this.renderTaskCard(task)));
        container.appendChild(allDaySection);
      }
  
      const hoursContainer = DOM.create('div', 'timeline-day-hours');
      for (let hour = 0; hour < 24; hour += 1) {
        const hourRow = DOM.create('div', 'timeline-hour-row');
        const hourLabel = DOM.create('div', 'timeline-hour-label', `${String(hour).padStart(2, '0')}:00`);
        const hourTasks = DOM.create('div', 'timeline-hour-tasks');
  
        (tasksByHour[hour] || []).forEach(task => {
          hourTasks.appendChild(this.renderTaskCard(task));
        });
  
        if (!tasksByHour[hour] || tasksByHour[hour].length === 0) {
          hourTasks.appendChild(DOM.create('div', 'timeline-hour-empty', ''));
        }
  
        hourRow.appendChild(hourLabel);
        hourRow.appendChild(hourTasks);
        hoursContainer.appendChild(hourRow);
      }
  
      if (dayTasks.length === 0) {
        const emptyDay = DOM.create('div', 'timeline-day-empty');
        const text = DOM.create('div', '');
        text.textContent = 'No tasks for this day';
        text.style.fontSize = '0.875rem';
        text.style.color = '#9ca3af';
        emptyDay.appendChild(text);
        container.appendChild(emptyDay);
      }
  
      container.appendChild(hoursContainer);
    },
  
    getTaskStartMinutes(task) {
      if (!task.startTime) return null;
      const match = task.startTime.trim().match(/(\d{1,2})(?::(\d{2}))?\s*(AM|PM)?/i);
      if (!match) return null;
      let hour = parseInt(match[1], 10);
      const minutes = parseInt(match[2] || '0', 10);
      const meridian = match[3];
      if (meridian) {
        const upper = meridian.toUpperCase();
        if (upper === 'PM' && hour < 12) hour += 12;
        if (upper === 'AM' && hour === 12) hour = 0;
      }
      if (hour < 0 || hour > 23 || minutes < 0 || minutes > 59) return null;
      return hour * 60 + minutes;
    },
  
    getTaskEndMinutes(task) {
      if (!task.endTime) return null;
      const match = task.endTime.trim().match(/(\d{1,2})(?::(\d{2}))?\s*(AM|PM)?/i);
      if (!match) return null;
      let hour = parseInt(match[1], 10);
      const minutes = parseInt(match[2] || '0', 10);
      const meridian = match[3];
      if (meridian) {
        const upper = meridian.toUpperCase();
        if (upper === 'PM' && hour < 12) hour += 12;
        if (upper === 'AM' && hour === 12) hour = 0;
      }
      if (hour < 0 || hour > 23 || minutes < 0 || minutes > 59) return null;
      return hour * 60 + minutes;
    },
  
    getDateKey(date) {
      return `${date.getFullYear()}-${String(date.getMonth() + 1).padStart(2, '0')}-${String(date.getDate()).padStart(2, '0')}`;
    },
  
    isToday(date) {
      const today = new Date();
      return date.getDate() === today.getDate() &&
             date.getMonth() === today.getMonth() &&
             date.getFullYear() === today.getFullYear();
    }
  };
  
  // Finance Page
  const FinancePage = {
    render() {
      const container = DOM.create('div', '');
  
      const header = DOM.create('div', 'page-header');
      header.appendChild(DOM.create('h1', 'page-title', 'Finance'));
      header.appendChild(DOM.create('p', 'page-subtitle', 'Track income, expenses, and budgets'));
      container.appendChild(header);
  
      // Tabs
      const tabs = DOM.create('div', 'reference-tabs');
      const tabList = [
        { id: 'transactions', label: 'Transactions' },
        { id: 'recurring', label: 'Recurring Bills' },
        { id: 'categories', label: 'Categories' }
       
      ];
  
      tabList.forEach(tab => {
        const tabBtn = DOM.create('button', 'reference-tab');
        tabBtn.textContent = tab.label;
        if (AppState.financeTab === tab.id) tabBtn.classList.add('active');
        tabBtn.onclick = () => {
          AppState.financeTab = tab.id;
          Router.render();
        };
        tabs.appendChild(tabBtn);
      });
  
      container.appendChild(tabs);
  
      const content = DOM.create('div', 'reference-content');
      if (AppState.financeTab === 'categories') {
        content.appendChild(FinanceCategoriesPage.render());
      } else if (AppState.financeTab === 'recurring') {
        content.appendChild(RecurringBillsPage.render());
      } else {
        // Transactions tab
        const controls = DOM.create('div', 'finance-controls');
        const monthLabel = DOM.create('label', 'finance-label', 'Month');
        const monthInput = DOM.create('input', 'form-input');
        monthInput.type = 'month';
        monthInput.value = this.getMonthKey(AppState.financeMonth);
        monthInput.onchange = (event) => {
          AppState.financeMonth = new Date(`${event.target.value}-01`);
          Router.render();
        };
        monthLabel.appendChild(monthInput);
  
        const ratioBadge = DOM.create('div', 'finance-ratio-badge');
        const monthTotals = this.getTotals(this.getMonthlyRecords());
        const percentSpent = monthTotals.income > 0
          ? Math.round((monthTotals.expenses / monthTotals.income) * 100)
          : 0;
        ratioBadge.innerHTML = `
          <span class="finance-ratio-label">Income vs Spend</span>
          <span class="finance-ratio-value">${percentSpent}% spent</span>
        `;
  
        controls.appendChild(monthLabel);
        controls.appendChild(ratioBadge);
        content.appendChild(controls);
  
        const monthRecords = this.getMonthlyRecords();
        const filteredRecords = this.applyFinanceFilters(monthRecords);
        
        // Overview
        content.appendChild(this.renderFinanceDashboard(filteredRecords));
        
        // Filters and transactions
        content.appendChild(this.renderFinanceFilters(monthRecords));
        content.appendChild(this.renderAddForm());
        content.appendChild(this.renderDailyBreakdown(filteredRecords));
      }
  
      container.appendChild(content);
  
      return container;
    },
  
    renderSummary(records) {
      const totals = this.getTotals(records);
      const budget = this.getMonthlyBudget(this.getMonthKey(AppState.financeMonth));
      const remaining = budget > 0 ? budget - totals.expenses : null;
      const exceeded = remaining !== null && remaining < 0;
      const budgetProgress = budget > 0 ? Math.min(100, Math.round((totals.expenses / budget) * 100)) : 0;
  
      const summary = DOM.create('div', 'finance-summary');
      summary.innerHTML = `
        <div class="finance-summary-card">
          <div class="finance-summary-label">Income</div>
          <div class="finance-summary-value income">${this.formatCurrency(totals.income)}</div>
        </div>
        <div class="finance-summary-card">
          <div class="finance-summary-label">Expenses</div>
          <div class="finance-summary-value expense">${this.formatCurrency(totals.expenses)}</div>
        </div>
        <div class="finance-summary-card">
          <div class="finance-summary-label">Net</div>
          <div class="finance-summary-value">${this.formatCurrency(totals.net)}</div>
        </div>
        <div class="finance-summary-card">
          <div class="finance-summary-label">Budget</div>
          <div class="finance-summary-value ${exceeded ? 'expense' : 'income'}">
            ${budget > 0 ? this.formatCurrency(remaining) : 'Not set'}
          </div>
          <div class="finance-summary-sub">
            ${budget > 0 ? (exceeded ? 'Over budget' : 'Remaining') : 'Set a monthly budget'}
          </div>
          ${budget > 0 ? `
            <div class="finance-budget-progress">
              <span style="width: ${budgetProgress}%;" class="${exceeded ? 'danger' : ''}"></span>
            </div>
            <div class="finance-budget-text">${budgetProgress}% used</div>
          ` : ''}
        </div>
      `;
      return summary;
    },
  
    renderFinanceDashboard(records) {
      const wrapper = DOM.create('div', '');
      wrapper.appendChild(this.renderSummary(records));
  
      const chartsCard = DOM.create('div', 'finance-card');
      chartsCard.appendChild(DOM.create('h2', 'section-title', 'Cashflow & Spending'));
      const grid = DOM.create('div', 'finance-chart-grid');
  
      const cashflowWrap = DOM.create('div', 'finance-chart-card');
      cashflowWrap.appendChild(DOM.create('div', 'finance-chart-title', 'Monthly Cashflow'));
      const cashflowCanvas = DOM.create('canvas', '');
      cashflowCanvas.id = 'financeCashflowLine';
      cashflowWrap.appendChild(cashflowCanvas);
      grid.appendChild(cashflowWrap);
  
      const categoryWrap = DOM.create('div', 'finance-chart-card');
      categoryWrap.appendChild(DOM.create('div', 'finance-chart-title', 'Top Categories'));
      const categoryCanvas = DOM.create('canvas', '');
      categoryCanvas.id = 'financeCategorySpendBar';
      categoryWrap.appendChild(categoryCanvas);
      grid.appendChild(categoryWrap);
  
      const trendWrap = DOM.create('div', 'finance-chart-card finance-chart-compact');
      trendWrap.appendChild(DOM.create('div', 'finance-chart-title', 'Daily Spend Trend'));
      const trendCanvas = DOM.create('canvas', '');
      trendCanvas.id = 'financeDailySpendSparkline';
      trendCanvas.height = 120;
      trendWrap.appendChild(trendCanvas);
      grid.appendChild(trendWrap);
  
      const splitWrap = DOM.create('div', 'finance-chart-card finance-chart-compact');
      splitWrap.appendChild(DOM.create('div', 'finance-chart-title', 'Income vs Expense'));
      const splitCanvas = DOM.create('canvas', '');
      splitCanvas.id = 'financeIncomeExpenseDonut';
      splitCanvas.height = 120;
      splitWrap.appendChild(splitCanvas);
      grid.appendChild(splitWrap);
  
      const budgetWrap = DOM.create('div', 'finance-chart-card');
      budgetWrap.appendChild(DOM.create('div', 'finance-chart-title', 'Budget vs Actual'));
      const budgetCanvas = DOM.create('canvas', '');
      budgetCanvas.id = 'financeBudgetActualBar';
      budgetWrap.appendChild(budgetCanvas);
      grid.appendChild(budgetWrap);
  
      chartsCard.appendChild(grid);
      wrapper.appendChild(chartsCard);
      wrapper.appendChild(this.renderHighlights(records));
  
      requestAnimationFrame(() => this.drawFinanceDashboardCharts(records));
      return wrapper;
    },
  
    drawFinanceDashboardCharts(records) {
      if (typeof Chart === 'undefined') return;
  
      const groupedByDate = records.reduce((acc, record) => {
        if (!record.date) return acc;
        if (!acc[record.date]) acc[record.date] = { income: 0, expense: 0 };
        const amount = Number(record.amount) || 0;
        if (record.type === 'income') acc[record.date].income += amount;
        else acc[record.date].expense += amount;
        return acc;
      }, {});
      const dates = Object.keys(groupedByDate).sort();
      const incomeSeries = dates.map(date => groupedByDate[date].income);
      const expenseSeries = dates.map(date => groupedByDate[date].expense);
  
      const cashflowCanvas = document.getElementById('financeCashflowLine');
      if (cashflowCanvas) {
        if (AppState.dashboardCharts.financeCashflowLine) {
          AppState.dashboardCharts.financeCashflowLine.destroy();
        }
        AppState.dashboardCharts.financeCashflowLine = new Chart(cashflowCanvas, {
          type: 'line',
          data: {
            labels: dates,
            datasets: [
              { label: 'Income', data: incomeSeries, borderColor: '#10b981', backgroundColor: 'rgba(16, 185, 129, 0.2)', fill: true, tension: 0.35 },
              { label: 'Expenses', data: expenseSeries, borderColor: '#ef4444', backgroundColor: 'rgba(239, 68, 68, 0.2)', fill: true, tension: 0.35 }
            ]
          },
          options: {
            responsive: true,
            plugins: { legend: { position: 'bottom' } },
            scales: { y: { beginAtZero: true } }
          }
        });
      }
  
      const categoryTotals = records
        .filter(record => record.type === 'expense')
        .reduce((acc, record) => {
          const key = record.category || 'Uncategorized';
          acc[key] = (acc[key] || 0) + (Number(record.amount) || 0);
          return acc;
        }, {});
      const categoryEntries = Object.entries(categoryTotals).sort((a, b) => b[1] - a[1]).slice(0, 5);
      const categoryLabels = categoryEntries.map(entry => entry[0]);
      const categoryData = categoryEntries.map(entry => entry[1]);
  
      const categoryCanvas = document.getElementById('financeCategorySpendBar');
      if (categoryCanvas) {
        if (AppState.dashboardCharts.financeCategorySpendBar) {
          AppState.dashboardCharts.financeCategorySpendBar.destroy();
        }
        AppState.dashboardCharts.financeCategorySpendBar = new Chart(categoryCanvas, {
          type: 'bar',
          data: {
            labels: categoryLabels,
            datasets: [{ label: 'Spend', data: categoryData, backgroundColor: '#3b82f6' }]
          },
          options: {
            plugins: { legend: { position: 'bottom' } },
            scales: { y: { beginAtZero: true } }
          }
        });
      }
  
      const dailySpend = dates.map(date => groupedByDate[date].expense);
      const trendCanvas = document.getElementById('financeDailySpendSparkline');
      if (trendCanvas) {
        if (AppState.dashboardCharts.financeDailySpendSparkline) {
          AppState.dashboardCharts.financeDailySpendSparkline.destroy();
        }
        AppState.dashboardCharts.financeDailySpendSparkline = new Chart(trendCanvas, {
          type: 'line',
          data: {
            labels: dates,
            datasets: [{
              data: dailySpend,
              borderColor: '#0ea5e9',
              backgroundColor: 'rgba(14, 165, 233, 0.2)',
              fill: true,
              tension: 0.35,
              pointRadius: 0
            }]
          },
          options: {
            plugins: { legend: { display: false } },
            scales: { x: { display: false }, y: { display: false } }
          }
        });
      }
  
      const totals = this.getTotals(records);
      const splitCanvas = document.getElementById('financeIncomeExpenseDonut');
      if (splitCanvas) {
        if (AppState.dashboardCharts.financeIncomeExpenseDonut) {
          AppState.dashboardCharts.financeIncomeExpenseDonut.destroy();
        }
        AppState.dashboardCharts.financeIncomeExpenseDonut = new Chart(splitCanvas, {
          type: 'doughnut',
          data: {
            labels: ['Income', 'Expenses'],
            datasets: [{
              data: [totals.income, totals.expenses],
              backgroundColor: ['#10b981', '#ef4444']
            }]
          },
          options: { plugins: { legend: { position: 'bottom' } } }
        });
      }
  
      const budgetCategories = AppState.financeCategories.filter(category => (Number(category.budget) || 0) > 0);
      const budgetLabels = budgetCategories.map(category => category.name);
      const budgetValues = budgetCategories.map(category => Number(category.budget) || 0);
      const actualValues = budgetCategories.map(category => {
        return records
          .filter(record => record.type === 'expense' && (record.category || 'Uncategorized') === category.name)
          .reduce((sum, record) => sum + (Number(record.amount) || 0), 0);
      });
  
      const budgetCanvas = document.getElementById('financeBudgetActualBar');
      if (budgetCanvas) {
        if (AppState.dashboardCharts.financeBudgetActualBar) {
          AppState.dashboardCharts.financeBudgetActualBar.destroy();
        }
        AppState.dashboardCharts.financeBudgetActualBar = new Chart(budgetCanvas, {
          type: 'bar',
          data: {
            labels: budgetLabels,
            datasets: [
              { label: 'Budget', data: budgetValues, backgroundColor: '#a855f7' },
              { label: 'Actual', data: actualValues, backgroundColor: '#f97316' }
            ]
          },
          options: {
            plugins: { legend: { position: 'bottom' } },
            scales: { y: { beginAtZero: true } }
          }
        });
      }
    },
  
    renderFinanceOverview(records) {
      const totals = this.getTotals(records);
      const percentSpent = totals.income > 0 ? Math.round((totals.expenses / totals.income) * 100) : 0;
  
      const card = DOM.create('div', 'finance-card');
      card.appendChild(DOM.create('h2', 'section-title', 'Finance Overview'));
  
      const metrics = DOM.create('div', 'finance-overview-grid');
      metrics.innerHTML = `
        <div class="finance-overview-card">
          <div class="finance-overview-label">Income</div>
          <div class="finance-overview-value income">${this.formatCurrency(totals.income)}</div>
        </div>
        <div class="finance-overview-card">
          <div class="finance-overview-label">Expenses</div>
          <div class="finance-overview-value expense">${this.formatCurrency(totals.expenses)}</div>
        </div>
        <div class="finance-overview-card">
          <div class="finance-overview-label">Net</div>
          <div class="finance-overview-value">${this.formatCurrency(totals.net)}</div>
        </div>
        <div class="finance-overview-card">
          <div class="finance-overview-label">Spend rate</div>
          <div class="finance-overview-value">${percentSpent}%</div>
        </div>
      `;
      card.appendChild(metrics);
  
      const charts = DOM.create('div', 'finance-overview-charts');
      const ratioWrap = DOM.create('div', 'finance-chart-card finance-chart-compact');
      ratioWrap.appendChild(DOM.create('div', 'finance-chart-title', 'Spend vs Remaining'));
      const ratioCanvas = DOM.create('canvas', '');
      ratioCanvas.id = 'financeSpendRatioChart';
      ratioCanvas.height = 120;
      ratioWrap.appendChild(ratioCanvas);
      charts.appendChild(ratioWrap);
  
      const categoryWrap = DOM.create('div', 'finance-chart-card');
      categoryWrap.appendChild(DOM.create('div', 'finance-chart-title', 'Category Spend (% of Income)'));
      const categoryCanvas = DOM.create('canvas', '');
      categoryCanvas.id = 'financeSpendPercentChart';
      categoryCanvas.height = 180;
      categoryWrap.appendChild(categoryCanvas);
      charts.appendChild(categoryWrap);
  
      card.appendChild(charts);
      requestAnimationFrame(() => this.drawFinancePercentCharts(records));
      return card;
    },
  
  
    drawFinancePercentCharts(records) {
      if (typeof Chart === 'undefined') return;
      const totals = this.getTotals(records);
      const percentSpent = totals.income > 0 ? Math.round((totals.expenses / totals.income) * 100) : 0;
      const percentRemaining = totals.income > 0 ? Math.max(0, 100 - percentSpent) : 0;
  
      const ratioCanvas = document.getElementById('financeSpendRatioChart');
      if (ratioCanvas) {
        if (AppState.dashboardCharts.financeSpendRatioChart) {
          AppState.dashboardCharts.financeSpendRatioChart.destroy();
        }
        AppState.dashboardCharts.financeSpendRatioChart = new Chart(ratioCanvas, {
          type: 'doughnut',
          data: {
            labels: ['Spent', 'Remaining'],
            datasets: [{
              data: totals.income > 0 ? [percentSpent, percentRemaining] : [0, 100],
              backgroundColor: ['#ef4444', '#10b981']
            }]
          },
          options: {
            cutout: '70%',
            radius: '80%',
            plugins: { legend: { position: 'bottom' } },
            maintainAspectRatio: false
          }
        });
      }
  
      const categoryTotals = records
        .filter(record => record.type === 'expense')
        .reduce((acc, record) => {
          const key = record.category || 'Uncategorized';
          acc[key] = (acc[key] || 0) + (Number(record.amount) || 0);
          return acc;
        }, {});
      const categoryEntries = Object.entries(categoryTotals)
        .sort((a, b) => b[1] - a[1])
        .slice(0, 6);
      const categoryLabels = categoryEntries.map(entry => entry[0]);
      const categoryData = categoryEntries.map(entry => {
        if (totals.income <= 0) return 0;
        return Math.round((entry[1] / totals.income) * 100);
      });
  
      const categoryCanvas = document.getElementById('financeSpendPercentChart');
      if (categoryCanvas) {
        if (AppState.dashboardCharts.financeSpendPercentChart) {
          AppState.dashboardCharts.financeSpendPercentChart.destroy();
        }
        AppState.dashboardCharts.financeSpendPercentChart = new Chart(categoryCanvas, {
          type: 'bar',
          data: {
            labels: categoryLabels,
            datasets: [{
              label: '% of income',
              data: categoryData,
              backgroundColor: '#3b82f6'
            }]
          },
          options: {
            plugins: { legend: { position: 'bottom' } },
            scales: { y: { beginAtZero: true, max: 100 } }
          }
        });
      }
    },
  
    renderHighlights(records) {
      const totals = this.getTotals(records);
      const expenseRecords = records.filter(record => record.type === 'expense');
      const incomeRecords = records.filter(record => record.type === 'income');
      const largestExpense = expenseRecords.reduce((acc, record) => {
        return !acc || Number(record.amount) > Number(acc.amount) ? record : acc;
      }, null);
      const largestIncome = incomeRecords.reduce((acc, record) => {
        return !acc || Number(record.amount) > Number(acc.amount) ? record : acc;
      }, null);
      const recurringTotal = records
        .filter(record => record.recurringMonthly)
        .reduce((sum, record) => sum + (Number(record.amount) || 0), 0);
  
      const uniqueDates = new Set(records.map(record => record.date)).size || 1;
      const averageDailySpend = totals.expenses / uniqueDates;
      const savingsRate = totals.income > 0 ? Math.round((totals.net / totals.income) * 100) : 0;
  
      const card = DOM.create('div', 'finance-card');
      card.appendChild(DOM.create('h2', 'section-title', 'Monthly Highlights'));
  
      const grid = DOM.create('div', 'finance-highlights-grid');
      const items = [
        {
          label: 'Average Daily Spend',
          value: this.formatCurrency(averageDailySpend),
          sub: `${uniqueDates} day${uniqueDates === 1 ? '' : 's'} tracked`
        },
        {
          label: 'Largest Expense',
          value: largestExpense ? this.formatCurrency(largestExpense.amount) : this.formatCurrency(0),
          sub: largestExpense ? (largestExpense.category || largestExpense.note || 'Uncategorized') : 'No expenses yet'
        },
        {
          label: 'Largest Income',
          value: largestIncome ? this.formatCurrency(largestIncome.amount) : this.formatCurrency(0),
          sub: largestIncome ? (largestIncome.category || largestIncome.note || 'Uncategorized') : 'No income yet'
        },
        {
          label: 'Recurring Total',
          value: this.formatCurrency(recurringTotal),
          sub: recurringTotal > 0 ? 'Monthly recurring items' : 'No recurring items'
        },
        {
          label: 'Savings Rate',
          value: `${savingsRate}%`,
          sub: totals.income > 0 ? 'Net vs. income' : 'Add income to track'
        }
      ];
  
      items.forEach(item => {
        const tile = DOM.create('div', 'finance-highlight-card');
        tile.appendChild(DOM.create('div', 'finance-highlight-label', item.label));
        tile.appendChild(DOM.create('div', 'finance-highlight-value', item.value));
        tile.appendChild(DOM.create('div', 'finance-highlight-sub', item.sub));
        grid.appendChild(tile);
      });
  
      card.appendChild(grid);
      return card;
    },
  
    renderCategoryBreakdown(records) {
      const card = DOM.create('div', 'finance-card');
      card.appendChild(DOM.create('h2', 'section-title', 'Top Expense Categories'));
  
      const categoryTotals = records
        .filter(record => record.type === 'expense')
        .reduce((acc, record) => {
          const key = record.category || 'Uncategorized';
          acc[key] = (acc[key] || 0) + (Number(record.amount) || 0);
          return acc;
        }, {});
  
      const entries = Object.entries(categoryTotals)
        .sort((a, b) => b[1] - a[1])
        .slice(0, 5);
  
      if (entries.length === 0) {
        const empty = DOM.create('div', 'empty-state');
        empty.textContent = 'No expense categories yet.';
        card.appendChild(empty);
        return card;
      }
  
      const list = DOM.create('div', 'finance-category-list');
      entries.forEach(([category, amount]) => {
        const row = DOM.create('div', 'finance-category-row');
        row.innerHTML = `<span>${category}</span><span>${this.formatCurrency(amount)}</span>`;
        list.appendChild(row);
      });
  
      card.appendChild(list);
      return card;
    },
  
  
    renderTaskValueSnapshot() {
      return DOM.create('div', '');
    },
  
    renderCharts(records) {
      const card = DOM.create('div', 'finance-card');
      card.appendChild(DOM.create('h2', 'section-title', 'Budget Histograms'));
  
      const grid = DOM.create('div', 'finance-chart-grid');
      const spendWrap = DOM.create('div', 'finance-chart-card');
      spendWrap.appendChild(DOM.create('div', 'finance-chart-title', 'Daily Spend vs Income'));
      const spendCanvas = DOM.create('canvas', '');
      spendCanvas.id = 'financeDailyHistogram';
      spendWrap.appendChild(spendCanvas);
      grid.appendChild(spendWrap);
  
      const categoryWrap = DOM.create('div', 'finance-chart-card');
      categoryWrap.appendChild(DOM.create('div', 'finance-chart-title', 'Top Categories Histogram'));
      const categoryCanvas = DOM.create('canvas', '');
      categoryCanvas.id = 'financeCategoryHistogram';
      categoryWrap.appendChild(categoryCanvas);
      grid.appendChild(categoryWrap);
  
      const objectiveWrap = DOM.create('div', 'finance-chart-card');
      objectiveWrap.appendChild(DOM.create('div', 'finance-chart-title', 'Task Objectives Mix'));
      const objectiveCanvas = DOM.create('canvas', '');
      objectiveCanvas.id = 'financeTaskObjectiveChart';
      objectiveWrap.appendChild(objectiveCanvas);
      grid.appendChild(objectiveWrap);
  
      card.appendChild(grid);
      setTimeout(() => this.drawFinanceHistograms(records), 0);
      return card;
    },
  
    drawFinanceHistograms(records) {
      if (typeof Chart === 'undefined') return;
      const grouped = records.reduce((acc, record) => {
        if (!record.date) return acc;
        if (!acc[record.date]) acc[record.date] = { income: 0, expense: 0 };
        const amount = Number(record.amount) || 0;
        if (record.type === 'income') acc[record.date].income += amount;
        else acc[record.date].expense += amount;
        return acc;
      }, {});
      const dates = Object.keys(grouped).sort();
      const incomeSeries = dates.map(date => grouped[date].income);
      const expenseSeries = dates.map(date => grouped[date].expense);
  
      const dailyCanvas = document.getElementById('financeDailyHistogram');
      if (dailyCanvas) {
        if (AppState.dashboardCharts.financeDailyHistogram) {
          AppState.dashboardCharts.financeDailyHistogram.destroy();
        }
        AppState.dashboardCharts.financeDailyHistogram = new Chart(dailyCanvas, {
          type: 'bar',
          data: {
            labels: dates,
            datasets: [
              { label: 'Income', data: incomeSeries, backgroundColor: '#10b981' },
              { label: 'Expenses', data: expenseSeries, backgroundColor: '#ef4444' }
            ]
          },
          options: {
            responsive: true,
            plugins: { legend: { position: 'bottom' } },
            scales: { x: { stacked: true }, y: { beginAtZero: true, stacked: true } }
          }
        });
      }
  
      const categoryTotals = records
        .filter(record => record.type === 'expense')
        .reduce((acc, record) => {
          const key = record.category || 'Uncategorized';
          acc[key] = (acc[key] || 0) + (Number(record.amount) || 0);
          return acc;
        }, {});
      const categoryEntries = Object.entries(categoryTotals).sort((a, b) => b[1] - a[1]).slice(0, 8);
      const categoryLabels = categoryEntries.map(entry => entry[0]);
      const categoryData = categoryEntries.map(entry => entry[1]);
  
      const categoryCanvas = document.getElementById('financeCategoryHistogram');
      if (categoryCanvas) {
        if (AppState.dashboardCharts.financeCategoryHistogram) {
          AppState.dashboardCharts.financeCategoryHistogram.destroy();
        }
        AppState.dashboardCharts.financeCategoryHistogram = new Chart(categoryCanvas, {
          type: 'bar',
          data: {
            labels: categoryLabels,
            datasets: [{ label: 'Spend', data: categoryData, backgroundColor: '#3b82f6' }]
          },
          options: {
            plugins: { legend: { position: 'bottom' } },
            scales: { y: { beginAtZero: true } }
          }
        });
      }
  
      const objectiveCounts = AppState.tasks.reduce((acc, task) => {
        const key = task.objectiveId ? getObjectiveName(task.objectiveId) : 'No objective';
        acc[key] = (acc[key] || 0) + 1;
        return acc;
      }, {});
      const objectiveEntries = Object.entries(objectiveCounts)
        .sort((a, b) => b[1] - a[1])
        .slice(0, 6);
      const objectiveCanvas = document.getElementById('financeTaskObjectiveChart');
      if (objectiveCanvas) {
        if (AppState.dashboardCharts.financeTaskObjectiveChart) {
          AppState.dashboardCharts.financeTaskObjectiveChart.destroy();
        }
        AppState.dashboardCharts.financeTaskObjectiveChart = new Chart(objectiveCanvas, {
          type: 'doughnut',
          data: {
            labels: objectiveEntries.map(entry => entry[0]),
            datasets: [{
              data: objectiveEntries.map(entry => entry[1]),
              backgroundColor: ['#10b981', '#3b82f6', '#f59e0b', '#8b5cf6', '#ef4444', '#0ea5e9']
            }]
          },
          options: {
            plugins: { legend: { position: 'bottom' } }
          }
        });
      }
    },
  
    renderAddForm() {
      const card = DOM.create('div', 'finance-card');
      card.appendChild(DOM.create('h2', 'section-title', 'Add Transaction'));
  
      const form = DOM.create('form', 'finance-form');
  
      const dateGroup = DOM.create('div', 'form-group');
      dateGroup.appendChild(DOM.create('label', 'form-label', 'Date'));
      const dateInput = DOM.create('input', 'form-input');
      dateInput.type = 'date';
      dateInput.required = true;
      dateInput.value = this.formatDateInput(new Date());
      dateGroup.appendChild(dateInput);
  
      const typeGroup = DOM.create('div', 'form-group');
      typeGroup.appendChild(DOM.create('label', 'form-label', 'Type'));
      const typeSelect = DOM.create('select', 'form-input');
      ['expense', 'income'].forEach(type => {
        const option = document.createElement('option');
        option.value = type;
        option.textContent = type.charAt(0).toUpperCase() + type.slice(1);
        typeSelect.appendChild(option);
      });
      typeGroup.appendChild(typeSelect);
  
      const amountGroup = DOM.create('div', 'form-group');
      amountGroup.appendChild(DOM.create('label', 'form-label', 'Amount'));
      const amountInput = DOM.create('input', 'form-input');
      amountInput.type = 'number';
      amountInput.min = '0';
      amountInput.step = '0.01';
      amountInput.placeholder = '0.00';
      amountInput.required = true;
      amountGroup.appendChild(amountInput);
  
      const categoryGroup = DOM.create('div', 'form-group');
      categoryGroup.appendChild(DOM.create('label', 'form-label', 'Category'));
      const categorySelect = DOM.create('select', 'form-input');
      categorySelect.name = 'category';
      const defaultOption = DOM.create('option', '');
      defaultOption.value = '';
      defaultOption.textContent = 'Select category';
      categorySelect.appendChild(defaultOption);
      AppState.financeCategories.forEach(cat => {
        const option = DOM.create('option', '');
        option.value = cat.name;
        option.textContent = cat.name;
        categorySelect.appendChild(option);
      });
      SelectUtils.addCreateOption(categorySelect, 'Category', () => {
        FinanceCategoryModal.show();
      });
      categoryGroup.appendChild(categorySelect);
  
      const noteGroup = DOM.create('div', 'form-group span-2');
      noteGroup.appendChild(DOM.create('label', 'form-label', 'Note'));
      const noteInput = DOM.create('input', 'form-input');
      noteInput.type = 'text';
      noteInput.name = 'note';
      noteInput.placeholder = 'Name/description of this transaction';
      noteGroup.appendChild(noteInput);

      // Hours Needed field (only for income)
      const hoursNeededGroup = DOM.create('div', 'form-group');
      hoursNeededGroup.id = 'hours-needed-group-add';
      hoursNeededGroup.style.display = (typeSelect.value === 'income') ? 'block' : 'none';
      hoursNeededGroup.appendChild(DOM.create('label', 'form-label', 'Hours Needed to Earn This'));
      const hoursNeededInput = DOM.create('input', 'form-input');
      hoursNeededInput.type = 'number';
      hoursNeededInput.name = 'hoursNeeded';
      hoursNeededInput.step = '0.25';
      hoursNeededInput.min = '0';
      hoursNeededInput.placeholder = 'How many hours of work needed to earn this income';
      hoursNeededGroup.appendChild(hoursNeededInput);

      // Show/hide hours needed based on type
      typeSelect.onchange = () => {
        hoursNeededGroup.style.display = (typeSelect.value === 'income') ? 'block' : 'none';
      };
  
      const submitBtn = DOM.create('button', 'btn btn-primary');
      submitBtn.type = 'submit';
      submitBtn.textContent = 'Add Transaction';
  
      const grid = DOM.create('div', 'finance-form-grid');
      grid.appendChild(dateGroup);
      grid.appendChild(typeGroup);
      grid.appendChild(amountGroup);
      grid.appendChild(categoryGroup);
      grid.appendChild(noteGroup);
      form.appendChild(grid);
      form.appendChild(hoursNeededGroup);
      form.appendChild(submitBtn);
  
      form.onsubmit = async (event) => {
        event.preventDefault();
        const record = {
          id: this.getNextFinanceId(),
          date: dateInput.value,
          type: typeSelect.value,
          amount: parseFloat(amountInput.value || '0'),
          category: categorySelect.value,
          note: noteInput.value,
          recurringMonthly: false,
          hoursNeeded: typeSelect.value === 'income' ? parseFloat(hoursNeededInput.value || '0') : 0
        };
  
        const operationId = `create-finance-${Date.now()}`;
        await SaveManager.saveWithOptimisticUpdate(
          operationId,
          () => {
            AppState.financeRecords.push(record);
            // Reset form
            dateInput.value = FinancePage.formatDateInput(new Date());
            typeSelect.value = 'expense';
            amountInput.value = '';
            categorySelect.value = '';
            noteInput.value = '';
            hoursNeededInput.value = '';
            hoursNeededGroup.style.display = 'none';
            hoursNeededInput.value = '';
            hoursNeededGroup.style.display = 'none';
          },
          async () => {
            await API.saveFinanceRecords(AppState.financeRecords);
          },
          () => {
            Toast.success('Transaction saved');
          },
          (error) => {
            Toast.error('Error saving transaction');
          }
        );
      };
  
      card.appendChild(form);
      return card;
    },
  
    renderDailyBreakdown(records) {
      const card = DOM.create('div', 'finance-card');
      card.appendChild(DOM.create('h2', 'section-title', 'Daily Breakdown'));
  
      if (records.length === 0) {
        const empty = DOM.create('div', 'empty-state');
        empty.textContent = 'No transactions for this month yet.';
        card.appendChild(empty);
        return card;
      }
  
      const grouped = {};
      records.forEach(record => {
        if (!grouped[record.date]) grouped[record.date] = [];
        grouped[record.date].push(record);
      });
  
      const dates = Object.keys(grouped).sort();
      const list = DOM.create('div', 'finance-daily-list');
      dates.forEach(date => {
        const dayRecords = grouped[date];
        const totals = this.getTotals(dayRecords);
        const dayCard = DOM.create('div', 'finance-day');
        const dayHeader = DOM.create('div', 'finance-day-header');
        dayHeader.appendChild(DOM.create('div', 'finance-day-title', date));
        dayHeader.appendChild(DOM.create('div', 'finance-day-total',
          `${this.formatCurrency(totals.expenses)} spent • ${this.formatCurrency(totals.income)} earned`));
        dayCard.appendChild(dayHeader);
  
        const items = DOM.create('div', 'finance-day-items');
        dayRecords.forEach(record => {
          items.appendChild(this.renderRecordRow(record));
        });
        dayCard.appendChild(items);
        list.appendChild(dayCard);
      });
  
      card.appendChild(list);
      return card;
    },
  
    renderRecurringList() {
      const card = DOM.create('div', 'finance-card');
      card.appendChild(DOM.create('h2', 'section-title', 'Recurring Monthly Items'));
  
      const recurring = (arguments.length > 0 ? arguments[0] : AppState.financeRecords)
        .filter(record => record.recurringMonthly);
      if (recurring.length === 0) {
        const empty = DOM.create('div', 'empty-state');
        empty.textContent = 'No recurring items yet.';
        card.appendChild(empty);
        return card;
      }
  
      const list = DOM.create('div', 'finance-recurring-list');
      recurring.forEach(record => {
        list.appendChild(this.renderRecordRow(record));
      });
      card.appendChild(list);
      return card;
    },
  
    renderFinanceFilters(records) {
      const bar = DOM.create('div', 'filter-bar finance-filter-bar');
      const header = DOM.create('div', 'filter-title', 'Finance Filters');
      bar.appendChild(header);
  
      const typeGroup = DOM.create('div', 'filter-group finance-filter-group');
      typeGroup.appendChild(DOM.create('div', 'filter-label', 'Type'));
      const typeOptions = DOM.create('div', 'filter-options');
      ['income', 'expense'].forEach(type => {
        const option = DOM.create('label', 'filter-option');
        const checkbox = DOM.create('input', '');
        checkbox.type = 'checkbox';
        checkbox.checked = AppState.financeFilters.types.includes(type);
        checkbox.onchange = () => this.toggleFinanceFilter('types', type);
        option.appendChild(checkbox);
        option.appendChild(DOM.create('span', '', type.charAt(0).toUpperCase() + type.slice(1)));
        typeOptions.appendChild(option);
      });
      typeGroup.appendChild(typeOptions);
      bar.appendChild(typeGroup);
  
      const categoryGroup = DOM.create('div', 'filter-group finance-filter-group');
      categoryGroup.appendChild(DOM.create('div', 'filter-label', 'Category'));
      const categoryOptions = DOM.create('div', 'filter-options');
      const categories = Array.from(new Set(records.map(record => record.category).filter(Boolean))).sort();
      categories.forEach(category => {
        const option = DOM.create('label', 'filter-option');
        const checkbox = DOM.create('input', '');
        checkbox.type = 'checkbox';
        checkbox.checked = AppState.financeFilters.categories.includes(category);
        checkbox.onchange = () => this.toggleFinanceFilter('categories', category);
        option.appendChild(checkbox);
        option.appendChild(DOM.create('span', '', category));
        categoryOptions.appendChild(option);
      });
      if (categories.length === 0) {
        categoryOptions.appendChild(DOM.create('span', 'filter-empty', 'No categories'));
      }
      categoryGroup.appendChild(categoryOptions);
      bar.appendChild(categoryGroup);
  
      const clearBtn = DOM.create('button', 'btn btn-secondary btn-sm finance-filter-clear');
      clearBtn.textContent = 'Clear Filters';
      clearBtn.onclick = () => this.clearFinanceFilters();
      bar.appendChild(clearBtn);
      return bar;
    },
  
    toggleFinanceFilter(type, value) {
      const filters = AppState.financeFilters[type];
      const index = filters.indexOf(value);
      if (index >= 0) filters.splice(index, 1);
      else filters.push(value);
      Router.render();
    },
  
    clearFinanceFilters() {
      AppState.financeFilters = { types: [], categories: [] };
      Router.render();
    },
  
    applyFinanceFilters(records) {
      const filters = AppState.financeFilters;
      if (filters.types.length === 0 && filters.categories.length === 0) return records;
      return records.filter(record => {
        if (filters.types.length > 0 && !filters.types.includes(record.type)) return false;
        if (filters.categories.length > 0 && !filters.categories.includes(record.category)) return false;
        return true;
      });
    },
  
    renderRecordRow(record) {
      const row = DOM.create('div', 'finance-record');
      const details = DOM.create('div', 'finance-record-details');
      const title = record.category || record.note || 'Uncategorized';
      details.appendChild(DOM.create('div', 'finance-record-title', title));
      const meta = record.note && record.category ? `${record.category} • ${record.note}` : (record.note || record.category || '');
      if (meta) details.appendChild(DOM.create('div', 'finance-record-meta', meta));
      if (record.recurringMonthly) {
        details.appendChild(DOM.create('span', 'finance-record-tag', 'Recurring'));
      }
  
      const amount = DOM.create('div', `finance-record-amount ${record.type}`,
        `${record.type === 'expense' ? '-' : '+'}${this.formatCurrency(record.amount)}`);
  
      const actions = DOM.create('div', 'finance-record-actions');
      const editBtn = DOM.create('button', 'btn btn-secondary btn-sm');
      editBtn.textContent = 'Edit';
      editBtn.onclick = (event) => {
        event.stopPropagation();
        FinanceModal.show(record);
      };
      const deleteBtn = DOM.create('button', 'btn btn-danger btn-sm');
      deleteBtn.textContent = 'Delete';
      deleteBtn.onclick = async (event) => {
        event.stopPropagation();
        if (!confirm('Delete this transaction?')) return;
        const targetId = record.recurrenceSourceId || record.id;
        const operationId = `delete-finance-${targetId}`;
        
        await SaveManager.saveWithOptimisticUpdate(
          operationId,
          () => {
            AppState.financeRecords = AppState.financeRecords.filter(item => item.id !== targetId);
          },
          async () => {
            await API.saveFinanceRecords(AppState.financeRecords);
          },
          () => {
            Toast.success('Transaction deleted');
          },
          (error) => {
            Toast.error('Error deleting transaction');
          }
        );
      };
  
      actions.appendChild(editBtn);
      actions.appendChild(deleteBtn);
      row.appendChild(details);
      row.appendChild(amount);
      row.appendChild(actions);
      return row;
    },
  
    getMonthlyRecords() {
      return this.getMonthlyRecordsFor(AppState.financeMonth);
    },
  
    getMonthlyRecordsFor(date) {
      const monthKey = this.getMonthKey(date);
      const year = date.getFullYear();
      const month = date.getMonth();
      const daysInMonth = new Date(year, month + 1, 0).getDate();
      const records = [];
      const monthStart = new Date(year, month, 1);
      const monthEnd = new Date(year, month + 1, 0);
  
      AppState.financeRecords.forEach(record => {
        // Handle recurring bills (new structure with recurringFrequency)
        if (record.recurringFrequency && record.recurringStatus === 'active' && record.recurringNextDueDate) {
          const nextDueDate = new Date(record.recurringNextDueDate);
          // Check if this recurring bill should appear in this month
          if (nextDueDate >= monthStart && nextDueDate <= monthEnd) {
            records.push({
              ...record,
              date: this.formatDateInput(nextDueDate),
              id: `recurring-bill-${record.id}-${monthKey}`,
              recurrenceSourceId: record.id,
              isRecurringBill: true
            });
          }
          return;
        }
  
        // Payment transactions from recurring bills (have recurringBillId set)
        // These are actual transactions and should be included if they fall in this month
        if (record.recurringBillId) {
          if (!record.date) return;
          const recordDate = new Date(record.date);
          if (recordDate.getFullYear() === year && recordDate.getMonth() === month) {
            records.push(record);
          }
          return;
        }
  
        // Skip recurring bill template records when processing regular records
        // (templates have recurringFrequency/Status but no recurringBillId)
        if (record.recurringFrequency && record.recurringStatus) {
          return; // This is a recurring bill template, skip it from regular processing
        }
  
        // Handle old recurringMonthly records
        if (!record.date) return;
        const recordDate = new Date(record.date);
        if (record.recurringMonthly && !record.recurringFrequency) {
          const day = Math.min(recordDate.getDate(), daysInMonth);
          const instanceDate = new Date(year, month, day);
          records.push({
            ...record,
            date: this.formatDateInput(instanceDate),
            id: `recurring-${record.id}-${monthKey}`,
            recurrenceSourceId: record.id
          });
          return;
        }
        if (recordDate.getFullYear() === year && recordDate.getMonth() === month) {
          records.push(record);
        }
      });
  
      return records.sort((a, b) => a.date.localeCompare(b.date));
    },
  
    getTotals(records) {
      return records.reduce((acc, record) => {
        const amount = Number(record.amount) || 0;
        if (record.type === 'income') acc.income += amount;
        else acc.expenses += amount;
        acc.net = acc.income - acc.expenses;
        return acc;
      }, { income: 0, expenses: 0, net: 0 });
    },
  
    getMonthKey(date) {
      return `${date.getFullYear()}-${String(date.getMonth() + 1).padStart(2, '0')}`;
    },
  
    formatDateInput(date) {
      return `${date.getFullYear()}-${String(date.getMonth() + 1).padStart(2, '0')}-${String(date.getDate()).padStart(2, '0')}`;
    },
  
    formatCurrency(value) {
      const num = Number(value) || 0;
      return `${num.toFixed(2)} MAD`;
    },
  
    getMonthlyBudget(monthKey) {
      return AppState.financeSettings[monthKey] || 0;
    },
  
    getNextFinanceId() {
      const ids = AppState.financeRecords.map(record => Number(record.id)).filter(Number.isFinite);
      const maxId = ids.length > 0 ? Math.max(...ids) : 0;
      return maxId + 1;
    }
  };
  
  const FinanceModal = {
    show(record = null) {
      const overlay = DOM.create('div', 'modal-overlay active');
      overlay.onclick = (event) => {
        if (event.target === overlay) this.hide();
      };
  
      const modal = DOM.create('div', 'modal');
      const header = DOM.create('div', 'modal-header');
      header.appendChild(DOM.create('h2', 'modal-title', record ? 'Edit Transaction' : 'New Transaction'));
      const closeBtn = DOM.create('button', 'modal-close');
      closeBtn.innerHTML = DOM.getIconSVG('close');
      closeBtn.onclick = () => this.hide();
      header.appendChild(closeBtn);
      modal.appendChild(header);
  
      const form = DOM.create('form', '');
  
      const dateGroup = DOM.create('div', 'form-group');
      dateGroup.appendChild(DOM.create('label', 'form-label', 'Date'));
      const dateInput = DOM.create('input', 'form-input');
      dateInput.type = 'date';
      dateInput.name = 'date';
      dateInput.value = record?.date || FinancePage.formatDateInput(new Date());
      dateGroup.appendChild(dateInput);
      form.appendChild(dateGroup);
  
      const typeGroup = DOM.create('div', 'form-group');
      typeGroup.appendChild(DOM.create('label', 'form-label', 'Type'));
      const typeSelect = DOM.create('select', 'form-select');
      typeSelect.name = 'type';
      ['expense', 'income'].forEach(type => {
        const option = DOM.create('option', '');
        option.value = type;
        option.textContent = type.charAt(0).toUpperCase() + type.slice(1);
        if ((record?.type || 'expense') === type) option.selected = true;
        typeSelect.appendChild(option);
      });
      typeGroup.appendChild(typeSelect);
      form.appendChild(typeGroup);
  
      const amountGroup = DOM.create('div', 'form-group');
      amountGroup.appendChild(DOM.create('label', 'form-label', 'Amount'));
      const amountInput = DOM.create('input', 'form-input');
      amountInput.type = 'number';
      amountInput.min = '0';
      amountInput.step = '0.01';
      amountInput.name = 'amount';
      amountInput.value = record?.amount || '';
      amountGroup.appendChild(amountInput);
      form.appendChild(amountGroup);
  
      const categoryGroup = DOM.create('div', 'form-group');
      categoryGroup.appendChild(DOM.create('label', 'form-label', 'Category'));
      const categorySelect = DOM.create('select', 'form-input');
      categorySelect.name = 'category';
      const defaultOption = DOM.create('option', '');
      defaultOption.value = '';
      defaultOption.textContent = 'Select category';
      categorySelect.appendChild(defaultOption);
      AppState.financeCategories.forEach(cat => {
        const option = DOM.create('option', '');
        option.value = cat.name;
        option.textContent = cat.name;
        if (record?.category === cat.name) option.selected = true;
        categorySelect.appendChild(option);
      });
      SelectUtils.addCreateOption(categorySelect, 'Category', () => {
        this.hide();
        FinanceCategoryModal.show(null, () => {
          this.show(record);
        });
      });
      categorySelect.value = record?.category || '';
      categoryGroup.appendChild(categorySelect);
      form.appendChild(categoryGroup);
  
      const noteGroup = DOM.create('div', 'form-group');
      noteGroup.appendChild(DOM.create('label', 'form-label', 'Note'));
      const noteInput = DOM.create('input', 'form-input');
      noteInput.type = 'text';
      noteInput.name = 'note';
      noteInput.value = record?.note || '';
      noteInput.placeholder = 'Name/description of this transaction';
      noteGroup.appendChild(noteInput);
      form.appendChild(noteGroup);

      // Hours Needed field (only for income)
      const hoursNeededGroup = DOM.create('div', 'form-group');
      hoursNeededGroup.id = 'hours-needed-group';
      hoursNeededGroup.style.display = (typeSelect.value === 'income') ? 'block' : 'none';
      hoursNeededGroup.appendChild(DOM.create('label', 'form-label', 'Hours Needed to Earn This'));
      const hoursNeededInput = DOM.create('input', 'form-input');
      hoursNeededInput.type = 'number';
      hoursNeededInput.name = 'hoursNeeded';
      hoursNeededInput.value = record?.hoursNeeded || '';
      hoursNeededInput.step = '0.25';
      hoursNeededInput.min = '0';
      hoursNeededInput.placeholder = 'How many hours of work needed to earn this income';
      hoursNeededGroup.appendChild(hoursNeededInput);
      form.appendChild(hoursNeededGroup);

      // Show/hide hours needed based on type
      typeSelect.onchange = () => {
        hoursNeededGroup.style.display = (typeSelect.value === 'income') ? 'block' : 'none';
      };
  
      form.onsubmit = async (event) => {
        event.preventDefault();
        await this.save(record, new FormData(form));
      };
  
      modal.appendChild(form);
  
      const footer = DOM.create('div', 'modal-footer');
      const saveBtn = DOM.create('button', 'btn btn-primary');
      saveBtn.type = 'submit';
      saveBtn.textContent = 'Save';
      saveBtn.onclick = () => form.requestSubmit();
      footer.appendChild(saveBtn);
      const cancelBtn = DOM.create('button', 'btn btn-secondary');
      cancelBtn.textContent = 'Cancel';
      cancelBtn.onclick = () => this.hide();
      footer.appendChild(cancelBtn);
      modal.appendChild(footer);
  
      overlay.appendChild(modal);
      document.body.appendChild(overlay);
    },
  
    hide() {
      const overlay = document.querySelector('.modal-overlay');
      if (overlay) overlay.remove();
    },
  
    async save(record, formData) {
      const targetId = record?.recurrenceSourceId || record?.id || FinancePage.getNextFinanceId();
      const updated = {
        id: targetId,
        date: formData.get('date'),
        type: formData.get('type'),
        amount: parseFloat(formData.get('amount') || '0'),
        category: formData.get('category'),
        note: formData.get('note'),
        recurringMonthly: false,
        hoursNeeded: formData.get('type') === 'income' ? parseFloat(formData.get('hoursNeeded') || '0') : 0
      };
  
      const operationId = record ? `update-finance-${targetId}` : `create-finance-${Date.now()}`;
      
      await SaveManager.saveWithOptimisticUpdate(
        operationId,
        () => {
          const existingIndex = AppState.financeRecords.findIndex(item => item.id === targetId);
          if (existingIndex >= 0) {
            AppState.financeRecords[existingIndex] = updated;
          } else {
            AppState.financeRecords.push(updated);
          }
          this.hide();
        },
        async () => {
          await API.saveFinanceRecords(AppState.financeRecords);
        },
        () => {
          Toast.success(record ? 'Transaction updated' : 'Transaction saved');
        },
        (error) => {
          Toast.error('Error saving transaction. Please try again.');
        }
      );
    }
  };
  
  // Finance Categories Page
  const FinanceCategoriesPage = {
    render() {
      const container = DOM.create('div', '');
      
      const header = DOM.create('div', 'page-header');
      header.style.display = 'flex';
      header.style.justifyContent = 'space-between';
      header.style.alignItems = 'center';
      
      const titleSection = DOM.create('div', '');
      titleSection.appendChild(DOM.create('h1', 'page-title', 'Finance Categories'));
      titleSection.appendChild(DOM.create('p', 'page-subtitle', 'Manage your finance categories'));
      header.appendChild(titleSection);
      
      const addBtn = DOM.create('button', 'btn btn-primary');
      addBtn.textContent = '+ Add Category';
      addBtn.onclick = () => FinanceCategoryModal.show();
      header.appendChild(addBtn);
      
      container.appendChild(header);
  
      const categoriesList = DOM.create('div', 'objectives-list');
      
      if (AppState.financeCategories.length === 0) {
        const emptyState = DOM.create('div', 'empty-state');
        emptyState.style.textAlign = 'center';
        emptyState.style.padding = '3rem';
        emptyState.style.color = '#6b7280';
        emptyState.innerHTML = '<p style="font-size: 1.125rem; margin-bottom: 0.5rem;">No finance categories yet</p><p>Create your first category to get started</p>';
        categoriesList.appendChild(emptyState);
      } else {
        AppState.financeCategories.forEach(category => {
          categoriesList.appendChild(this.renderCategory(category));
        });
      }
      
      container.appendChild(categoriesList);
  
      return container;
    },
  
    renderCategory(category) {
      const card = DOM.create('div', 'objective-card');
      card.style.borderLeftColor = category.color || '#3b82f6';
      
      const header = DOM.create('div', 'objective-header');
      const titleSection = DOM.create('div', '');
      titleSection.appendChild(DOM.create('h3', 'objective-title', category.name));
      header.appendChild(titleSection);
      
      const actions = DOM.create('div', 'objective-actions');
      const editBtn = DOM.create('button', 'btn btn-secondary btn-sm');
      editBtn.textContent = 'Edit';
      editBtn.onclick = () => FinanceCategoryModal.show(category);
      actions.appendChild(editBtn);
      
      const deleteBtn = DOM.create('button', 'btn btn-danger btn-sm');
      deleteBtn.textContent = 'Delete';
      deleteBtn.onclick = () => this.deleteCategory(category);
      actions.appendChild(deleteBtn);
      
      header.appendChild(actions);
      card.appendChild(header);
  
      // Show finance records with this category
      const recordsWithCategory = AppState.financeRecords.filter(r => r.category === category.name);
      if (recordsWithCategory.length > 0) {
        const recordsSection = DOM.create('div', 'objective-tasks');
        recordsSection.appendChild(DOM.create('p', 'objective-tasks-label', `Transactions: ${recordsWithCategory.length}`));
        const total = recordsWithCategory.reduce((sum, r) => sum + (Number(r.amount) || 0), 0);
        recordsSection.appendChild(DOM.create('p', 'objective-tasks-label', `Total: ${FinancePage.formatCurrency(total)}`));
        card.appendChild(recordsSection);
      }
  
      if (category.budget) {
        const monthRecords = FinancePage.getMonthlyRecordsFor(AppState.financeMonth)
          .filter(record => record.category === category.name && record.type === 'expense');
        const spent = monthRecords.reduce((sum, record) => sum + (Number(record.amount) || 0), 0);
        const percent = Math.min(100, Math.round((spent / category.budget) * 100));
        const budgetSection = DOM.create('div', 'objective-tasks');
        budgetSection.appendChild(DOM.create('p', 'objective-tasks-label', `Budget: ${FinancePage.formatCurrency(category.budget)}`));
        budgetSection.appendChild(DOM.create('p', 'objective-tasks-label', `Spent: ${FinancePage.formatCurrency(spent)} (${percent}%)`));
        const bar = DOM.create('div', 'finance-budget-progress');
        bar.innerHTML = `<span style="width: ${percent}%;" class="${percent >= 100 ? 'danger' : ''}"></span>`;
        budgetSection.appendChild(bar);
        card.appendChild(budgetSection);
      }
  
      return card;
    },
  
    async deleteCategory(category) {
      if (!confirm(`Are you sure you want to delete "${category.name}"?`)) return;
      
      const operationId = `delete-finance-category-${category.id}`;
      await SaveManager.saveWithOptimisticUpdate(
        operationId,
        () => {
          AppState.financeCategories = AppState.financeCategories.filter(c => c.id !== category.id);
          // Update finance records to remove category reference
          AppState.financeRecords.forEach(record => {
            if (record.category === category.name) {
              record.category = '';
            }
          });
        },
        async () => {
          await API.deleteFinanceCategory(category.id);
          await API.saveFinanceRecords(AppState.financeRecords);
        },
        () => {
          Toast.success('Category deleted');
        },
        (error) => {
          Toast.error('Error deleting category. Please try again.');
        }
      );
    }
  };
  
  // Finance Category Modal
  const FinanceCategoryModal = {
    show(category = null, onSaveCallback = null) {
      const overlay = DOM.create('div', 'modal-overlay active');
      overlay.onclick = (e) => {
        if (e.target === overlay) this.hide();
      };
  
      const modal = DOM.create('div', 'modal');
      
      const modalHeader = DOM.create('div', 'modal-header');
      modalHeader.appendChild(DOM.create('h2', 'modal-title', category ? 'Edit Finance Category' : 'New Finance Category'));
      const closeBtn = DOM.create('button', 'modal-close');
      closeBtn.innerHTML = DOM.getIconSVG('close');
      closeBtn.onclick = () => this.hide();
      modalHeader.appendChild(closeBtn);
      modal.appendChild(modalHeader);
  
      const form = DOM.create('form', '');
      
      // Category name
      const nameGroup = DOM.create('div', 'form-group');
      nameGroup.appendChild(DOM.create('label', 'form-label', 'Category Name'));
      const nameInput = DOM.create('input', 'form-input');
      nameInput.type = 'text';
      nameInput.name = 'name';
      nameInput.value = category?.name || '';
      nameInput.required = true;
      nameInput.placeholder = 'e.g., Food, Transport, Salary';
      nameGroup.appendChild(nameInput);
      form.appendChild(nameGroup);
  
      const budgetGroup = DOM.create('div', 'form-group');
      budgetGroup.appendChild(DOM.create('label', 'form-label', 'Monthly Budget'));
      const budgetInput = DOM.create('input', 'form-input');
      budgetInput.type = 'number';
      budgetInput.min = '0';
      budgetInput.step = '0.01';
      budgetInput.name = 'budget';
      budgetInput.value = category?.budget || '';
      budgetInput.placeholder = 'Optional limit';
      budgetGroup.appendChild(budgetInput);
      form.appendChild(budgetGroup);
  
      // Color
  
      form.onsubmit = (e) => {
        e.preventDefault();
        this.save(category, new FormData(form), onSaveCallback);
      };
  
      modal.appendChild(form);
  
      const footer = DOM.create('div', 'modal-footer');
      const saveBtn = DOM.create('button', 'btn btn-primary');
      saveBtn.type = 'submit';
      saveBtn.textContent = 'Save';
      saveBtn.onclick = () => form.requestSubmit();
      footer.appendChild(saveBtn);
      
      const cancelBtn = DOM.create('button', 'btn btn-secondary');
      cancelBtn.textContent = 'Cancel';
      cancelBtn.onclick = () => this.hide();
      footer.appendChild(cancelBtn);
      
      modal.appendChild(footer);
      overlay.appendChild(modal);
      document.body.appendChild(overlay);
    },
  
    hide() {
      const overlay = document.querySelector('.modal-overlay');
      if (overlay) overlay.remove();
    },
  
    async save(category, formData, callback) {
      const categoryData = {
        name: formData.get('name'),
        budget: parseFloat(formData.get('budget') || '0') || 0,
        color: category?.color || ColorPalette.getNext(AppState.categories.map(item => item.color))
      };
      const previousName = category?.name || '';
  
      const operationId = category ? `update-finance-category-${category.id}` : `create-finance-category-${Date.now()}`;
      
      await SaveManager.saveWithOptimisticUpdate(
        operationId,
        () => {
          if (category) {
            categoryData.id = category.id;
            const index = AppState.financeCategories.findIndex(c => c.id === category.id);
            if (index >= 0) AppState.financeCategories[index] = categoryData;
            // Update finance records if name changed
            if (previousName && previousName !== categoryData.name) {
              AppState.financeRecords.forEach(record => {
                if (record.category === previousName) {
                  record.category = categoryData.name;
                }
              });
            }
          } else {
            categoryData.id = Date.now(); // Temporary ID
            AppState.financeCategories.push(categoryData);
          }
          this.hide();
        },
        async () => {
          if (category) {
            await API.updateFinanceCategory(categoryData);
            if (previousName && previousName !== categoryData.name) {
              await API.saveFinanceRecords(AppState.financeRecords);
            }
          } else {
            const newId = await API.addFinanceCategory(categoryData);
            // Update the temporary ID with the real one
            const tempIndex = AppState.financeCategories.findIndex(c => c.id === categoryData.id);
            if (tempIndex >= 0) {
              AppState.financeCategories[tempIndex].id = newId;
            }
          }
        },
        () => {
          if (callback) callback(categoryData);
          Toast.success('Category saved');
        },
        (error) => {
          Toast.error('Error saving category. Please try again.');
        }
      );
    }
  };
  
  const ReferenceTabs = {
    open(tab) {
      AppState.referenceTab = tab;
      AppState.currentPage = 'reference';
      Sidebar.render();
      Router.render();
    }
  };
  
  const ReferencePage = {
    render() {
      const container = DOM.create('div', '');
  
      const header = DOM.create('div', 'page-header');
      header.appendChild(DOM.create('h1', 'page-title', 'Reference'));
      header.appendChild(DOM.create('p', 'page-subtitle', 'Manage objectives, categories, and statuses'));
      container.appendChild(header);
  
      const tabs = DOM.create('div', 'reference-tabs');
      const tabList = [
        { id: 'objectives', label: 'Objectives' },
        { id: 'categories', label: 'Categories' },
        { id: 'statuses', label: 'Statuses' }
      ];
  
      tabList.forEach(tab => {
        const tabBtn = DOM.create('button', 'reference-tab');
        tabBtn.textContent = tab.label;
        if (AppState.referenceTab === tab.id) tabBtn.classList.add('active');
        tabBtn.onclick = () => {
          AppState.referenceTab = tab.id;
          Router.render();
        };
        tabs.appendChild(tabBtn);
      });
  
      container.appendChild(tabs);
  
      const content = DOM.create('div', 'reference-content');
      if (AppState.referenceTab === 'categories') {
        content.appendChild(CategoriesPage.render());
      } else if (AppState.referenceTab === 'statuses') {
        content.appendChild(StatusesPage.render());
      } else {
        content.appendChild(ObjectivesPage.render());
      }
  
      container.appendChild(content);
  
      container.appendChild(FinancePage.renderTaskValueSnapshot());
      return container;
    }
  };
  
  // Objectives Page
  const ObjectivesPage = {
    render() {
      const container = DOM.create('div', '');
      
      const header = DOM.create('div', 'page-header');
      header.style.display = 'flex';
      header.style.justifyContent = 'space-between';
      header.style.alignItems = 'center';
      
      const titleSection = DOM.create('div', '');
      titleSection.appendChild(DOM.create('h1', 'page-title', 'Objectives'));
      titleSection.appendChild(DOM.create('p', 'page-subtitle', 'Manage your objectives and goals'));
      header.appendChild(titleSection);
      
      const addBtn = DOM.create('button', 'btn btn-primary');
      addBtn.textContent = '+ Add Objective';
      addBtn.onclick = () => ObjectiveModal.show();
      header.appendChild(addBtn);
      
      container.appendChild(header);
  
      const objectivesList = DOM.create('div', 'objectives-list');
      
      if (AppState.objectives.length === 0) {
        const emptyState = DOM.create('div', 'empty-state');
        emptyState.style.textAlign = 'center';
        emptyState.style.padding = '3rem';
        emptyState.style.color = '#6b7280';
        emptyState.innerHTML = '<p style="font-size: 1.125rem; margin-bottom: 0.5rem;">No objectives yet</p><p>Create your first objective to get started</p>';
        objectivesList.appendChild(emptyState);
      } else {
        AppState.objectives.forEach(objective => {
          objectivesList.appendChild(this.renderObjective(objective));
        });
      }
      
      container.appendChild(objectivesList);
  
      return container;
    },
  
  renderObjective(objective) {
    const card = DOM.create('div', 'objective-card collapsible-card');
    card.style.borderLeftColor = objective.color || '#3b82f6';

    // Header with title and actions
    const header = DOM.create('div', 'objective-header');
    const titleSection = DOM.create('div', 'objective-title-section');
    titleSection.appendChild(DOM.create('h3', 'objective-title', objective.name));

    // Collapse/expand toggle
    const toggleBtn = DOM.create('button', 'objective-toggle btn-icon');
    toggleBtn.innerHTML = '▼';
    toggleBtn.onclick = () => this.toggleObjectiveCard(card);
    titleSection.appendChild(toggleBtn);

    header.appendChild(titleSection);

    // Actions in header
    const actions = DOM.create('div', 'objective-actions');
    const editBtn = DOM.create('button', 'btn btn-secondary btn-sm');
    editBtn.textContent = 'Edit';
    editBtn.onclick = () => ObjectiveModal.show(objective);
    actions.appendChild(editBtn);

    const deleteBtn = DOM.create('button', 'btn btn-danger btn-sm');
    deleteBtn.textContent = 'Delete';
    deleteBtn.onclick = () => this.deleteObjective(objective);
    actions.appendChild(deleteBtn);

    header.appendChild(actions);
    card.appendChild(header);

    // Collapsible content
    const content = DOM.create('div', 'objective-content');

    // Basic info (always visible when expanded)
    const basicInfo = DOM.create('div', 'objective-basic-info');
    if (objective.description) {
      basicInfo.appendChild(DOM.create('p', 'objective-description', objective.description));
    }

    const badges = DOM.create('div', 'objective-badges');
    if (objective.category) {
      const categoryBadge = DOM.create('span', 'task-category');
      categoryBadge.textContent = `📁 ${objective.category}`;
      badges.appendChild(categoryBadge);
    }
    if (objective.dueDate) {
      const dueBadge = DOM.create('span', 'task-objective');
      dueBadge.textContent = `📅 Due ${objective.dueDate}`;
      badges.appendChild(dueBadge);
    }
    
    // Show financial value if linked to finance record
    if (objective.relatedFinanceId) {
      const financeRecord = getFinanceRecordById(objective.relatedFinanceId);
      
      if (financeRecord) {
        const financeBadge = DOM.create('span', 'task-badge value');
        financeBadge.textContent = `💰 ${FinancePage.formatCurrency(financeRecord.amount)}`;
        badges.appendChild(financeBadge);
        
        // Show hours needed if available
        if (financeRecord.hoursNeeded && financeRecord.hoursNeeded > 0) {
          const hoursBadge = DOM.create('span', 'task-badge');
          hoursBadge.textContent = `⏱️ ${financeRecord.hoursNeeded}h needed`;
          badges.appendChild(hoursBadge);
        }
      }
    }
    
    basicInfo.appendChild(badges);
    content.appendChild(basicInfo);

    card.appendChild(content);
  
      // Show tasks with this objective
      const tasksWithObjective = AppState.tasks.filter(t => t.objectiveId === objective.id);
      if (tasksWithObjective.length > 0) {
        const tasksSection = DOM.create('div', 'objective-tasks');
        tasksSection.appendChild(DOM.create('p', 'objective-tasks-label', `Tasks: ${tasksWithObjective.length}`));
        const taskList = DOM.create('div', 'objective-task-list');
        tasksWithObjective.slice(0, 5).forEach(task => {
          const taskItem = DOM.create('div', 'objective-task-item');
          taskItem.textContent = task.task;
          taskItem.onclick = () => {
            Router.navigate('timeline');
            setTimeout(() => TaskModal.show(task), 100);
          };
          taskList.appendChild(taskItem);
        });
        if (tasksWithObjective.length > 5) {
          const more = DOM.create('div', 'objective-task-more');
          more.textContent = `+${tasksWithObjective.length - 5} more`;
          taskList.appendChild(more);
        }
        tasksSection.appendChild(taskList);
        card.appendChild(tasksSection);
      }
  
    return card;
  },

  toggleObjectiveCard(card) {
    const content = card.querySelector('.objective-content');
    const toggleBtn = card.querySelector('.objective-toggle');

    if (content.style.display === 'none') {
      content.style.display = 'block';
      toggleBtn.innerHTML = '▼';
      card.classList.remove('collapsed');
    } else {
      content.style.display = 'none';
      toggleBtn.innerHTML = '▶';
      card.classList.add('collapsed');
    }
  },

  renderObjectiveHealth(objective) {
      const healthSection = DOM.create('div', 'objective-health');
      healthSection.style.display = 'flex';
      healthSection.style.alignItems = 'center';
      healthSection.style.gap = '1rem';
      healthSection.style.marginTop = '0.75rem';
  
      // Health score indicator
      const healthScore = objective.healthScore || 0;
      const healthIndicator = DOM.create('div', 'health-indicator');
      healthIndicator.style.display = 'flex';
      healthIndicator.style.alignItems = 'center';
      healthIndicator.style.gap = '0.5rem';
  
      const healthIcon = DOM.create('span', '');
      if (healthScore >= 80) {
        healthIcon.textContent = '🟢';
        healthIcon.title = 'Excellent health';
      } else if (healthScore >= 60) {
        healthIcon.textContent = '🟡';
        healthIcon.title = 'Good health';
      } else if (healthScore >= 40) {
        healthIcon.textContent = '🟠';
        healthIcon.title = 'Needs attention';
      } else {
        healthIcon.textContent = '🔴';
        healthIcon.title = 'At risk';
      }
  
    const healthText = DOM.create('span', 'health-score');
    healthText.textContent = `${healthScore}%`;

    // Add descriptive label based on score
    const healthLabel = DOM.create('span', 'health-label');
    if (healthScore >= 90) {
      healthLabel.textContent = 'Excellent';
      healthLabel.style.color = '#10b981';
    } else if (healthScore >= 75) {
      healthLabel.textContent = 'Good';
      healthLabel.style.color = '#3b82f6';
    } else if (healthScore >= 60) {
      healthLabel.textContent = 'Fair';
      healthLabel.style.color = '#f59e0b';
    } else if (healthScore >= 40) {
      healthLabel.textContent = 'Poor';
      healthLabel.style.color = '#f97316';
    } else {
      healthLabel.textContent = 'Critical';
      healthLabel.style.color = '#ef4444';
    }
      healthText.style.fontWeight = 'bold';
  
    healthIndicator.appendChild(healthIcon);
    healthIndicator.appendChild(healthText);
    healthIndicator.appendChild(healthLabel);
  
    // Progress indicator
    const progressIndicator = DOM.create('div', 'progress-indicator');
    const tasksWithObjective = AppState.tasks.filter(t => t.objective === objective.name);
    const completedTasks = tasksWithObjective.filter(t => t.status === 'completed').length;
    const progressPercent = tasksWithObjective.length > 0 ? Math.round((completedTasks / tasksWithObjective.length) * 100) : 0;

    progressIndicator.innerHTML = `
      <div style="display: flex; flex-direction: column; align-items: center; gap: 0.25rem;">
        <div style="width: 80px; height: 6px; background: #e5e7eb; border-radius: 3px; overflow: hidden;">
          <div style="width: ${progressPercent}%; height: 100%; background: ${objective.color || '#3b82f6'}; transition: width 0.3s ease;"></div>
        </div>
        <span style="font-size: 0.75rem; color: #6b7280; text-transform: uppercase; letter-spacing: 0.05em;">Progress</span>
        <span style="font-size: 0.875rem; font-weight: 500; color: #1f2937;">${progressPercent}%</span>
      </div>
    `;

    healthSection.appendChild(healthIndicator);
    healthSection.appendChild(progressIndicator);
  
      return healthSection;
    },
  
    renderObjectiveAnalytics(objective) {
      const analyticsSection = DOM.create('div', 'objective-analytics');
      analyticsSection.style.marginTop = '1rem';
      analyticsSection.style.padding = '1rem';
      analyticsSection.style.background = '#f9fafb';
      analyticsSection.style.borderRadius = '8px';
  
      // Get objective analytics
      const tasksWithObjective = AppState.tasks.filter(t => t.objectiveId === objective.id);
      const completedTasks = tasksWithObjective.filter(t => t.status === 'completed');
      const overdueTasks = tasksWithObjective.filter(t => t.status === 'overdue');
  
    const totalValue = completedTasks.reduce((sum, task) => {
      const value = Number(task.actualValue) || Number(task.estimatedValue) || 0;
      return sum + (task.isIncome !== false ? value : -Math.abs(value));
    }, 0);

    // Calculate total hours and completed hours for this objective
    const totalHours = tasksWithObjective.reduce((sum, task) => sum + (Number(task.estimatedHours) || 0), 0);
    const completedHours = completedTasks.reduce((sum, task) => sum + (Number(task.estimatedHours) || 0), 0);
    const hoursProgress = totalHours > 0 ? Math.round((completedHours / totalHours) * 100) : 0;
    const hourlyRate = totalHours > 0 && totalValue > 0 ? totalValue / totalHours : 0;

    // Finance records related to this objective's tasks
    const relatedFinance = AppState.financeRecords.filter(record =>
      record.type === 'expense' && tasksWithObjective.some(task => task.id == record.relatedTaskId)
    );
    const totalSpending = relatedFinance.reduce((sum, record) => sum + (Number(record.amount) || 0), 0);

    const analyticsGrid = DOM.create('div', '');
    analyticsGrid.style.display = 'grid';
    analyticsGrid.style.gridTemplateColumns = 'repeat(auto-fit, minmax(150px, 1fr))';
    analyticsGrid.style.gap = '1rem';

    const metrics = [
      { label: 'Total Tasks', value: tasksWithObjective.length.toString() },
      { label: 'Completed', value: completedTasks.length.toString() },
      { label: 'Overdue', value: overdueTasks.length.toString() },
      { label: 'Value Delivered', value: FinancePage.formatCurrency(totalValue) },
      { label: 'Hours Progress', value: totalHours > 0 ? `${completedHours.toFixed(1)}h / ${totalHours.toFixed(1)}h (${hoursProgress}%)` : '—' },
      { label: 'Hourly Rate', value: hourlyRate > 0 ? `${FinancePage.formatCurrency(hourlyRate)}/hr` : '—' },
      { label: 'Related Spending', value: FinancePage.formatCurrency(totalSpending) },
      { label: 'ROI', value: totalSpending > 0 ? `${Math.round((totalValue / totalSpending) * 100) / 100}x` : (totalValue > 0 ? '∞' : '—') }
    ];
  
      metrics.forEach(metric => {
        const metricCard = DOM.create('div', 'metric-card');
        metricCard.style.textAlign = 'center';
        metricCard.style.padding = '0.75rem';
        metricCard.style.background = 'white';
        metricCard.style.borderRadius = '6px';
        metricCard.style.boxShadow = '0 1px 3px rgba(0,0,0,0.1)';
  
        const value = DOM.create('div', 'metric-value');
        value.style.fontSize = '1.25rem';
        value.style.fontWeight = 'bold';
        value.style.color = objective.color || '#3b82f6';
        value.textContent = metric.value;
  
        const label = DOM.create('div', 'metric-label');
        label.style.fontSize = '0.875rem';
        label.style.color = '#6b7280';
        label.textContent = metric.label;
  
        metricCard.appendChild(value);
        metricCard.appendChild(label);
        analyticsGrid.appendChild(metricCard);
      });
  
      analyticsSection.appendChild(analyticsGrid);
  
      return analyticsSection;
    },
  
    async deleteObjective(objective) {
      if (!confirm(`Are you sure you want to delete "${objective.name}"?`)) return;
      
      const operationId = `delete-objective-${objective.id}`;
      await SaveManager.saveWithOptimisticUpdate(
        operationId,
        () => {
          AppState.objectives = AppState.objectives.filter(o => o.id !== objective.id);
          updateTaskReferences('objective', objective.name, '');
        },
        async () => {
          await API.deleteObjective(objective.id);
          await API.saveTasks(AppState.tasks);
        },
        () => {
          Toast.success('Objective deleted');
        },
        (error) => {
          Toast.error('Error deleting objective. Please try again.');
        }
      );
    }
  };
  
  // Objective Modal
  const ObjectiveModal = {
    show(objective = null, onSaveCallback = null) {
      const overlay = DOM.create('div', 'modal-overlay active');
      overlay.onclick = (e) => {
        if (e.target === overlay) this.hide();
      };
  
      const modal = DOM.create('div', 'modal');
      
      const modalHeader = DOM.create('div', 'modal-header');
      modalHeader.appendChild(DOM.create('h2', 'modal-title', objective ? 'Edit Objective' : 'New Objective'));
      const closeBtn = DOM.create('button', 'modal-close');
      closeBtn.innerHTML = DOM.getIconSVG('close');
      closeBtn.onclick = () => this.hide();
      modalHeader.appendChild(closeBtn);
      modal.appendChild(modalHeader);
  
      const form = DOM.create('form', '');
      
      // Objective name
      const nameGroup = DOM.create('div', 'form-group');
      nameGroup.appendChild(DOM.create('label', 'form-label', 'Objective Name'));
      const nameInput = DOM.create('input', 'form-input');
      nameInput.type = 'text';
      nameInput.name = 'name';
      nameInput.value = objective?.name || '';
      nameInput.required = true;
      nameInput.placeholder = 'e.g., Work, Personal, Health';
      nameGroup.appendChild(nameInput);
      form.appendChild(nameGroup);
  
      // Description
      const descGroup = DOM.create('div', 'form-group');
      descGroup.appendChild(DOM.create('label', 'form-label', 'Description'));
      const descInput = DOM.create('textarea', 'form-input');
      descInput.name = 'description';
      descInput.value = objective?.description || '';
      descInput.rows = 2;
      descInput.style.minHeight = '60px';
      descInput.placeholder = 'Brief description...';
      descGroup.appendChild(descInput);
      form.appendChild(descGroup);
  
      // Category
      const categoryGroup = DOM.create('div', 'form-group');
      categoryGroup.appendChild(DOM.create('label', 'form-label', 'Category'));
      const categorySelect = DOM.create('select', 'form-select');
      categorySelect.name = 'category';
      
      const noneCategoryOption = DOM.create('option', '');
      noneCategoryOption.value = '';
      noneCategoryOption.textContent = 'None';
      if (!objective?.category) noneCategoryOption.selected = true;
      categorySelect.appendChild(noneCategoryOption);
      
      AppState.categories.forEach(cat => {
        const option = DOM.create('option', '');
        option.value = cat.name;
        option.textContent = cat.name;
        if (objective?.category === cat.name) option.selected = true;
        categorySelect.appendChild(option);
      });
      
      categoryGroup.appendChild(categorySelect);
      SelectUtils.addCreateOption(categorySelect, 'Category', () => {
        this.hide();
        CategoryModal.show(null, () => {
          this.show(objective);
        });
      });
      form.appendChild(categoryGroup);
  
      // Due date
      const dueGroup = DOM.create('div', 'form-group');
      dueGroup.appendChild(DOM.create('label', 'form-label', 'Due Date (Optional)'));
      const dueInput = DOM.create('input', 'form-input');
      dueInput.type = 'date';
      dueInput.name = 'dueDate';
      dueInput.value = objective?.dueDate || '';
      dueGroup.appendChild(dueInput);
      form.appendChild(dueGroup);
  
      // Financial Value (Optional - links to income record)
      const financialGroup = DOM.create('div', 'form-group');
      financialGroup.appendChild(DOM.create('label', 'form-label', 'Link to Income Record (Optional)'));
      
      // Get current month's income records
      const now = new Date();
      const currentMonth = new Date(now.getFullYear(), now.getMonth(), 1);
      const monthRecords = FinancePage.getMonthlyRecordsFor(currentMonth);
      const incomeRecords = monthRecords.filter(record => 
        record.type === 'income' && Number(record.amount) > 0 && record.note && record.note.trim() !== ''
      );
      
      const financialSelect = DOM.create('select', 'form-select');
      financialSelect.name = 'relatedFinanceId';
      
      const noneFinancialOption = DOM.create('option', '');
      noneFinancialOption.value = '';
      noneFinancialOption.textContent = 'None (no financial tracking)';
      if (!objective?.relatedFinanceId) {
        noneFinancialOption.selected = true;
      }
      financialSelect.appendChild(noneFinancialOption);
      
      incomeRecords.forEach(record => {
        const option = DOM.create('option', '');
        option.value = record.id.toString(); // Store ID
        option.textContent = record.note; // Display name
        if (objective?.relatedFinanceId === record.id) {
          option.selected = true;
        }
        financialSelect.appendChild(option);
      });
      
      financialGroup.appendChild(financialSelect);
      const financialHint = DOM.create('div', 'form-hint');
      financialHint.style.fontSize = '0.75rem';
      financialHint.style.color = '#6b7280';
      financialHint.style.marginTop = '0.25rem';
      financialHint.textContent = 'Budget and target value will be automatically set from the selected income record';
      financialGroup.appendChild(financialHint);
      form.appendChild(financialGroup);
  
      form.onsubmit = (e) => {
        e.preventDefault();
        this.save(objective, new FormData(form), onSaveCallback);
      };
  
      modal.appendChild(form);
  
      const footer = DOM.create('div', 'modal-footer');
      const saveBtn = DOM.create('button', 'btn btn-primary');
      saveBtn.type = 'submit';
      saveBtn.textContent = 'Save';
      saveBtn.onclick = () => form.requestSubmit();
      footer.appendChild(saveBtn);
      
      const cancelBtn = DOM.create('button', 'btn btn-secondary');
      cancelBtn.textContent = 'Cancel';
      cancelBtn.onclick = () => this.hide();
      footer.appendChild(cancelBtn);
      
      modal.appendChild(footer);
      overlay.appendChild(modal);
      document.body.appendChild(overlay);
    },
  
    hide() {
      const overlay = document.querySelector('.modal-overlay');
      if (overlay) overlay.remove();
    },
  
    async save(objective, formData, callback) {
      // Get related finance record name from dropdown
      const relatedFinanceName = formData.get('relatedFinanceName') || '';
      
      // Get budget/targetValue from current month's matching finance record
      let budget = 0;
      let targetValue = 0;
      
      if (relatedFinanceName) {
        const now = new Date();
        const currentMonth = new Date(now.getFullYear(), now.getMonth(), 1);
        const monthRecords = FinancePage.getMonthlyRecordsFor(currentMonth);
        
        // Find matching finance record in current month
        const financeRecord = monthRecords.find(r => 
          r.type === 'income' && r.note && r.note.trim() === relatedFinanceName.trim()
        );
        
        if (financeRecord) {
          budget = Number(financeRecord.amount) || 0;
          targetValue = Number(financeRecord.amount) || 0;
        }
      }
      
      const objectiveData = {
        name: formData.get('name'),
        description: formData.get('description'),
        color: objective?.color || ColorPalette.getNext(AppState.objectives.map(item => item.color)),
        category: '', // Category removed - can be added back if needed
        dueDate: formData.get('dueDate') || '',
        budget: budget,
        targetValue: targetValue,
        relatedFinanceId: relatedFinanceId // Store ID
      };
      const previousName = objective?.name || '';
  
      const operationId = objective ? `update-objective-${objective.id}` : `create-objective-${Date.now()}`;
      
      await SaveManager.saveWithOptimisticUpdate(
        operationId,
        () => {
          if (objective) {
            objectiveData.id = objective.id;
            const index = AppState.objectives.findIndex(o => o.id === objective.id);
            if (index >= 0) AppState.objectives[index] = objectiveData;
            // No need to update task references when using IDs
          } else {
            objectiveData.id = Date.now(); // Temporary ID
            AppState.objectives.push(objectiveData);
          }
          this.hide();
        },
        async () => {
          if (objective) {
            await API.updateObjective(objectiveData);
            // No need to update task references when using IDs
            if (false && previousName && previousName !== objectiveData.name) {
              await API.saveTasks(AppState.tasks);
            }
          } else {
            const newId = await API.addObjective(objectiveData);
            // Update the temporary ID with the real one
            const tempIndex = AppState.objectives.findIndex(o => o.id === objectiveData.id);
            if (tempIndex >= 0) {
              AppState.objectives[tempIndex].id = newId;
            }
          }
        },
        () => {
          if (callback) callback(objectiveData);
          Toast.success('Objective saved');
        },
        (error) => {
          Toast.error('Error saving objective. Please try again.');
        }
      );
    }
  };
  
  // Categories Page
  const CategoriesPage = {
    render() {
      const container = DOM.create('div', '');
      
      const header = DOM.create('div', 'page-header');
      header.style.display = 'flex';
      header.style.justifyContent = 'space-between';
      header.style.alignItems = 'center';
      
      const titleSection = DOM.create('div', '');
      titleSection.appendChild(DOM.create('h1', 'page-title', 'Categories'));
      titleSection.appendChild(DOM.create('p', 'page-subtitle', 'Manage your categories'));
      header.appendChild(titleSection);
      
      const addBtn = DOM.create('button', 'btn btn-primary');
      addBtn.textContent = '+ Add Category';
      addBtn.onclick = () => CategoryModal.show();
      header.appendChild(addBtn);
      
      container.appendChild(header);
  
      const categoriesList = DOM.create('div', 'objectives-list');
      
      if (AppState.categories.length === 0) {
        const emptyState = DOM.create('div', 'empty-state');
        emptyState.style.textAlign = 'center';
        emptyState.style.padding = '3rem';
        emptyState.style.color = '#6b7280';
        emptyState.innerHTML = '<p style="font-size: 1.125rem; margin-bottom: 0.5rem;">No categories yet</p><p>Create your first category to get started</p>';
        categoriesList.appendChild(emptyState);
      } else {
        AppState.categories.forEach(category => {
          categoriesList.appendChild(this.renderCategory(category));
        });
      }
      
      container.appendChild(categoriesList);
  
      return container;
    },
  
    renderCategory(category) {
      const card = DOM.create('div', 'objective-card');
      card.style.borderLeftColor = category.color || '#3b82f6';
      
      const header = DOM.create('div', 'objective-header');
      const titleSection = DOM.create('div', '');
      titleSection.appendChild(DOM.create('h3', 'objective-title', category.name));
      header.appendChild(titleSection);
      
      const actions = DOM.create('div', 'objective-actions');
      const editBtn = DOM.create('button', 'btn btn-secondary btn-sm');
      editBtn.textContent = 'Edit';
      editBtn.onclick = () => CategoryModal.show(category);
      actions.appendChild(editBtn);
      
      const deleteBtn = DOM.create('button', 'btn btn-danger btn-sm');
      deleteBtn.textContent = 'Delete';
      deleteBtn.onclick = () => this.deleteCategory(category);
      actions.appendChild(deleteBtn);
      
      header.appendChild(actions);
      card.appendChild(header);
  
      // Show objectives with this category
      const objectivesWithCategory = AppState.objectives.filter(o => o.category === category.name);
      if (objectivesWithCategory.length > 0) {
        const objectivesSection = DOM.create('div', 'objective-tasks');
        objectivesSection.appendChild(DOM.create('p', 'objective-tasks-label', `Objectives: ${objectivesWithCategory.length}`));
        const objectiveList = DOM.create('div', 'objective-task-list');
        objectivesWithCategory.forEach(objective => {
          const objectiveItem = DOM.create('div', 'objective-task-item');
          objectiveItem.textContent = objective.name;
          objectiveItem.onclick = () => {
            ReferenceTabs.open('objectives');
            setTimeout(() => ObjectiveModal.show(objective), 100);
          };
          objectiveList.appendChild(objectiveItem);
        });
        objectivesSection.appendChild(objectiveList);
        card.appendChild(objectivesSection);
      }
  
      return card;
    },
  
    async deleteCategory(category) {
      if (!confirm(`Are you sure you want to delete "${category.name}"?`)) return;
      
      const operationId = `delete-category-${category.id}`;
      await SaveManager.saveWithOptimisticUpdate(
        operationId,
        () => {
          AppState.categories = AppState.categories.filter(c => c.id !== category.id);
          AppState.objectives.forEach(objective => {
            if (objective.category === category.name) {
              objective.category = '';
            }
          });
          updateTaskReferences('category', category.name, '');
        },
        async () => {
          await API.deleteCategory(category.id);
          const objectivesToUpdate = AppState.objectives.filter(o => o.category === '');
          if (objectivesToUpdate.length > 0) {
            await Promise.all(objectivesToUpdate.map(objective => API.updateObjective(objective)));
          }
          await API.saveTasks(AppState.tasks);
        },
        () => {
          Toast.success('Category deleted');
        },
        (error) => {
          Toast.error('Error deleting category. Please try again.');
        }
      );
    }
  };
  
  // Category Modal
  const CategoryModal = {
    show(category = null, onSaveCallback = null) {
      const overlay = DOM.create('div', 'modal-overlay active');
      overlay.onclick = (e) => {
        if (e.target === overlay) this.hide();
      };
  
      const modal = DOM.create('div', 'modal');
      
      const modalHeader = DOM.create('div', 'modal-header');
      modalHeader.appendChild(DOM.create('h2', 'modal-title', category ? 'Edit Category' : 'New Category'));
      const closeBtn = DOM.create('button', 'modal-close');
      closeBtn.innerHTML = DOM.getIconSVG('close');
      closeBtn.onclick = () => this.hide();
      modalHeader.appendChild(closeBtn);
      modal.appendChild(modalHeader);
  
      const form = DOM.create('form', '');
      
      // Category name
      const nameGroup = DOM.create('div', 'form-group');
      nameGroup.appendChild(DOM.create('label', 'form-label', 'Category Name'));
      const nameInput = DOM.create('input', 'form-input');
      nameInput.type = 'text';
      nameInput.name = 'name';
      nameInput.value = category?.name || '';
      nameInput.required = true;
      nameInput.placeholder = 'e.g., Work, Personal, Health';
      nameGroup.appendChild(nameInput);
      form.appendChild(nameGroup);
  
      // Color
      const colorGroup = DOM.create('div', 'form-group');
      colorGroup.appendChild(DOM.create('label', 'form-label', 'Color'));
      const colorInput = DOM.create('input', 'form-input');
      colorInput.type = 'color';
      colorInput.name = 'color';
      colorInput.value = category?.color || '#3b82f6';
      colorGroup.appendChild(colorInput);
      form.appendChild(colorGroup);
  
      form.onsubmit = (e) => {
        e.preventDefault();
        this.save(category, new FormData(form), onSaveCallback);
      };
  
      modal.appendChild(form);
  
      const footer = DOM.create('div', 'modal-footer');
      const saveBtn = DOM.create('button', 'btn btn-primary');
      saveBtn.type = 'submit';
      saveBtn.textContent = 'Save';
      saveBtn.onclick = () => form.requestSubmit();
      footer.appendChild(saveBtn);
      
      const cancelBtn = DOM.create('button', 'btn btn-secondary');
      cancelBtn.textContent = 'Cancel';
      cancelBtn.onclick = () => this.hide();
      footer.appendChild(cancelBtn);
      
      modal.appendChild(footer);
      overlay.appendChild(modal);
      document.body.appendChild(overlay);
    },
  
    hide() {
      const overlay = document.querySelector('.modal-overlay');
      if (overlay) overlay.remove();
    },
  
    async save(category, formData, callback) {
      const categoryData = {
        name: formData.get('name'),
        color: formData.get('color')
      };
      const previousName = category?.name || '';
  
      const operationId = category ? `update-category-${category.id}` : `create-category-${Date.now()}`;
      
      await SaveManager.saveWithOptimisticUpdate(
        operationId,
        () => {
          if (category) {
            categoryData.id = category.id;
            const index = AppState.categories.findIndex(c => c.id === category.id);
            if (index >= 0) AppState.categories[index] = categoryData;
            if (previousName && previousName !== categoryData.name) {
              AppState.objectives.forEach(objective => {
                if (objective.category === previousName) {
                  objective.category = categoryData.name;
                }
              });
              updateTaskReferences('category', previousName, categoryData.name);
            }
          } else {
            categoryData.id = Date.now(); // Temporary ID
            AppState.categories.push(categoryData);
          }
          this.hide();
        },
        async () => {
          if (category) {
            await API.updateCategory(categoryData);
            if (previousName && previousName !== categoryData.name) {
              const objectivesToUpdate = AppState.objectives.filter(o => o.category === categoryData.name && o.category === previousName);
              if (objectivesToUpdate.length > 0) {
                await Promise.all(objectivesToUpdate.map(objective => API.updateObjective(objective)));
              }
              await API.saveTasks(AppState.tasks);
            }
          } else {
            const newId = await API.addCategory(categoryData);
            // Update the temporary ID with the real one
            const tempIndex = AppState.categories.findIndex(c => c.id === categoryData.id);
            if (tempIndex >= 0) {
              AppState.categories[tempIndex].id = newId;
            }
          }
        },
        () => {
          if (callback) callback(categoryData);
          Toast.success('Category saved');
        },
        (error) => {
          Toast.error('Error saving category. Please try again.');
        }
      );
    }
  };
  
  // Statuses Page
  const StatusesPage = {
    render() {
      const container = DOM.create('div', '');
      
      const header = DOM.create('div', 'page-header');
      header.style.display = 'flex';
      header.style.justifyContent = 'space-between';
      header.style.alignItems = 'center';
      
      const titleSection = DOM.create('div', '');
      titleSection.appendChild(DOM.create('h1', 'page-title', 'Statuses'));
      titleSection.appendChild(DOM.create('p', 'page-subtitle', 'Manage your task statuses'));
      header.appendChild(titleSection);
      
      const addBtn = DOM.create('button', 'btn btn-primary');
      addBtn.textContent = '+ Add Status';
      addBtn.onclick = () => StatusModal.show();
      header.appendChild(addBtn);
      
      container.appendChild(header);
  
      const statusesList = DOM.create('div', 'objectives-list');
      
      if (AppState.statuses.length === 0) {
        const emptyState = DOM.create('div', 'empty-state');
        emptyState.style.textAlign = 'center';
        emptyState.style.padding = '3rem';
        emptyState.style.color = '#6b7280';
        emptyState.innerHTML = '<p style="font-size: 1.125rem; margin-bottom: 0.5rem;">No statuses yet</p><p>Create your first status to get started</p>';
        statusesList.appendChild(emptyState);
      } else {
        AppState.statuses.forEach(status => {
          statusesList.appendChild(this.renderStatus(status));
        });
      }
      
      container.appendChild(statusesList);
  
      return container;
    },
  
    renderStatus(status) {
      const card = DOM.create('div', 'objective-card');
      card.style.borderLeftColor = status.color || '#3b82f6';
      
      const header = DOM.create('div', 'objective-header');
      const titleSection = DOM.create('div', '');
      const titleDiv = DOM.create('div', '');
      titleDiv.style.display = 'flex';
      titleDiv.style.alignItems = 'center';
      titleDiv.style.gap = '0.5rem';
      
      const statusDot = DOM.create('div', '');
      statusDot.style.width = '12px';
      statusDot.style.height = '12px';
      statusDot.style.borderRadius = '50%';
      statusDot.style.backgroundColor = status.color || '#3b82f6';
      titleDiv.appendChild(statusDot);
      titleDiv.appendChild(DOM.create('h3', 'objective-title', status.name.charAt(0).toUpperCase() + status.name.slice(1).replace('-', ' ')));
      titleSection.appendChild(titleDiv);
      header.appendChild(titleSection);
      
      const actions = DOM.create('div', 'objective-actions');
      const editBtn = DOM.create('button', 'btn btn-secondary btn-sm');
      editBtn.textContent = 'Edit';
      editBtn.onclick = () => StatusModal.show(status);
      actions.appendChild(editBtn);
      
      const deleteBtn = DOM.create('button', 'btn btn-danger btn-sm');
      deleteBtn.textContent = 'Delete';
      deleteBtn.onclick = () => this.deleteStatus(status);
      actions.appendChild(deleteBtn);
      
      header.appendChild(actions);
      card.appendChild(header);
  
      // Show tasks with this status
      const tasksWithStatus = AppState.tasks.filter(t => t.status === status.name);
      if (tasksWithStatus.length > 0) {
        const tasksSection = DOM.create('div', 'objective-tasks');
        tasksSection.appendChild(DOM.create('p', 'objective-tasks-label', `Tasks: ${tasksWithStatus.length}`));
        const taskList = DOM.create('div', 'objective-task-list');
        tasksWithStatus.slice(0, 5).forEach(task => {
          const taskItem = DOM.create('div', 'objective-task-item');
          taskItem.textContent = task.task;
          taskItem.onclick = () => {
            Router.navigate('timeline');
            setTimeout(() => TaskModal.show(task), 100);
          };
          taskList.appendChild(taskItem);
        });
        if (tasksWithStatus.length > 5) {
          const more = DOM.create('div', 'objective-task-more');
          more.textContent = `+${tasksWithStatus.length - 5} more`;
          taskList.appendChild(more);
        }
        tasksSection.appendChild(taskList);
        card.appendChild(tasksSection);
      }
  
      return card;
    },
  
    async deleteStatus(status) {
      if (!confirm(`Are you sure you want to delete "${status.name}"?`)) return;
      
      const operationId = `delete-status-${status.id}`;
      await SaveManager.saveWithOptimisticUpdate(
        operationId,
        () => {
          AppState.statuses = AppState.statuses.filter(s => s.id !== status.id);
          const fallbackStatus = AppState.statuses.find(s => s.name === 'pending') ? 'pending' : '';
          updateTaskReferences('status', status.name, fallbackStatus);
        },
        async () => {
          await API.deleteStatus(status.id);
          await API.saveTasks(AppState.tasks);
        },
        () => {
          Toast.success('Status deleted');
        },
        (error) => {
          Toast.error('Error deleting status. Please try again.');
        }
      );
    }
  };
  
  // Status Modal
  const StatusModal = {
    show(status = null, onSaveCallback = null) {
      const overlay = DOM.create('div', 'modal-overlay active');
      overlay.onclick = (e) => {
        if (e.target === overlay) this.hide();
      };
  
      const modal = DOM.create('div', 'modal');
      
      const modalHeader = DOM.create('div', 'modal-header');
      modalHeader.appendChild(DOM.create('h2', 'modal-title', status ? 'Edit Status' : 'New Status'));
      const closeBtn = DOM.create('button', 'modal-close');
      closeBtn.innerHTML = DOM.getIconSVG('close');
      closeBtn.onclick = () => this.hide();
      modalHeader.appendChild(closeBtn);
      modal.appendChild(modalHeader);
  
      const form = DOM.create('form', '');
      
      // Status name
      const nameGroup = DOM.create('div', 'form-group');
      nameGroup.appendChild(DOM.create('label', 'form-label', 'Status Name'));
      const nameInput = DOM.create('input', 'form-input');
      nameInput.type = 'text';
      nameInput.name = 'name';
      nameInput.value = status?.name || '';
      nameInput.required = true;
      nameInput.placeholder = 'e.g., pending, completed, in-progress';
      nameGroup.appendChild(nameInput);
      form.appendChild(nameGroup);
  
      // Color
  
      form.onsubmit = (e) => {
        e.preventDefault();
        this.save(status, new FormData(form), onSaveCallback);
      };
  
      modal.appendChild(form);
  
      const footer = DOM.create('div', 'modal-footer');
      const saveBtn = DOM.create('button', 'btn btn-primary');
      saveBtn.type = 'submit';
      saveBtn.textContent = 'Save';
      saveBtn.onclick = () => form.requestSubmit();
      footer.appendChild(saveBtn);
      
      const cancelBtn = DOM.create('button', 'btn btn-secondary');
      cancelBtn.textContent = 'Cancel';
      cancelBtn.onclick = () => this.hide();
      footer.appendChild(cancelBtn);
      
      modal.appendChild(footer);
      overlay.appendChild(modal);
      document.body.appendChild(overlay);
    },
  
    hide() {
      const overlay = document.querySelector('.modal-overlay');
      if (overlay) overlay.remove();
    },
  
    async save(status, formData, callback) {
      const statusData = {
        name: formData.get('name'),
        color: status?.color || ColorPalette.getNext(AppState.statuses.map(item => item.color))
      };
      const previousName = status?.name || '';
  
      const operationId = status ? `update-status-${status.id}` : `create-status-${Date.now()}`;
      
      await SaveManager.saveWithOptimisticUpdate(
        operationId,
        () => {
          if (status) {
            statusData.id = status.id;
            const index = AppState.statuses.findIndex(s => s.id === status.id);
            if (index >= 0) AppState.statuses[index] = statusData;
            if (previousName && previousName !== statusData.name) {
              updateTaskReferences('status', previousName, statusData.name);
            }
          } else {
            statusData.id = Date.now(); // Temporary ID
            AppState.statuses.push(statusData);
          }
          this.hide();
        },
        async () => {
          if (status) {
            await API.updateStatus(statusData);
            if (previousName && previousName !== statusData.name) {
              await API.saveTasks(AppState.tasks);
            }
          } else {
            const newId = await API.addStatus(statusData);
            // Update the temporary ID with the real one
            const tempIndex = AppState.statuses.findIndex(s => s.id === statusData.id);
            if (tempIndex >= 0) {
              AppState.statuses[tempIndex].id = newId;
            }
          }
        },
        () => {
          if (callback) callback(statusData);
          Toast.success('Status saved');
        },
        (error) => {
          Toast.error('Error saving status. Please try again.');
        }
      );
    }
  };
  
  // Events Timeline Page (Calendar View for Events)
  const EventsTimelinePage = {
    render() {
      const container = DOM.create('div', '');
  
      const header = DOM.create('div', 'page-header');
      header.style.display = 'flex';
      header.style.justifyContent = 'space-between';
      header.style.alignItems = 'center';
  
      // Left section: Title and navigation
      const leftSection = DOM.create('div', '');
      leftSection.style.display = 'flex';
      leftSection.style.alignItems = 'center';
      leftSection.style.gap = '1rem';
      
      const titleSection = DOM.create('div', '');
      titleSection.appendChild(DOM.create('h1', 'page-title', 'Events'));
      titleSection.appendChild(DOM.create('p', 'page-subtitle', 'Calendar view of your events'));
      leftSection.appendChild(titleSection);
  
      const navControls = DOM.create('div', 'timeline-nav');
      navControls.style.display = 'flex';
      navControls.style.alignItems = 'center';
      navControls.style.gap = '0.5rem';
  
      const prevBtn = DOM.create('button', 'btn btn-secondary btn-sm');
      prevBtn.innerHTML = DOM.getIconSVG('chevronLeft');
      prevBtn.onclick = () => this.navigateTimeline(-1);
      navControls.appendChild(prevBtn);
  
      const monthYear = DOM.create('div', 'timeline-month-year');
      monthYear.textContent = this.formatViewLabel(AppState.eventsTimelineCurrentDate || new Date());
      monthYear.style.fontSize = '1.125rem';
      monthYear.style.fontWeight = '600';
      monthYear.style.minWidth = '140px';
      monthYear.style.textAlign = 'center';
      navControls.appendChild(monthYear);
  
      const nextBtn = DOM.create('button', 'btn btn-secondary btn-sm');
      nextBtn.innerHTML = DOM.getIconSVG('chevronRight');
      nextBtn.onclick = () => this.navigateTimeline(1);
      navControls.appendChild(nextBtn);
  
      const todayBtn = DOM.create('button', 'btn btn-secondary btn-sm');
      todayBtn.textContent = 'Today';
      todayBtn.onclick = () => this.goToToday();
      navControls.appendChild(todayBtn);
  
      leftSection.appendChild(navControls);
  
      // Right section: View toggle and Add button
      const rightSection = DOM.create('div', '');
      rightSection.style.display = 'flex';
      rightSection.style.gap = '0.5rem';
      rightSection.style.alignItems = 'center';
      rightSection.className = 'events-timeline-view-toggle';
  
      // On mobile, force day view and hide toggle buttons
      if (window.innerWidth <= 768) {
        AppState.eventsTimelineView = 'day';
      }
  
      const currentView = AppState.eventsTimelineView || 'month';
  
      const monthBtn = DOM.create('button', `btn btn-sm ${currentView === 'month' ? 'btn-primary' : 'btn-secondary'}`);
      monthBtn.textContent = 'Month';
      monthBtn.onclick = () => this.setView('month');
      rightSection.appendChild(monthBtn);
  
      const weekBtn = DOM.create('button', `btn btn-sm ${currentView === 'week' ? 'btn-primary' : 'btn-secondary'}`);
      weekBtn.textContent = 'Week';
      weekBtn.onclick = () => this.setView('week');
      rightSection.appendChild(weekBtn);
  
      const dayBtn = DOM.create('button', `btn btn-sm ${currentView === 'day' ? 'btn-primary' : 'btn-secondary'}`);
      dayBtn.textContent = 'Day';
      dayBtn.onclick = () => this.setView('day');
      rightSection.appendChild(dayBtn);
  
      const addBtn = DOM.create('button', 'btn btn-primary btn-sm');
      addBtn.textContent = '+ Add Event';
      addBtn.onclick = () => EventModal.show();
      rightSection.appendChild(addBtn);
  
      header.appendChild(leftSection);
      header.appendChild(rightSection);
      container.appendChild(header);
  
      const timelineWrapper = DOM.create('div', 'timeline-wrapper');
      timelineWrapper.style.overflowX = 'auto';
      timelineWrapper.style.marginTop = '1rem';
      // On mobile, always use day view
      const viewToUse = window.innerWidth <= 768 ? 'day' : (AppState.eventsTimelineView || 'month');
      timelineWrapper.setAttribute('data-view', viewToUse);
  
      const timeline = DOM.create('div', 'timeline-container');
      this.renderTimeline(timeline);
      timelineWrapper.appendChild(timeline);
  
      container.appendChild(timelineWrapper);
  
      return container;
    },
  
    setView(view) {
      // On mobile, always use day view
      const isMobile = window.innerWidth <= 768;
      if (!AppState.eventsTimelineView) AppState.eventsTimelineView = {};
      AppState.eventsTimelineView = isMobile ? 'day' : view;
      if (!AppState.eventsTimelineCurrentDate) AppState.eventsTimelineCurrentDate = new Date();
      Router.render();
    },
  
    navigateTimeline(delta) {
      const currentDate = new Date(AppState.eventsTimelineCurrentDate || new Date());
      const view = AppState.eventsTimelineView || 'month';
      if (view === 'day') {
        currentDate.setDate(currentDate.getDate() + delta);
      } else if (view === 'week') {
        currentDate.setDate(currentDate.getDate() + (delta * 7));
      } else {
        currentDate.setMonth(currentDate.getMonth() + delta);
      }
      AppState.eventsTimelineCurrentDate = currentDate;
      Router.render();
    },
  
    goToToday() {
      AppState.eventsTimelineCurrentDate = new Date();
      Router.render();
    },
  
    formatViewLabel(date) {
      const view = AppState.eventsTimelineView || 'month';
      if (view === 'day') {
        return date.toLocaleDateString('en-US', {
          weekday: 'long',
          year: 'numeric',
          month: 'long',
          day: 'numeric'
        });
      }
      if (view === 'week') {
        const start = new Date(date);
        start.setDate(date.getDate() - date.getDay());
        const end = new Date(start);
        end.setDate(start.getDate() + 6);
        const startLabel = start.toLocaleDateString('en-US', { month: 'short', day: 'numeric' });
        const endLabel = end.toLocaleDateString('en-US', { month: 'short', day: 'numeric', year: 'numeric' });
        return `${startLabel} - ${endLabel}`;
      }
      return date.toLocaleDateString('en-US', { year: 'numeric', month: 'long' });
    },
  
    isToday(date) {
      const today = new Date();
      return date.getDate() === today.getDate() &&
             date.getMonth() === today.getMonth() &&
             date.getFullYear() === today.getFullYear();
    },
  
    renderTimeline(container) {
      // On mobile, always use day view
      const view = window.innerWidth <= 768 ? 'day' : (AppState.eventsTimelineView || 'month');
      const currentDate = AppState.eventsTimelineCurrentDate || new Date();
      let startDate, endDate, days = [];
  
      if (view === 'day') {
        startDate = DateUtils.parseDate(currentDate);
        endDate = DateUtils.parseDate(currentDate);
        days = [new Date(startDate)];
      } else if (view === 'week') {
        const dayOfWeek = currentDate.getDay();
        startDate = new Date(currentDate);
        startDate.setDate(currentDate.getDate() - dayOfWeek);
        startDate = DateUtils.parseDate(startDate);
        endDate = DateUtils.addDays(startDate, 6);
  
        for (let i = 0; i < 7; i++) {
          const date = new Date(startDate);
          date.setDate(startDate.getDate() + i);
          days.push(date);
        }
      } else {
        startDate = new Date(currentDate.getFullYear(), currentDate.getMonth(), 1);
        endDate = new Date(currentDate.getFullYear(), currentDate.getMonth() + 1, 0);
        startDate = DateUtils.parseDate(startDate);
        endDate = DateUtils.parseDate(endDate);
  
        const firstDay = startDate.getDay();
        for (let i = firstDay - 1; i >= 0; i--) {
          const date = new Date(startDate);
          date.setDate(startDate.getDate() - i - 1);
          days.push(date);
        }
  
        for (let i = 1; i <= endDate.getDate(); i++) {
          const date = new Date(currentDate.getFullYear(), currentDate.getMonth(), i);
          days.push(date);
        }
  
        const lastDay = endDate.getDay();
        for (let i = 1; i <= 6 - lastDay; i++) {
          const date = new Date(endDate);
          date.setDate(endDate.getDate() + i);
          days.push(date);
        }
      }
  
      // Group events by date
      const eventsByDate = {};
      AppState.events.forEach(event => {
        const eventStart = DateUtils.parseDate(event.startDate || event.endDate);
        const eventEnd = DateUtils.parseDate(event.endDate || event.startDate);
        if (!eventStart && !eventEnd) return;
        
        const start = eventStart || eventEnd;
        const end = eventEnd || eventStart;
        
        let cursor = new Date(start);
        while (cursor <= end) {
          const dateKey = this.getDateKey(cursor);
          if (!eventsByDate[dateKey]) {
            eventsByDate[dateKey] = [];
          }
          eventsByDate[dateKey].push(event);
          cursor = DateUtils.addDays(cursor, 1);
        }
      });
  
      // Create timeline header
      const header = DOM.create('div', 'timeline-header');
      const dayNames = ['Sun', 'Mon', 'Tue', 'Wed', 'Thu', 'Fri', 'Sat'];
      dayNames.forEach(dayName => {
        const dayHeader = DOM.create('div', 'timeline-day-header');
        dayHeader.appendChild(DOM.create('div', 'timeline-day-name', dayName));
        header.appendChild(dayHeader);
      });
      container.appendChild(header);
  
      // Create timeline body
      const body = DOM.create('div', 'timeline-body');
      
      days.forEach(day => {
        const dayColumn = DOM.create('div', 'timeline-day-column');
        const dateKey = this.getDateKey(day);
        const dayEvents = eventsByDate[dateKey] || [];
        const isCurrentMonth = day.getMonth() === currentDate.getMonth();
        const isCollapsed = !!(AppState.eventsTimelineCollapsedDates && AppState.eventsTimelineCollapsedDates[dateKey]);
  
        if (!isCurrentMonth) {
          dayColumn.classList.add('timeline-day-other-month');
        } else if (this.isToday(day)) {
          dayColumn.classList.add('timeline-day-today');
        } else if (day.getDay() === 0 || day.getDay() === 6) {
          dayColumn.classList.add('timeline-day-weekend');
        }
  
        const dayHeader = DOM.create('div', 'timeline-day-column-header');
        const headerInfo = DOM.create('div', 'timeline-day-header-info');
        headerInfo.appendChild(DOM.create('div', 'timeline-day-name', dayNames[day.getDay()]));
        headerInfo.appendChild(DOM.create('div', 'timeline-day-number', day.getDate()));
        dayHeader.appendChild(headerInfo);
  
        const dateStr = DateUtils.formatDate(day);
        const addBtn = DOM.create('button', 'timeline-day-add');
        addBtn.innerHTML = DOM.getIconSVG('plus');
        addBtn.onclick = (e) => {
          e.stopPropagation();
          EventModal.show(null, null, dateStr);
        };
        dayHeader.appendChild(addBtn);
  
        const collapseButton = DOM.create('button', 'timeline-day-toggle');
        collapseButton.textContent = isCollapsed ? 'Show' : 'Hide';
        collapseButton.onclick = (e) => {
          e.stopPropagation();
          if (!AppState.eventsTimelineCollapsedDates) AppState.eventsTimelineCollapsedDates = {};
          const nextCollapsed = !dayColumn.classList.contains('collapsed');
          dayColumn.classList.toggle('collapsed', nextCollapsed);
          AppState.eventsTimelineCollapsedDates[dateKey] = nextCollapsed;
          collapseButton.textContent = nextCollapsed ? 'Show' : 'Hide';
        };
        dayHeader.appendChild(collapseButton);
        dayColumn.appendChild(dayHeader);
  
        if (isCollapsed) {
          dayColumn.classList.add('collapsed');
        }
  
        const eventsContainer = DOM.create('div', 'timeline-day-tasks');
        const collapsedSummary = DOM.create('div', 'timeline-day-collapsed-summary', `${dayEvents.length} events hidden`);
        dayColumn.appendChild(collapsedSummary);
  
        if (view === 'day') {
          this.renderDaySchedule(eventsContainer, dayEvents, day);
        } else {
          dayEvents.forEach(event => {
            eventsContainer.appendChild(this.renderEventCard(event));
          });
  
          if (dayEvents.length === 0) {
            const emptyDay = DOM.create('div', 'timeline-day-empty');
            const addIndicator = DOM.create('div', 'add-task-indicator');
            addIndicator.innerHTML = DOM.getIconSVG('plus');
            addIndicator.style.opacity = '0';
            addIndicator.style.position = 'absolute';
            addIndicator.style.top = '0.5rem';
            addIndicator.style.right = '0.5rem';
            addIndicator.style.width = '20px';
            addIndicator.style.height = '20px';
            addIndicator.style.color = '#6b7280';
            addIndicator.style.transition = 'opacity 0.2s';
            emptyDay.appendChild(addIndicator);
  
            const text = DOM.create('div', '');
            text.textContent = 'Click to add event';
            text.style.fontSize = '0.75rem';
            text.style.color = '#9ca3af';
            emptyDay.appendChild(text);
  
            eventsContainer.appendChild(emptyDay);
          }
        }
  
        dayColumn.appendChild(eventsContainer);
        body.appendChild(dayColumn);
      });
      
      container.appendChild(body);
    },
  
    renderEventCard(event) {
      const eventBar = DOM.create('div', 'timeline-task-bar');
      eventBar.style.backgroundColor = event.color || '#3b82f6';
      eventBar.style.borderLeftColor = event.color || '#3b82f6';
  
      const eventContent = DOM.create('div', 'timeline-task-content');
  
      const title = DOM.create('div', 'timeline-task-title');
      title.textContent = event.title.length > 25 ? event.title.substring(0, 25) + '...' : event.title;
      title.title = event.title;
      eventContent.appendChild(title);
  
      const meta = DOM.create('div', 'timeline-task-meta');
      const timeInfo = event.startTime || event.endTime
        ? ` • ${(event.startTime || '')}${event.endTime ? `-${event.endTime}` : ''}`
        : '';
      const categoryInfo = event.category ? ` • ${event.category}` : '';
      meta.textContent = `${event.startDate || ''}${timeInfo}${categoryInfo}`;
      eventContent.appendChild(meta);
  
      eventBar.appendChild(eventContent);
      eventBar.onclick = (e) => {
        if (!e.defaultPrevented) EventModal.show(event);
      };
  
      const calendarBtn = DOM.create('button', 'btn btn-xs btn-secondary');
      calendarBtn.textContent = '📅';
      calendarBtn.style.position = 'absolute';
      calendarBtn.style.top = '0.5rem';
      calendarBtn.style.right = '0.5rem';
      calendarBtn.onclick = async (e) => {
        e.stopPropagation();
        await this.addToGoogleCalendar(event);
      };
      eventBar.appendChild(calendarBtn);
  
      return eventBar;
    },
  
    renderDaySchedule(container, dayEvents, selectedDate) {
      const allDayEvents = [];
      const eventsByHour = {};
      const selectedKey = this.getDateKey(selectedDate);
  
      dayEvents.forEach(event => {
        const eventStart = DateUtils.parseDate(event.startDate);
        const eventEnd = DateUtils.parseDate(event.endDate || event.startDate);
        const startMinutes = this.getEventStartMinutes(event);
        const endMinutes = this.getEventEndMinutes(event);
  
        if (!startMinutes && !endMinutes) {
          allDayEvents.push(event);
          return;
        }
  
        let startHour = 0;
        let endHour = 23;
  
        if (eventStart && this.getDateKey(eventStart) === selectedKey && startMinutes !== null) {
          startHour = Math.floor(startMinutes / 60);
        }
        if (eventEnd && this.getDateKey(eventEnd) === selectedKey && endMinutes !== null) {
          endHour = Math.max(startHour, Math.ceil(endMinutes / 60));
        }
  
        for (let hour = startHour; hour <= endHour; hour += 1) {
          if (!eventsByHour[hour]) eventsByHour[hour] = [];
          eventsByHour[hour].push(event);
        }
      });
  
      if (allDayEvents.length > 0) {
        const allDaySection = DOM.create('div', 'timeline-day-all-day');
        const allDayLabel = DOM.create('div', 'timeline-day-all-day-label', 'All Day');
        allDaySection.appendChild(allDayLabel);
        allDayEvents.forEach(event => allDaySection.appendChild(this.renderEventCard(event)));
        container.appendChild(allDaySection);
      }
  
      const hoursContainer = DOM.create('div', 'timeline-day-hours');
      for (let hour = 0; hour < 24; hour += 1) {
        const hourRow = DOM.create('div', 'timeline-hour-row');
        const hourLabel = DOM.create('div', 'timeline-hour-label', `${String(hour).padStart(2, '0')}:00`);
        const hourEvents = DOM.create('div', 'timeline-hour-tasks');
  
        (eventsByHour[hour] || []).forEach(event => {
          hourEvents.appendChild(this.renderEventCard(event));
        });
  
        if (!eventsByHour[hour] || eventsByHour[hour].length === 0) {
          hourEvents.appendChild(DOM.create('div', 'timeline-hour-empty', ''));
        }
  
        hourRow.appendChild(hourLabel);
        hourRow.appendChild(hourEvents);
        hoursContainer.appendChild(hourRow);
      }
  
      if (dayEvents.length === 0) {
        const emptyDay = DOM.create('div', 'timeline-day-empty');
        const text = DOM.create('div', '');
        text.textContent = 'No events for this day';
        text.style.fontSize = '0.875rem';
        text.style.color = '#9ca3af';
        emptyDay.appendChild(text);
        container.appendChild(emptyDay);
      }
  
      container.appendChild(hoursContainer);
    },
  
    getEventStartMinutes(event) {
      if (!event.startTime) return null;
      const match = event.startTime.trim().match(/(\d{1,2})(?::(\d{2}))?\s*(AM|PM)?/i);
      if (!match) return null;
      let hour = parseInt(match[1], 10);
      const minutes = parseInt(match[2] || '0', 10);
      const meridian = match[3];
      if (meridian) {
        const upper = meridian.toUpperCase();
        if (upper === 'PM' && hour < 12) hour += 12;
        if (upper === 'AM' && hour === 12) hour = 0;
      }
      if (hour < 0 || hour > 23 || minutes < 0 || minutes > 59) return null;
      return hour * 60 + minutes;
    },
  
    getEventEndMinutes(event) {
      if (!event.endTime) return null;
      const match = event.endTime.trim().match(/(\d{1,2})(?::(\d{2}))?\s*(AM|PM)?/i);
      if (!match) return null;
      let hour = parseInt(match[1], 10);
      const minutes = parseInt(match[2] || '0', 10);
      const meridian = match[3];
      if (meridian) {
        const upper = meridian.toUpperCase();
        if (upper === 'PM' && hour < 12) hour += 12;
        if (upper === 'AM' && hour === 12) hour = 0;
      }
      if (hour < 0 || hour > 23 || minutes < 0 || minutes > 59) return null;
      return hour * 60 + minutes;
    },
  
    getDateKey(date) {
      return `${date.getFullYear()}-${String(date.getMonth() + 1).padStart(2, '0')}-${String(date.getDate()).padStart(2, '0')}`;
    },
  
    async addToGoogleCalendar(event) {
      try {
        const result = await API.createGoogleCalendarEvent(event);
        if (result.success) {
          Toast.success('Event added to Google Calendar!');
        } else {
          Toast.error(result.error || 'Failed to add to Google Calendar');
        }
      } catch (error) {
        console.error('Error adding to Google Calendar:', error);
        Toast.error('Error adding to Google Calendar');
      }
    }
  };
  
  const EventActions = {
    async deleteEvent(event) {
      if (!confirm(`Delete event "${event.title}"?`)) return;
      
      const operationId = `delete-event-${event.id}`;
      await SaveManager.saveWithOptimisticUpdate(
        operationId,
        () => {
          AppState.events = AppState.events.filter(e => e.id !== event.id);
        },
        async () => {
          await API.deleteEvent(event.id);
        },
        () => {
          Toast.success('Event deleted');
        },
        (error) => {
          Toast.error('Error deleting event. Please try again.');
        }
      );
    }
  };
  
  // Event Modal
  const EventModal = {
    show(event = null, onSaveCallback = null, prefillDate = null) {
      const overlay = DOM.create('div', 'modal-overlay active');
      overlay.onclick = (e) => {
        if (e.target === overlay) this.hide();
      };
  
      const modal = DOM.create('div', 'modal');
      const header = DOM.create('div', 'modal-header');
      header.appendChild(DOM.create('h2', 'modal-title', event ? 'Edit Event' : 'New Event'));
      const closeBtn = DOM.create('button', 'modal-close');
      closeBtn.innerHTML = DOM.getIconSVG('close');
      closeBtn.onclick = () => this.hide();
      header.appendChild(closeBtn);
      modal.appendChild(header);
  
      const form = DOM.create('form', '');
      form.onsubmit = (e) => {
        e.preventDefault();
        this.save(event, onSaveCallback);
      };
  
      const titleGroup = DOM.create('div', 'form-group');
      titleGroup.appendChild(DOM.create('label', 'form-label', 'Title *'));
      const titleInput = DOM.create('input', 'form-input');
      titleInput.type = 'text';
      titleInput.required = true;
      titleInput.value = event?.title || '';
      titleInput.name = 'title';
      titleGroup.appendChild(titleInput);
      form.appendChild(titleGroup);
  
      const descGroup = DOM.create('div', 'form-group');
      descGroup.appendChild(DOM.create('label', 'form-label', 'Description'));
      const descInput = DOM.create('textarea', 'form-input');
      descInput.name = 'description';
      descInput.value = event?.description || '';
      descGroup.appendChild(descInput);
      form.appendChild(descGroup);
  
      const dateRow = DOM.create('div', 'time-range-row');
      const startDateGroup = DOM.create('div', 'form-group');
      startDateGroup.appendChild(DOM.create('label', 'form-label', 'Start Date'));
      const startDateInput = DOM.create('input', 'form-input');
      startDateInput.type = 'date';
      startDateInput.value = event?.startDate || prefillDate || '';
      startDateInput.name = 'startDate';
      startDateGroup.appendChild(startDateInput);
      dateRow.appendChild(startDateGroup);
  
      const startTimeGroup = DOM.create('div', 'form-group');
      startTimeGroup.appendChild(DOM.create('label', 'form-label', 'Start Time'));
      const startTimeInput = DOM.create('input', 'form-input');
      startTimeInput.type = 'time';
      startTimeInput.value = event?.startTime || '';
      startTimeInput.name = 'startTime';
      startTimeGroup.appendChild(startTimeInput);
      dateRow.appendChild(startTimeGroup);
      form.appendChild(dateRow);
  
      const endDateRow = DOM.create('div', 'time-range-row');
      const endDateGroup = DOM.create('div', 'form-group');
      endDateGroup.appendChild(DOM.create('label', 'form-label', 'End Date'));
      const endDateInput = DOM.create('input', 'form-input');
      endDateInput.type = 'date';
      endDateInput.value = event?.endDate || prefillDate || '';
      endDateInput.name = 'endDate';
      endDateGroup.appendChild(endDateInput);
      endDateRow.appendChild(endDateGroup);
  
      const endTimeGroup = DOM.create('div', 'form-group');
      endTimeGroup.appendChild(DOM.create('label', 'form-label', 'End Time'));
      const endTimeInput = DOM.create('input', 'form-input');
      endTimeInput.type = 'time';
      endTimeInput.value = event?.endTime || '';
      endTimeInput.name = 'endTime';
      endTimeGroup.appendChild(endTimeInput);
      endDateRow.appendChild(endTimeGroup);
      form.appendChild(endDateRow);
  
      const categoryGroup = DOM.create('div', 'form-group');
      categoryGroup.appendChild(DOM.create('label', 'form-label', 'Category'));
      const categorySelect = DOM.create('select', 'form-select');
      categorySelect.name = 'category';
      const emptyOption = DOM.create('option', '', '');
      emptyOption.value = '';
      emptyOption.textContent = 'None';
      categorySelect.appendChild(emptyOption);
      AppState.categories.forEach(cat => {
        const option = DOM.create('option', '', cat.name);
        option.value = cat.name;
        if (event?.category === cat.name) option.selected = true;
        categorySelect.appendChild(option);
      });
      categoryGroup.appendChild(categorySelect);
      form.appendChild(categoryGroup);
  
      SelectUtils.addCreateOption(categorySelect, 'Category', () => {
        this.hide();
        CategoryModal.show(null, () => {
          this.show(event);
        });
      });
  
      // Attendance tracking (only for existing events)
      if (event?.id) {
        const attendanceGroup = DOM.create('div', 'form-group');
        attendanceGroup.appendChild(DOM.create('label', 'form-label', 'Event Attendance'));
        const attendanceRow = DOM.create('div', 'attendance-row');
  
        const attendedCheckbox = DOM.create('input', 'form-checkbox');
        attendedCheckbox.type = 'checkbox';
        attendedCheckbox.name = 'attended';
        attendedCheckbox.id = 'attended';
        attendedCheckbox.checked = event?.attended || false;
  
        const attendedLabel = DOM.create('label', 'checkbox-label');
        attendedLabel.htmlFor = 'attended';
        attendedLabel.textContent = 'I attended this event';
  
        attendanceRow.appendChild(attendedCheckbox);
        attendanceRow.appendChild(attendedLabel);
        attendanceGroup.appendChild(attendanceRow);
        form.appendChild(attendanceGroup);
  
        // Attendance date (shown when attended is checked)
        const attendanceDateGroup = DOM.create('div', 'form-group attendance-date-group');
        attendanceDateGroup.style.display = event?.attended ? 'block' : 'none';
        attendanceDateGroup.appendChild(DOM.create('label', 'form-label', 'Attendance Date'));
        const attendanceDateInput = DOM.create('input', 'form-input');
        attendanceDateInput.type = 'date';
        attendanceDateInput.name = 'attendanceDate';
        attendanceDateInput.value = event?.attendanceDate || '';
        attendanceDateGroup.appendChild(attendanceDateInput);
        form.appendChild(attendanceDateGroup);
  
        // Show/hide attendance date based on checkbox
        attendedCheckbox.onchange = () => {
          attendanceDateGroup.style.display = attendedCheckbox.checked ? 'block' : 'none';
          if (attendedCheckbox.checked && !attendanceDateInput.value) {
            attendanceDateInput.value = new Date().toISOString().split('T')[0];
          }
        };
      }
  
      // Related tasks section (only for existing events)
      if (event?.id) {
        const relatedTasksGroup = DOM.create('div', 'form-group');
        relatedTasksGroup.appendChild(DOM.create('label', 'form-label', 'Related Tasks'));
        const relatedTasksList = DOM.create('div', 'related-tasks-list');
  
        const relatedTaskIds = event?.relatedTaskIds ? event.relatedTaskIds.split(',').filter(id => id.trim()) : [];
        if (relatedTaskIds.length > 0) {
          relatedTaskIds.forEach(taskId => {
            const task = AppState.tasks.find(t => t.id == taskId);
            if (task) {
              const taskItem = DOM.create('div', 'related-task-item');
              taskItem.innerHTML = `
                <span class="task-name">${task.task}</span>
                <span class="task-status status-${task.status}">${task.status}</span>
              `;
              taskItem.onclick = () => {
                this.hide();
                TaskModal.show(task);
              };
              relatedTasksList.appendChild(taskItem);
            }
          });
        } else {
          relatedTasksList.innerHTML = '<div class="no-related-tasks">No related tasks</div>';
        }
  
        relatedTasksGroup.appendChild(relatedTasksList);
        form.appendChild(relatedTasksGroup);
      }
  
      const syncHint = DOM.create('div', 'modal-hint', 'New events sync automatically to Google Calendar.');
      form.appendChild(syncHint);
  
      const footer = DOM.create('div', 'modal-footer');
      const cancelBtn = DOM.create('button', 'btn btn-secondary');
      cancelBtn.type = 'button';
      cancelBtn.textContent = 'Cancel';
      cancelBtn.onclick = () => this.hide();
      const saveBtn = DOM.create('button', 'btn btn-primary modal-save');
      saveBtn.type = 'submit';
      saveBtn.textContent = 'Save';
      footer.appendChild(cancelBtn);
      footer.appendChild(saveBtn);
      form.appendChild(footer);
  
      modal.appendChild(form);
      overlay.appendChild(modal);
      document.body.appendChild(overlay);
    },
  
    hide() {
      const overlay = document.querySelector('.modal-overlay');
      if (overlay) overlay.remove();
    },
  
    async save(event, onSaveCallback) {
      const form = document.querySelector('.modal form');
      const saveButton = form?.querySelector('.modal-save');
      if (saveButton) {
        saveButton.classList.add('loading');
        saveButton.textContent = 'Saving...';
        saveButton.disabled = true;
      }
      const formData = new FormData(form);
      const eventData = {
        title: formData.get('title'),
        description: formData.get('description') || '',
        startDate: formData.get('startDate') || '',
        startTime: formData.get('startTime') || '',
        endDate: formData.get('endDate') || '',
        endTime: formData.get('endTime') || '',
        category: '', // Category removed - simplified
        color: event?.color || ColorPalette.getNext(AppState.events.map(item => item.color))
      };
      const operationId = event ? `update-event-${event.id}` : `create-event-${Date.now()}`;
      
      await SaveManager.saveWithOptimisticUpdate(
        operationId,
        () => {
          if (event) {
            eventData.id = event.id;
            const index = AppState.events.findIndex(e => e.id === event.id);
            if (index >= 0) AppState.events[index] = eventData;
          } else {
            eventData.id = Date.now(); // Temporary ID
            AppState.events.push(eventData);
          }
          this.hide();
        },
        async () => {
          if (event) {
            await API.updateEvent(eventData);
          } else {
            const newId = await API.addEvent(eventData);
            // Update the temporary ID with the real one
            const tempIndex = AppState.events.findIndex(e => e.id === eventData.id);
            if (tempIndex >= 0) {
              AppState.events[tempIndex].id = newId;
            }
          }
  
          const shouldSyncToCalendar = !event;
          const calendarStartDate = eventData.startDate || eventData.endDate;
          const calendarEndDate = eventData.endDate || eventData.startDate;
          if (shouldSyncToCalendar && calendarStartDate) {
            const calendarPayload = {
              ...eventData,
              startDate: calendarStartDate,
              endDate: calendarEndDate
            };
            try {
              const result = await API.createGoogleCalendarEvent(calendarPayload);
              if (result.success) {
                Toast.success('Event saved and synced to Google Calendar');
              } else {
                Toast.success('Event saved, but calendar sync failed: ' + (result.error || 'Unknown error'));
              }
            } catch (error) {
              console.error('Error adding to Google Calendar:', error);
              Toast.success('Event saved, but calendar sync failed');
            }
          } else if (!calendarStartDate) {
            Toast.success('Event saved. Add a date to sync with Google Calendar.');
          } else {
            Toast.success('Event updated');
          }
        },
        () => {
          if (saveButton) {
            saveButton.classList.remove('loading');
            saveButton.textContent = 'Save';
            saveButton.disabled = false;
          }
        },
        (error) => {
          if (saveButton) {
            saveButton.classList.remove('loading');
            saveButton.textContent = 'Save';
            saveButton.disabled = false;
          }
          Toast.error('Error saving event');
        }
      );
    }
  };
  
  // Debts Page
  const DebtsPage = {
    render() {
      const container = DOM.create('div', '');
      
      const header = DOM.create('div', 'page-header');
      header.style.display = 'flex';
      header.style.justifyContent = 'space-between';
      header.style.alignItems = 'center';
      header.appendChild(DOM.create('h1', 'page-title', 'Debts'));
      
      const addBtn = DOM.create('button', 'btn btn-primary');
      addBtn.textContent = '+ New Debt';
      addBtn.onclick = () => DebtModal.show();
      header.appendChild(addBtn);
      container.appendChild(header);
      
      // Secondary tabs for managing persons (shown first)
      const personTabs = DOM.create('div', 'reference-tabs');
      personTabs.style.marginBottom = '1rem';
      const personTabList = [
        { id: 'list', label: 'Debts List' },
        { id: 'persons', label: 'Manage Persons' }
      ];
      const currentPersonTab = AppState.debtsPersonTab || 'list';
      personTabList.forEach(tab => {
        const tabBtn = DOM.create('button', 'reference-tab');
        tabBtn.textContent = tab.label;
        if (currentPersonTab === tab.id) tabBtn.classList.add('active');
        tabBtn.onclick = () => {
          AppState.debtsPersonTab = tab.id;
          Router.render();
        };
        personTabs.appendChild(tabBtn);
      });
      container.appendChild(personTabs);
      
      // Show persons management or debts list based on tab
      if (currentPersonTab === 'persons') {
        container.appendChild(this.renderPersonsManagement());
        return container;
      }
  
  
      const summaryCard = DOM.create('div', 'card');
      const summaryTitle = DOM.create('h3', 'section-title', 'Summary');
      summaryCard.appendChild(summaryTitle);
      
      const totals = AppState.debts.reduce((acc, debt) => {
        if (debt.status === 'pending') {
          if (debt.direction === 'owed') acc.owedToMe += debt.amount;
          else acc.iOwe += debt.amount;
        }
        return acc;
      }, { owedToMe: 0, iOwe: 0 });
  
      const summaryGrid = DOM.create('div', 'dashboard-finance-summary');
      const owedCard = DOM.create('div', 'dashboard-finance-item');
      owedCard.innerHTML = `
        <div>
          <div class="dashboard-finance-label">Owed to Me</div>
          <div class="dashboard-finance-value income">${totals.owedToMe.toFixed(2)} MAD</div>
        </div>
      `;
      const oweCard = DOM.create('div', 'dashboard-finance-item');
      oweCard.innerHTML = `
        <div>
          <div class="dashboard-finance-label">I Owe</div>
          <div class="dashboard-finance-value expense">${totals.iOwe.toFixed(2)} MAD</div>
        </div>
      `;
      const netCard = DOM.create('div', 'dashboard-finance-item');
      const net = totals.owedToMe - totals.iOwe;
      netCard.innerHTML = `
        <div>
          <div class="dashboard-finance-label">Net</div>
          <div class="dashboard-finance-value ${net >= 0 ? 'income' : 'expense'}">${net.toFixed(2)} MAD</div>
        </div>
      `;
      summaryGrid.appendChild(owedCard);
      summaryGrid.appendChild(oweCard);
      summaryGrid.appendChild(netCard);
      summaryCard.appendChild(summaryGrid);
      container.appendChild(summaryCard);
  
      const listCard = DOM.create('div', 'card');
      listCard.appendChild(DOM.create('h3', 'section-title', 'All Debts'));
      
      const debtsList = DOM.create('div', 'finance-daily-list');
      // Show all debts, sorted by date (newest first)
      const sortedDebts = [...AppState.debts].sort((a, b) => {
        const dateA = a.date ? new Date(a.date) : new Date(0);
        const dateB = b.date ? new Date(b.date) : new Date(0);
        return dateB - dateA;
      });
      
      if (sortedDebts.length === 0) {
        const empty = DOM.create('div', 'empty-state');
        empty.textContent = 'No debts yet. Click "+ New Debt" to create one.';
        debtsList.appendChild(empty);
      } else {
        sortedDebts.forEach(debt => {
          const debtRow = DOM.create('div', 'finance-record');
          const details = DOM.create('div', 'finance-record-details');
          const title = DOM.create('div', 'finance-record-title', 
            `${debt.person} • ${debt.direction === 'owed' ? 'Owes me' : 'I owe'}`
          );
          const meta = DOM.create('div', 'finance-record-meta', 
            `${debt.date || 'No date'} | ${debt.description || 'No description'}`
          );
          const statusLabel = debt.status === 'paid' ? 'Paid' : debt.status === 'cancelled' ? 'Cancelled' : 'Pending';
          const status = DOM.create('span', 'finance-record-tag', statusLabel);
          details.appendChild(title);
          details.appendChild(meta);
          details.appendChild(status);
  
          // Add resolution information for paid debts
          if (debt.status === 'paid' && (debt.resolvedByTaskId || debt.resolvedDate)) {
            const resolutionInfo = DOM.create('div', 'debt-resolution-info');
            resolutionInfo.style.fontSize = '0.75rem';
            resolutionInfo.style.color = '#10b981';
            resolutionInfo.style.marginTop = '0.25rem';
  
            let resolutionText = 'Resolved';
            if (debt.resolvedDate) {
              resolutionText += ` on ${debt.resolvedDate}`;
            }
            if (debt.resolvedByTaskId) {
              const resolvingTask = AppState.tasks.find(t => t.id == debt.resolvedByTaskId);
              if (resolvingTask) {
                resolutionText += ` via "${resolvingTask.task}"`;
              }
            }
  
            resolutionInfo.textContent = resolutionText;
            details.appendChild(resolutionInfo);
          }
          
          const amount = DOM.create('div', `finance-record-amount ${debt.direction === 'owed' ? 'income' : 'expense'}`);
          amount.textContent = `${debt.amount.toFixed(2)} MAD`;
          
          const actions = DOM.create('div', 'finance-record-actions');
          const editBtn = DOM.create('button', 'btn btn-xs btn-secondary');
          editBtn.textContent = 'Edit';
          editBtn.onclick = () => DebtModal.show(debt);
          const deleteBtn = DOM.create('button', 'btn btn-xs btn-danger');
          deleteBtn.textContent = 'Delete';
          deleteBtn.onclick = () => this.deleteDebt(debt.id);
          actions.appendChild(editBtn);
          actions.appendChild(deleteBtn);
          
          debtRow.appendChild(details);
          debtRow.appendChild(amount);
          debtRow.appendChild(actions);
          debtsList.appendChild(debtRow);
        });
      }
      listCard.appendChild(debtsList);
      container.appendChild(listCard);
  
      return container;
    },
  
    renderPersonsManagement() {
      const container = DOM.create('div', '');
      
      const card = DOM.create('div', 'card');
      const header = DOM.create('div', '');
      header.style.display = 'flex';
      header.style.justifyContent = 'space-between';
      header.style.alignItems = 'center';
      header.style.marginBottom = '1.5rem';
      header.appendChild(DOM.create('h3', 'section-title', 'Manage Persons'));
      
      const addBtn = DOM.create('button', 'btn btn-primary btn-sm');
      addBtn.textContent = '+ Add Person';
      addBtn.onclick = () => PersonModal.show();
      header.appendChild(addBtn);
      card.appendChild(header);
      
      const personsList = DOM.create('div', 'finance-category-list');
      personsList.style.marginTop = '1rem';
      
      if (AppState.persons.length === 0) {
        const empty = DOM.create('div', 'empty-state');
        empty.textContent = 'No persons yet. Click "Add Person" to create one.';
        personsList.appendChild(empty);
      } else {
        AppState.persons.sort((a, b) => a.name.localeCompare(b.name)).forEach(person => {
          const personRow = DOM.create('div', 'finance-category-row');
          personRow.style.display = 'flex';
          personRow.style.justifyContent = 'space-between';
          personRow.style.alignItems = 'center';
          
          const personInfo = DOM.create('div', '');
          personInfo.innerHTML = `
            <div style="font-weight: 600;">${person.name}</div>
            <div style="font-size: 0.75rem; color: #6b7280; margin-top: 0.25rem;">
              ${AppState.debts.filter(d => d.person === person.name).length} debt(s)
            </div>
          `;
          
          const actions = DOM.create('div', '');
          actions.style.display = 'flex';
          actions.style.gap = '0.5rem';
          
          const editBtn = DOM.create('button', 'btn btn-xs btn-secondary');
          editBtn.textContent = 'Edit';
          editBtn.onclick = () => PersonModal.show(person);
          
          const deleteBtn = DOM.create('button', 'btn btn-xs btn-danger');
          deleteBtn.textContent = 'Delete';
          deleteBtn.onclick = () => this.deletePerson(person.id);
          
          actions.appendChild(editBtn);
          actions.appendChild(deleteBtn);
          
          personRow.appendChild(personInfo);
          personRow.appendChild(actions);
          personsList.appendChild(personRow);
        });
      }
      
      card.appendChild(personsList);
      container.appendChild(card);
      
      return container;
    },
  
    async deletePerson(personId) {
      const person = AppState.persons.find(p => p.id === personId);
      if (!person) return;
      
      // Check if person is used in any debts
      const debtsUsingPerson = AppState.debts.filter(d => d.person === person.name);
      if (debtsUsingPerson.length > 0) {
        if (!confirm(`This person is used in ${debtsUsingPerson.length} debt(s). Are you sure you want to delete?`)) {
          return;
        }
      } else {
        if (!confirm('Delete this person?')) return;
      }
      
      const operationId = `delete-person-${personId}`;
      await SaveManager.saveWithOptimisticUpdate(
        operationId,
        () => {
          AppState.persons = AppState.persons.filter(p => p.id !== personId);
        },
        async () => {
          await API.deletePerson(personId);
          await DataStore.refresh();
        },
        () => {
          Toast.success('Person deleted');
          Router.render();
        },
        (error) => {
          Toast.error('Error deleting person');
          Router.render();
        }
      );
    },
  
    async deleteDebt(debtId) {
      if (!confirm('Delete this debt record?')) return;
      
      const operationId = `delete-debt-${debtId}`;
      await SaveManager.saveWithOptimisticUpdate(
        operationId,
        () => {
          AppState.debts = AppState.debts.filter(d => d.id !== debtId);
        },
        async () => {
          await API.deleteDebt(debtId);
        },
        () => {
          Toast.success('Debt deleted');
        },
        (error) => {
          Toast.error('Error deleting debt');
        }
      );
    }
  };
  
  // Person Modal
  const PersonModal = {
    show(person = null, onSaveCallback = null) {
      const overlay = DOM.create('div', 'modal-overlay active');
      overlay.onclick = (e) => {
        if (e.target === overlay) this.hide();
      };
  
      const modal = DOM.create('div', 'modal');
      
      const modalHeader = DOM.create('div', 'modal-header');
      modalHeader.appendChild(DOM.create('h2', 'modal-title', person ? 'Edit Person' : 'New Person'));
      const closeBtn = DOM.create('button', 'modal-close');
      closeBtn.innerHTML = DOM.getIconSVG('close');
      closeBtn.onclick = () => this.hide();
      modalHeader.appendChild(closeBtn);
      modal.appendChild(modalHeader);
  
      const form = DOM.create('form', '');
      
      // Person name
      const nameGroup = DOM.create('div', 'form-group');
      nameGroup.appendChild(DOM.create('label', 'form-label', 'Person Name *'));
      const nameInput = DOM.create('input', 'form-input');
      nameInput.type = 'text';
      nameInput.name = 'name';
      nameInput.value = person?.name || '';
      nameInput.required = true;
      nameInput.placeholder = 'e.g., John Doe, Company Name';
      nameGroup.appendChild(nameInput);
      form.appendChild(nameGroup);
  
      form.onsubmit = (e) => {
        e.preventDefault();
        this.save(person, new FormData(form), onSaveCallback);
      };
  
      modal.appendChild(form);
  
      const footer = DOM.create('div', 'modal-footer');
      const saveBtn = DOM.create('button', 'btn btn-primary');
      saveBtn.type = 'submit';
      saveBtn.textContent = 'Save';
      saveBtn.onclick = () => form.requestSubmit();
      footer.appendChild(saveBtn);
      
      const cancelBtn = DOM.create('button', 'btn btn-secondary');
      cancelBtn.textContent = 'Cancel';
      cancelBtn.onclick = () => this.hide();
      footer.appendChild(cancelBtn);
      
      modal.appendChild(footer);
      overlay.appendChild(modal);
      document.body.appendChild(overlay);
    },
  
    hide() {
      const overlay = document.querySelector('.modal-overlay');
      if (overlay) overlay.remove();
    },
  
    async save(person, formData, onSaveCallback) {
      const personData = {
        id: person?.id || Date.now(),
        name: formData.get('name').trim()
      };
  
      if (!personData.name) {
        Toast.error('Person name is required');
        return;
      }
  
      // Check for duplicate names
      const existing = AppState.persons.find(p => p.name.toLowerCase() === personData.name.toLowerCase() && p.id !== personData.id);
      if (existing) {
        Toast.error('A person with this name already exists');
        return;
      }
  
      const operationId = person ? `update-person-${person.id}` : `create-person-${Date.now()}`;
      const saveButton = document.querySelector('.modal-footer .btn-primary');
      
      if (saveButton) {
        saveButton.classList.add('loading');
        saveButton.disabled = true;
        saveButton.textContent = 'Saving...';
      }
  
      await SaveManager.saveWithOptimisticUpdate(
        operationId,
        () => {
          if (person) {
            const index = AppState.persons.findIndex(p => p.id === person.id);
            if (index >= 0) {
              AppState.persons[index] = personData;
            }
          } else {
            AppState.persons.push(personData);
          }
        },
        async () => {
          if (person) {
            const oldName = person.name;
            await API.updatePerson(personData);
            // Update debts that reference this person
            const debtsToUpdate = AppState.debts.filter(d => d.person === oldName);
            if (debtsToUpdate.length > 0) {
              await Promise.all(debtsToUpdate.map(debt => {
                const updatedDebt = { ...debt, person: personData.name };
                return API.updateDebt(updatedDebt);
              }));
            }
          } else {
            const newId = await API.addPerson(personData);
            personData.id = newId;
          }
          await DataStore.refresh();
        },
        () => {
          if (saveButton) {
            saveButton.classList.remove('loading');
            saveButton.textContent = 'Save';
            saveButton.disabled = false;
          }
          this.hide();
          Toast.success(person ? 'Person updated' : 'Person created');
          if (onSaveCallback) onSaveCallback();
          Router.render();
        },
        (error) => {
          if (saveButton) {
            saveButton.classList.remove('loading');
            saveButton.textContent = 'Save';
            saveButton.disabled = false;
          }
          Toast.error('Error saving person');
        }
      );
    }
  };
  
  // Debt Modal
  const DebtModal = {
    show(debt = null) {
      const overlay = DOM.create('div', 'modal-overlay active');
      overlay.onclick = (e) => {
        if (e.target === overlay) this.hide();
      };
  
      const modal = DOM.create('div', 'modal');
      const header = DOM.create('div', 'modal-header');
      header.appendChild(DOM.create('h2', 'modal-title', debt ? 'Edit Debt' : 'New Debt'));
      const closeBtn = DOM.create('button', 'modal-close');
      closeBtn.innerHTML = DOM.getIconSVG('close');
      closeBtn.onclick = () => this.hide();
      header.appendChild(closeBtn);
      modal.appendChild(header);
  
      const form = DOM.create('form', '');
      form.onsubmit = (e) => {
        e.preventDefault();
        this.save(debt);
      };
  
      const personGroup = DOM.create('div', 'form-group');
      personGroup.appendChild(DOM.create('label', 'form-label', 'Person *'));
      const personSelect = DOM.create('select', 'form-select');
      personSelect.name = 'person';
      personSelect.required = true;
      
      const nonePersonOption = DOM.create('option', '');
      nonePersonOption.value = '';
      nonePersonOption.textContent = 'Select a person...';
      if (!debt?.person) nonePersonOption.selected = true;
      personSelect.appendChild(nonePersonOption);
      
      AppState.persons.sort((a, b) => a.name.localeCompare(b.name)).forEach(person => {
        const option = DOM.create('option', '');
        option.value = person.name;
        option.textContent = person.name;
        if (debt?.person === person.name) option.selected = true;
        personSelect.appendChild(option);
      });
      
      personGroup.appendChild(personSelect);
      SelectUtils.addCreateOption(personSelect, 'Person', () => {
        this.hide();
        PersonModal.show(null, () => {
          this.show(debt);
        });
      });
      form.appendChild(personGroup);
  
      const amountGroup = DOM.create('div', 'form-group');
      amountGroup.appendChild(DOM.create('label', 'form-label', 'Amount *'));
      const amountInput = DOM.create('input', 'form-input');
      amountInput.type = 'number';
      amountInput.step = '0.01';
      amountInput.required = true;
      amountInput.value = debt?.amount || '';
      amountInput.name = 'amount';
      amountGroup.appendChild(amountInput);
      form.appendChild(amountGroup);
  
      const directionGroup = DOM.create('div', 'form-group');
      directionGroup.appendChild(DOM.create('label', 'form-label', 'Direction *'));
      const directionSelect = DOM.create('select', 'form-select');
      directionSelect.name = 'direction';
      directionSelect.required = true;
      const owedOption = DOM.create('option', '', 'Owed to me (they owe me)');
      owedOption.value = 'owed';
      if (debt?.direction === 'owed') owedOption.selected = true;
      const oweOption = DOM.create('option', '', 'I owe them');
      oweOption.value = 'owe';
      if (debt?.direction === 'owe') oweOption.selected = true;
      directionSelect.appendChild(owedOption);
      directionSelect.appendChild(oweOption);
      directionGroup.appendChild(directionSelect);
      form.appendChild(directionGroup);
  
      const descGroup = DOM.create('div', 'form-group');
      descGroup.appendChild(DOM.create('label', 'form-label', 'Description'));
      const descInput = DOM.create('textarea', 'form-input');
      descInput.name = 'description';
      descInput.value = debt?.description || '';
      descGroup.appendChild(descInput);
      form.appendChild(descGroup);
  
      const dateGroup = DOM.create('div', 'form-group');
      dateGroup.appendChild(DOM.create('label', 'form-label', 'Date'));
      const dateInput = DOM.create('input', 'form-input');
      dateInput.type = 'date';
      dateInput.value = debt?.date || '';
      dateInput.name = 'date';
      dateInput.placeholder = 'dd/mm/yyyy';
      const dateHint = DOM.create('div', 'form-hint');
      dateHint.style.fontSize = '0.75rem';
      dateHint.style.color = '#6b7280';
      dateHint.style.marginTop = '0.25rem';
      dateHint.textContent = 'dd/mm/yyyy';
      dateGroup.appendChild(dateInput);
      dateGroup.appendChild(dateHint);
      form.appendChild(dateGroup);
  
      const statusGroup = DOM.create('div', 'form-group');
      statusGroup.appendChild(DOM.create('label', 'form-label', 'Status'));
      const statusSelect = DOM.create('select', 'form-select');
      statusSelect.name = 'status';
      const pendingOption = DOM.create('option', '', 'pending');
      pendingOption.value = 'pending';
      pendingOption.selected = !debt || debt.status === 'pending';
      statusSelect.appendChild(pendingOption);
      
      const paidOption = DOM.create('option', '', 'paid');
      paidOption.value = 'paid';
      if (debt?.status === 'paid') paidOption.selected = true;
      statusSelect.appendChild(paidOption);
      
      const cancelledOption = DOM.create('option', '', 'cancelled');
      cancelledOption.value = 'cancelled';
      if (debt?.status === 'cancelled') cancelledOption.selected = true;
      statusSelect.appendChild(cancelledOption);
      
      statusGroup.appendChild(statusSelect);
      form.appendChild(statusGroup);
  
      // Resolution tracking (only when status is paid)
      const resolutionGroup = DOM.create('div', 'form-group resolution-fields');
      resolutionGroup.style.display = debt?.status === 'paid' ? 'block' : 'none';
      resolutionGroup.appendChild(DOM.create('label', 'form-label', 'Resolution Details'));
  
      const resolutionFields = DOM.create('div', 'resolution-details');
  
      // Resolved by task
      const taskGroup = DOM.create('div', 'form-group');
      taskGroup.appendChild(DOM.create('label', 'form-label', 'Resolved by Task'));
      const taskSelect = DOM.create('select', 'form-select');
      taskSelect.name = 'resolvedByTaskId';
  
      const noTaskOption = DOM.create('option', '');
      noTaskOption.value = '';
      noTaskOption.textContent = 'No specific task';
      taskSelect.appendChild(noTaskOption);
  
      AppState.tasks
        .filter(task => task.status === 'completed')
        .sort((a, b) => new Date(b.endDate || b.startDate) - new Date(a.endDate || a.startDate))
        .slice(0, 20) // Show only recent completed tasks
        .forEach(task => {
          const option = DOM.create('option', '');
          option.value = task.id;
          const dateStr = task.endDate || task.startDate ? ` (${task.endDate || task.startDate})` : '';
          option.textContent = `${task.task}${dateStr}`;
          if (debt?.resolvedByTaskId == task.id) option.selected = true;
          taskSelect.appendChild(option);
        });
  
      taskGroup.appendChild(taskSelect);
      resolutionFields.appendChild(taskGroup);
  
      // Resolution date
      const resolvedDateGroup = DOM.create('div', 'form-group');
      resolvedDateGroup.appendChild(DOM.create('label', 'form-label', 'Resolution Date'));
      const resolvedDateInput = DOM.create('input', 'form-input');
      resolvedDateInput.type = 'date';
      resolvedDateInput.name = 'resolvedDate';
      resolvedDateInput.value = debt?.resolvedDate || (debt?.status === 'paid' ? new Date().toISOString().split('T')[0] : '');
      resolvedDateGroup.appendChild(resolvedDateInput);
      resolutionFields.appendChild(resolvedDateGroup);
  
      resolutionGroup.appendChild(resolutionFields);
      form.appendChild(resolutionGroup);
  
      // Show/hide resolution fields based on status
      statusSelect.onchange = () => {
        const isPaid = statusSelect.value === 'paid';
        resolutionGroup.style.display = isPaid ? 'block' : 'none';
        if (isPaid && !resolvedDateInput.value) {
          resolvedDateInput.value = new Date().toISOString().split('T')[0];
        }
      };
  
      const footer = DOM.create('div', 'modal-footer');
      const cancelBtn = DOM.create('button', 'btn btn-secondary');
      cancelBtn.type = 'button';
      cancelBtn.textContent = 'Cancel';
      cancelBtn.onclick = () => this.hide();
      const saveBtn = DOM.create('button', 'btn btn-primary');
      saveBtn.type = 'submit';
      saveBtn.textContent = 'Save';
      footer.appendChild(cancelBtn);
      footer.appendChild(saveBtn);
      form.appendChild(footer);
  
      modal.appendChild(form);
      overlay.appendChild(modal);
      document.body.appendChild(overlay);
    },
  
    hide() {
      const overlay = document.querySelector('.modal-overlay');
      if (overlay) overlay.remove();
    },
  
    async save(debt) {
      const form = document.querySelector('.modal form');
      const formData = new FormData(form);
      const debtData = {
        person: formData.get('person'),
        amount: parseFloat(formData.get('amount')) || 0,
        direction: formData.get('direction'),
        description: formData.get('description') || '',
        date: formData.get('date') || '',
        status: formData.get('status') || 'pending',
        relatedTaskId: debt?.relatedTaskId || ''
      };
  
      const operationId = debt ? `update-debt-${debt.id}` : `create-debt-${Date.now()}`;
      
      await SaveManager.saveWithOptimisticUpdate(
        operationId,
        () => {
          if (debt) {
            debtData.id = debt.id;
            const index = AppState.debts.findIndex(d => d.id === debt.id);
            if (index >= 0) AppState.debts[index] = debtData;
          } else {
            debtData.id = Date.now(); // Temporary ID
            AppState.debts.push(debtData);
          }
          this.hide();
        },
        async () => {
          if (debt) {
            await API.updateDebt(debtData);
          } else {
            const newId = await API.addDebt(debtData);
            // Update the temporary ID with the real one
            const tempIndex = AppState.debts.findIndex(d => d.id === debtData.id);
            if (tempIndex >= 0) {
              AppState.debts[tempIndex].id = newId;
            }
          }
        },
        () => {
          Toast.success('Debt saved');
        },
        (error) => {
          Toast.error('Error saving debt');
        }
      );
    }
  };
  
  // Task Modal
  const TaskModal = {
    show(task = null, onSaveCallback = null, prefillDate = null) {
      const overlay = DOM.create('div', 'modal-overlay active');
      overlay.onclick = (e) => {
        if (e.target === overlay) this.hide();
      };
  
      const modal = DOM.create('div', 'modal');
      
      const modalHeader = DOM.create('div', 'modal-header');
      modalHeader.appendChild(DOM.create('h2', 'modal-title', task ? 'Edit Task' : 'New Task'));
      const closeBtn = DOM.create('button', 'modal-close');
      closeBtn.innerHTML = DOM.getIconSVG('close');
      closeBtn.onclick = () => this.hide();
      modalHeader.appendChild(closeBtn);
      modal.appendChild(modalHeader);
  
      const form = DOM.create('form', '');
      
      // Task name
      const taskGroup = DOM.create('div', 'form-group');
      taskGroup.appendChild(DOM.create('label', 'form-label', 'Task Name'));
      const taskInput = DOM.create('input', 'form-input');
      taskInput.type = 'text';
      taskInput.name = 'task';
      taskInput.value = task?.task || '';
      taskInput.required = true;
      taskGroup.appendChild(taskInput);
      form.appendChild(taskGroup);
  
      // Date range
      const startDateGroup = DOM.create('div', 'form-group');
      startDateGroup.appendChild(DOM.create('label', 'form-label', 'Start Date'));
      const startDateInput = DOM.create('input', 'form-input');
      startDateInput.type = 'date';
      startDateInput.name = 'startDate';
      startDateInput.value = task?.startDate || task?.endDate || prefillDate || '';
      startDateGroup.appendChild(startDateInput);
      form.appendChild(startDateGroup);
  
      const endDateGroup = DOM.create('div', 'form-group');
      endDateGroup.appendChild(DOM.create('label', 'form-label', 'End Date'));
      const endDateInput = DOM.create('input', 'form-input');
      endDateInput.type = 'date';
      endDateInput.name = 'endDate';
      endDateInput.value = task?.endDate || task?.startDate || prefillDate || '';
      endDateGroup.appendChild(endDateInput);
      form.appendChild(endDateGroup);
  
      // Time Range (Optional)
      const timeGroup = DOM.create('div', 'form-group');
      timeGroup.appendChild(DOM.create('label', 'form-label', 'Time Range (Optional)'));
      const timeRow = DOM.create('div', 'time-range-row');
  
      const startTimeWrap = DOM.create('div', '');
      const startTimeLabel = DOM.create('label', 'form-label', 'Start Time');
      const startTimeInput = DOM.create('input', 'form-input');
      startTimeInput.type = 'time';
      startTimeInput.name = 'startTime';
      startTimeInput.value = task?.startTime || '';
      startTimeWrap.appendChild(startTimeLabel);
      startTimeWrap.appendChild(startTimeInput);
  
      const endTimeWrap = DOM.create('div', '');
      const endTimeLabel = DOM.create('label', 'form-label', 'End Time');
      const endTimeInput = DOM.create('input', 'form-input');
      endTimeInput.type = 'time';
      endTimeInput.name = 'endTime';
      endTimeInput.value = task?.endTime || '';
      endTimeWrap.appendChild(endTimeLabel);
      endTimeWrap.appendChild(endTimeInput);
  
      timeRow.appendChild(startTimeWrap);
      timeRow.appendChild(endTimeWrap);
      timeGroup.appendChild(timeRow);
      form.appendChild(timeGroup);
  
      // Status
      const statusGroup = DOM.create('div', 'form-group');
      statusGroup.appendChild(DOM.create('label', 'form-label', 'Status'));
      const statusSelect = DOM.create('select', 'form-select');
      statusSelect.name = 'status';
      
      AppState.statuses.forEach(status => {
        const option = DOM.create('option', '');
        option.value = status.name;
        option.textContent = status.name.charAt(0).toUpperCase() + status.name.slice(1).replace('-', ' ');
        if (task?.status === status.name) option.selected = true;
        statusSelect.appendChild(option);
      });
      
      statusGroup.appendChild(statusSelect);
      SelectUtils.addCreateOption(statusSelect, 'Status', () => {
        this.hide();
        StatusModal.show(null, () => {
          this.show(task);
        });
      });
      form.appendChild(statusGroup);
  
      // Objective (Category and Priority are automatically derived from objective)
      const objectiveGroup = DOM.create('div', 'form-group');
      objectiveGroup.appendChild(DOM.create('label', 'form-label', 'Objective'));
      const objectiveSelect = DOM.create('select', 'form-select');
      objectiveSelect.name = 'objective';
      objectiveSelect.required = true;
      
      const noneOption = DOM.create('option', '');
      noneOption.value = '';
      noneOption.textContent = 'Select an objective...';
      if (!task?.objective) noneOption.selected = true;
      objectiveSelect.appendChild(noneOption);
      
      AppState.objectives.forEach(obj => {
        const option = DOM.create('option', '');
        option.value = obj.id.toString(); // Store ID
        const categoryLabel = obj.category ? ` (${obj.category})` : '';
        option.textContent = obj.name + categoryLabel; // Display name
        if (task?.objectiveId === obj.id) option.selected = true;
        objectiveSelect.appendChild(option);
      });
      
      objectiveGroup.appendChild(objectiveSelect);
      SelectUtils.addCreateOption(objectiveSelect, 'Objective', () => {
        this.hide();
        ObjectiveModal.show(null, () => {
          this.show(task);
        });
      });
      
      // Show auto-filled info hint
      const autoFillHint = DOM.create('div', 'form-hint');
      autoFillHint.style.fontSize = '0.75rem';
      autoFillHint.style.color = '#6b7280';
      autoFillHint.style.marginTop = '0.25rem';
      autoFillHint.textContent = 'Category and financial data will be automatically set from the selected objective';
      objectiveGroup.appendChild(autoFillHint);

      // Update hint when objective changes
      const updateObjectiveInfo = () => {
        const selectedObjectiveId = objectiveSelect.value ? Number(objectiveSelect.value) : null;
        if (selectedObjectiveId) {
          const selectedObjective = getObjectiveById(selectedObjectiveId);
          const hints = [];
          if (selectedObjective?.category) {
            hints.push(`Category: ${selectedObjective.category}`);
          }
          if (selectedObjective && (selectedObjective.budget > 0 || selectedObjective.targetValue > 0)) {
            hints.push(`Financial: ${FinancePage.formatCurrency(selectedObjective.targetValue || selectedObjective.budget)}`);
          }
          if (hints.length > 0) {
            autoFillHint.textContent = hints.join(' • ');
            autoFillHint.style.color = '#10b981';
          } else {
            autoFillHint.textContent = 'Category and financial data will be automatically set from the selected objective';
            autoFillHint.style.color = '#6b7280';
          }
        } else {
          autoFillHint.textContent = 'Category and financial data will be automatically set from the selected objective';
          autoFillHint.style.color = '#6b7280';
        }
      };

      objectiveSelect.onchange = updateObjectiveInfo;
      
      // Set initial info if editing existing task
      if (task?.objectiveId) {
        updateObjectiveInfo();
      }
      
      form.appendChild(objectiveGroup);

    // Hours estimate (for tracking time investment)
    const hoursGroup = DOM.create('div', 'form-group');
    hoursGroup.appendChild(DOM.create('label', 'form-label', 'Estimated Hours'));
    const hoursInput = DOM.create('input', 'form-input');
    hoursInput.type = 'number';
    hoursInput.name = 'estimatedHours';
    hoursInput.value = task?.estimatedHours || '';
    hoursInput.step = '0.25';
    hoursInput.min = '0';
    hoursInput.placeholder = 'Time investment for this task';
    hoursGroup.appendChild(hoursInput);
    form.appendChild(hoursGroup);
  
      // Actual value (only show for completed tasks)
      if (task?.status === 'completed') {
        const actualValueGroup = DOM.create('div', 'form-group');
        actualValueGroup.appendChild(DOM.create('label', 'form-label', 'Actual Value Realized ($)'));
        const actualValueInput = DOM.create('input', 'form-input');
        actualValueInput.type = 'number';
        actualValueInput.name = 'actualValue';
        actualValueInput.value = task?.actualValue || '';
        actualValueInput.step = '0.01';
        actualValueInput.min = '0';
        actualValueInput.placeholder = 'Actual financial value realized';
        actualValueGroup.appendChild(actualValueInput);
        form.appendChild(actualValueGroup);
  
        // Value realized date
        const realizedDateGroup = DOM.create('div', 'form-group');
        realizedDateGroup.appendChild(DOM.create('label', 'form-label', 'Value Realized Date'));
        const realizedDateInput = DOM.create('input', 'form-input');
        realizedDateInput.type = 'date';
        realizedDateInput.name = 'valueRealizedDate';
        realizedDateInput.value = task?.valueRealizedDate || '';
        realizedDateGroup.appendChild(realizedDateInput);
        form.appendChild(realizedDateGroup);
      }
  
      form.onsubmit = (e) => {
        e.preventDefault();
        this.save(task, new FormData(form));
      };
  
      modal.appendChild(form);
  
      const footer = DOM.create('div', 'modal-footer');
      const saveBtn = DOM.create('button', 'btn btn-primary');
      saveBtn.type = 'submit';
      saveBtn.textContent = 'Save';
      saveBtn.onclick = () => form.requestSubmit();
      footer.appendChild(saveBtn);
      
      const cancelBtn = DOM.create('button', 'btn btn-secondary');
      cancelBtn.textContent = 'Cancel';
      cancelBtn.onclick = () => this.hide();
      footer.appendChild(cancelBtn);
      
      modal.appendChild(footer);
      overlay.appendChild(modal);
      document.body.appendChild(overlay);
    },
  
    hide() {
      const overlay = document.querySelector('.modal-overlay');
      if (overlay) overlay.remove();
    },
  
    async save(task, formData) {
      const rawStartDate = formData.get('startDate') || '';
      const rawEndDate = formData.get('endDate') || '';
      const startDate = rawStartDate || rawEndDate;
      const endDate = rawEndDate || startDate;
      
      // Get objective ID and derive category
      const objectiveId = formData.get('objective') ? Number(formData.get('objective')) : null;
      let category = '';
      let impactType = 'non-monetary';
      let isIncome = false;
      let estimatedValue = 0;
      
      if (objectiveId) {
        const selectedObjective = getObjectiveById(objectiveId);
        if (selectedObjective) {
          category = selectedObjective.category || '';
          if (selectedObjective.budget > 0 || selectedObjective.targetValue > 0) {
            impactType = 'money';
            isIncome = selectedObjective.targetValue > 0;
            estimatedValue = selectedObjective.targetValue || 0;
          }
        }
      }
  
      const taskData = {
        id: task?.id || Date.now(),
        task: formData.get('task'),
        category: category, // Automatically derived from objective
        startDate,
        endDate,
        startTime: formData.get('startTime') || '',
        endTime: formData.get('endTime') || '',
        color: getObjectiveColor(objectiveId),
        status: formData.get('status') || 'pending',
        objectiveId: objectiveId, // Store ID instead of name
        priority: 'medium', // Default priority, can be derived from objective in future
        repeatType: 'none', // Simplified - no repeat functionality
        repeatUntil: '',
        impactType: impactType, // Derived from objective
        isIncome: isIncome, // Derived from objective
        estimatedHours: Number(formData.get('estimatedHours')) || 0,
        estimatedValue: estimatedValue, // Derived from objective
        actualValue: Number(formData.get('actualValue')) || 0,
        valueRealizedDate: formData.get('valueRealizedDate') || ''
      };
  
      const operationId = task ? `update-task-${task.id}` : `create-task-${Date.now()}`;
      
      await SaveManager.saveWithOptimisticUpdate(
        operationId,
        () => {
          if (task) {
            const index = AppState.tasks.findIndex(t => t.id === task.id);
            if (index >= 0) {
              AppState.tasks[index] = taskData;
            }
          } else {
            AppState.tasks.push(taskData);
          }
          this.hide();
        },
        async () => {
          await API.saveTasks(AppState.tasks);
        },
        () => {
          Toast.success(task ? 'Task updated' : 'Task created');
        },
        (error) => {
          Toast.error('Error saving task. Please try again.');
        }
      );
    }
  };
  
  // Initialize App
  async function init() {
    // Show loader
    const loader = document.getElementById('loader');
    if (loader) {
      loader.classList.remove('hidden');
    }
    
    try {
      Toast.init();
      // Load tasks, objectives, categories, statuses, and finance data
      await DataStore.refresh();
      
      // Render sidebar and initial page
      Sidebar.render();
      Router.render();
    } catch (error) {
      console.error('Error initializing app:', error);
    } finally {
      // Hide loader after a short delay for smooth transition
      setTimeout(() => {
        if (loader) {
          loader.classList.add('hidden');
          // Remove loader from DOM after animation
          setTimeout(() => {
            if (loader.parentNode) {
              loader.parentNode.removeChild(loader);
            }
          }, 300);
        }
      }, 500);
    }
  }
  
  // Insights Panel Component
const InsightsPanel = {
  render() {
    const insights = AppState.stats?.insights || [];
    if (!insights || insights.length === 0) {
      const panel = DOM.create('div', 'insights-panel');
      panel.appendChild(DOM.create('h3', 'insights-title', '💡 Actionable Insights'));
      const emptyState = DOM.create('div', 'insights-empty', 'Insights will appear once you add the new columns to your sheets and complete some tasks.');
      panel.appendChild(emptyState);
      return panel;
    }
  
      const panel = DOM.create('div', 'insights-panel');
      panel.appendChild(DOM.create('h3', 'insights-title', '💡 Actionable Insights'));
  
      const insightsList = DOM.create('div', 'insights-list');
  
      insights.forEach(insight => {
        const insightCard = DOM.create('div', `insight-card ${insight.severity || 'info'}`);
  
        const header = DOM.create('div', 'insight-header');
        const icon = this.getInsightIcon(insight.type);
        header.appendChild(DOM.create('span', 'insight-icon', icon));
        header.appendChild(DOM.create('span', 'insight-message', insight.message));
  
        const actions = DOM.create('div', 'insight-actions');
        if (insight.action) {
          const actionBtn = DOM.create('button', 'btn btn-xs btn-primary');
          actionBtn.textContent = insight.action;
          actionBtn.onclick = () => this.handleInsightAction(insight);
          actions.appendChild(actionBtn);
        }
  
        insightCard.appendChild(header);
        if (actions.children.length > 0) {
          insightCard.appendChild(actions);
        }
  
        insightsList.appendChild(insightCard);
      });
  
      panel.appendChild(insightsList);
      return panel;
    },
  
    getInsightIcon(type) {
      const iconMap = {
        objective_risk: '⚠️',
        high_roi: '📈',
        value_delivery: '💰',
        debt_resolution: '✅',
        low_completion: '📉',
        predictive: '🔮',
        default: '💡'
      };
      return iconMap[type] || iconMap.default;
    },
  
    handleInsightAction(insight) {
      switch (insight.type) {
        case 'objective_risk':
          Router.navigate('objectives');
          break;
        case 'high_roi':
          if (insight.category) {
            AppState.timelineFilters.categories = [insight.category];
            Router.navigate('timeline');
          }
          break;
        case 'low_completion':
          if (insight.category) {
            AppState.timelineFilters.categories = [insight.category];
            Router.navigate('timeline');
          }
          break;
        case 'debt_resolution':
          Router.navigate('debts');
          break;
        case 'value_delivery':
          Router.navigate('finance');
          break;
        default:
          // Default action - could be expanded based on insight type
          break;
      }
    }
  };
  

// Category Performance Page
const CategoryPerformancePage = {
    render() {
      const container = DOM.create('div', '');
  
      const header = DOM.create('div', 'page-header');
      const titleSection = DOM.create('div', '');
      titleSection.appendChild(DOM.create('h1', 'page-title', 'Category Performance'));
      titleSection.appendChild(DOM.create('p', 'page-subtitle', 'Analyze task completion, ROI, and time allocation by category'));
      header.appendChild(titleSection);
      container.appendChild(header);
  
      const stats = AppState.stats?.categories || {};
  
      const categoriesGrid = DOM.create('div', 'categories-performance-grid');
  
      // Sort categories by task count (most active first)
      const sortedCategories = Object.entries(stats)
        .filter(([name, data]) => data.taskCount > 0)
        .sort((a, b) => b[1].taskCount - a[1].taskCount);
  
      if (sortedCategories.length === 0) {
        const emptyState = DOM.create('div', 'empty-state');
        emptyState.style.textAlign = 'center';
        emptyState.style.padding = '3rem';
        emptyState.style.color = '#6b7280';
        emptyState.innerHTML = '<p>No category data available yet.</p><p>Complete some tasks to see performance analytics.</p>';
        categoriesGrid.appendChild(emptyState);
      } else {
        sortedCategories.forEach(([categoryName, categoryStats]) => {
          const categoryCard = this.renderCategoryCard(categoryName, categoryStats);
          categoriesGrid.appendChild(categoryCard);
        });
      }
  
      container.appendChild(categoriesGrid);
  
      return container;
    },
  
    renderCategoryCard(categoryName, stats) {
      const card = DOM.create('div', 'category-performance-card');
      card.style.borderLeftColor = stats.color || '#3b82f6';
  
      const header = DOM.create('div', 'category-header');
      header.appendChild(DOM.create('h3', 'category-name', categoryName));
  
      // Performance indicators
      const indicators = DOM.create('div', 'category-indicators');
      indicators.innerHTML = `
        <div class="indicator">
          <span class="indicator-value">${stats.completionRate}%</span>
          <span class="indicator-label">Completion Rate</span>
        </div>
        <div class="indicator">
          <span class="indicator-value">${stats.taskCount}</span>
          <span class="indicator-label">Total Tasks</span>
        </div>
        <div class="indicator">
          <span class="indicator-value">${FinancePage.formatCurrency(stats.totalValue)}</span>
          <span class="indicator-label">Value Delivered</span>
        </div>
      `;
  
      // ROI indicator
      const roiIndicator = DOM.create('div', 'roi-indicator');
      const roiValue = typeof stats.roi === 'number' ? `${stats.roi.toFixed(1)}x` : stats.roi;
      const roiColor = typeof stats.roi === 'number' ?
        (stats.roi >= 2 ? '#10b981' : stats.roi >= 1 ? '#f59e0b' : '#ef4444') : '#6b7280';
  
      roiIndicator.innerHTML = `
        <div class="indicator">
          <span class="indicator-value" style="color: ${roiColor}">${roiValue}</span>
          <span class="indicator-label">ROI</span>
        </div>
      `;
  
      // Task breakdown
      const breakdown = DOM.create('div', 'category-breakdown');
      const totalTasks = stats.taskCount;
      const completedTasks = stats.completedCount;
      const overdueTasks = stats.overdueCount;
      const pendingTasks = totalTasks - completedTasks - overdueTasks;
  
      breakdown.innerHTML = `
        <div class="breakdown-item">
          <span class="breakdown-label">Completed:</span>
          <span class="breakdown-value completed">${completedTasks}</span>
        </div>
        <div class="breakdown-item">
          <span class="breakdown-label">Pending:</span>
          <span class="breakdown-value pending">${pendingTasks}</span>
        </div>
        <div class="breakdown-item">
          <span class="breakdown-label">Overdue:</span>
          <span class="breakdown-value overdue">${overdueTasks}</span>
        </div>
        <div class="breakdown-item">
          <span class="breakdown-label">Avg Duration:</span>
          <span class="breakdown-value">${stats.averageDuration} days</span>
        </div>
      `;
  
      // Spending info
      const spendingInfo = DOM.create('div', 'category-spending');
      spendingInfo.innerHTML = `
        <div class="spending-item">
          <span class="spending-label">Spending:</span>
          <span class="spending-value">${FinancePage.formatCurrency(stats.totalSpending)}</span>
        </div>
      `;
  
      card.appendChild(header);
      card.appendChild(indicators);
      card.appendChild(roiIndicator);
      card.appendChild(breakdown);
      card.appendChild(spendingInfo);
  
      // Click to view tasks in this category
      card.onclick = () => {
        // Filter tasks by this category and navigate to timeline
        AppState.timelineFilters.categories = [categoryName];
        Router.navigate('timeline');
      };
  
      return card;
    }
  };
  
  // Reports & Analytics Page
  const ReportsPage = {
    render() {
      const container = DOM.create('div', '');
      
      const header = DOM.create('div', 'page-header');
      header.appendChild(DOM.create('h1', 'page-title', 'Reports & Analytics'));
      header.appendChild(DOM.create('p', 'page-subtitle', 'Insights into your spending, tasks, and productivity'));
      container.appendChild(header);
  
      // Time period selector
      const periodSelector = DOM.create('div', 'reference-tabs');
      periodSelector.style.marginBottom = '1.5rem';
      const periods = [
        { id: 'month', label: 'This Month' },
        { id: 'year', label: 'This Year' },
        { id: 'all', label: 'All Time' }
      ];
      const currentPeriod = AppState.reportsPeriod || 'month';
      periods.forEach(period => {
        const btn = DOM.create('button', 'reference-tab');
        btn.textContent = period.label;
        if (currentPeriod === period.id) btn.classList.add('active');
        btn.onclick = () => {
          AppState.reportsPeriod = period.id;
          Router.render();
        };
        periodSelector.appendChild(btn);
      });
      container.appendChild(periodSelector);
  
      // Spending Trends
      container.appendChild(this.renderSpendingTrends());
      
      // Category Breakdown
      container.appendChild(this.renderCategoryBreakdown());
      
      // Task Completion Rates
      container.appendChild(this.renderTaskCompletion());
      
      // Productivity Trends
      container.appendChild(this.renderProductivityTrends());
  
      requestAnimationFrame(() => this.drawCharts());
      return container;
    },
  
    getDateRange() {
      const now = new Date();
      const period = AppState.reportsPeriod || 'month';
      
      if (period === 'month') {
        return {
          start: new Date(now.getFullYear(), now.getMonth(), 1),
          end: new Date(now.getFullYear(), now.getMonth() + 1, 0)
        };
      } else if (period === 'year') {
        return {
          start: new Date(now.getFullYear(), 0, 1),
          end: new Date(now.getFullYear(), 11, 31)
        };
      } else {
        return {
          start: new Date(2000, 0, 1),
          end: new Date(2100, 11, 31)
        };
      }
    },
  
    renderSpendingTrends() {
      const card = DOM.create('div', 'card');
      card.appendChild(DOM.create('h2', 'section-title', 'Spending Trends'));
      
      const { start, end } = this.getDateRange();
      const records = AppState.financeRecords.filter(r => {
        if (!r.date) return false;
        const recordDate = new Date(r.date);
        return recordDate >= start && recordDate <= end;
      });
  
      const monthlyData = {};
      records.forEach(record => {
        if (!record.date) return;
        const date = new Date(record.date);
        const monthKey = `${date.getFullYear()}-${String(date.getMonth() + 1).padStart(2, '0')}`;
        if (!monthlyData[monthKey]) {
          monthlyData[monthKey] = { income: 0, expenses: 0 };
        }
        const amount = Number(record.amount) || 0;
        if (record.type === 'income') {
          monthlyData[monthKey].income += amount;
        } else {
          monthlyData[monthKey].expenses += amount;
        }
      });
  
      const months = Object.keys(monthlyData).sort();
      const incomeData = months.map(m => monthlyData[m].income);
      const expenseData = months.map(m => monthlyData[m].expenses);
  
      const chartCard = DOM.create('div', 'finance-chart-card');
      chartCard.style.width = '100%';
      const canvas = DOM.create('canvas', '');
      canvas.id = 'reportsSpendingTrend';
      canvas.height = 300;
      chartCard.appendChild(canvas);
      card.appendChild(chartCard);
  
      // Store data for chart rendering
      card.dataset.months = JSON.stringify(months);
      card.dataset.income = JSON.stringify(incomeData);
      card.dataset.expenses = JSON.stringify(expenseData);
  
      return card;
    },
  
    renderCategoryBreakdown() {
      const card = DOM.create('div', 'card');
      card.appendChild(DOM.create('h2', 'section-title', 'Category Spending Breakdown'));
      
      const { start, end } = this.getDateRange();
      const records = AppState.financeRecords.filter(r => {
        if (!r.date || r.type !== 'expense') return false;
        const recordDate = new Date(r.date);
        return recordDate >= start && recordDate <= end;
      });
  
      const categoryTotals = {};
      records.forEach(record => {
        const category = record.category || 'Uncategorized';
        categoryTotals[category] = (categoryTotals[category] || 0) + (Number(record.amount) || 0);
      });
  
      const sortedCategories = Object.entries(categoryTotals)
        .sort((a, b) => b[1] - a[1])
        .slice(0, 10);
  
      const chartCard = DOM.create('div', 'finance-chart-card');
      chartCard.style.width = '100%';
      const canvas = DOM.create('canvas', '');
      canvas.id = 'reportsCategoryBreakdown';
      canvas.height = 300;
      chartCard.appendChild(canvas);
      card.appendChild(chartCard);
  
      // Store data
      card.dataset.categories = JSON.stringify(sortedCategories.map(c => c[0]));
      card.dataset.amounts = JSON.stringify(sortedCategories.map(c => c[1]));
  
      // Also show table
      const table = DOM.create('div', 'finance-category-list');
      table.style.marginTop = '1rem';
      sortedCategories.forEach(([category, amount]) => {
        const row = DOM.create('div', 'finance-category-row');
        row.innerHTML = `
          <div>
            <div style="font-weight: 600;">${category}</div>
          </div>
          <div style="font-weight: 600; color: #ef4444;">
            ${amount.toFixed(2)} MAD
          </div>
        `;
        table.appendChild(row);
      });
      card.appendChild(table);
  
      return card;
    },
  
    renderTaskCompletion() {
      const card = DOM.create('div', 'card');
      card.appendChild(DOM.create('h2', 'section-title', 'Task Completion Rates'));
      
      const { start, end } = this.getDateRange();
      const tasks = AppState.tasks.filter(t => {
        if (!t.endDate) return false;
        const taskDate = new Date(t.endDate);
        return taskDate >= start && taskDate <= end;
      });
  
      const statusCounts = {
        completed: tasks.filter(t => t.status === 'completed').length,
        pending: tasks.filter(t => t.status === 'pending').length,
        overdue: tasks.filter(t => t.status === 'overdue').length
      };
  
      const total = tasks.length;
      const completionRate = total > 0 ? Math.round((statusCounts.completed / total) * 100) : 0;
  
      const metrics = DOM.create('div', 'dashboard-finance-summary');
      metrics.innerHTML = `
        <div>
          <div class="dashboard-finance-label">Total Tasks</div>
          <div class="dashboard-finance-value">${total}</div>
        </div>
        <div>
          <div class="dashboard-finance-label">Completed</div>
          <div class="dashboard-finance-value income">${statusCounts.completed}</div>
        </div>
        <div>
          <div class="dashboard-finance-label">Pending</div>
          <div class="dashboard-finance-value">${statusCounts.pending}</div>
        </div>
        <div>
          <div class="dashboard-finance-label">Completion Rate</div>
          <div class="dashboard-finance-value ${completionRate >= 80 ? 'income' : completionRate >= 50 ? '' : 'expense'}">${completionRate}%</div>
        </div>
      `;
      card.appendChild(metrics);
  
      // Monthly completion trend
      const monthlyCompletion = {};
      tasks.forEach(task => {
        if (task.status === 'completed' && task.endDate) {
          const date = new Date(task.endDate);
          const monthKey = `${date.getFullYear()}-${String(date.getMonth() + 1).padStart(2, '0')}`;
          if (!monthlyCompletion[monthKey]) {
            monthlyCompletion[monthKey] = { completed: 0, total: 0 };
          }
          monthlyCompletion[monthKey].completed++;
        }
        if (task.endDate) {
          const date = new Date(task.endDate);
          const monthKey = `${date.getFullYear()}-${String(date.getMonth() + 1).padStart(2, '0')}`;
          if (!monthlyCompletion[monthKey]) {
            monthlyCompletion[monthKey] = { completed: 0, total: 0 };
          }
          monthlyCompletion[monthKey].total++;
        }
      });
  
      const months = Object.keys(monthlyCompletion).sort();
      const completionRates = months.map(m => 
        monthlyCompletion[m].total > 0 
          ? Math.round((monthlyCompletion[m].completed / monthlyCompletion[m].total) * 100)
          : 0
      );
  
      const chartCard = DOM.create('div', 'finance-chart-card');
      chartCard.style.width = '100%';
      chartCard.style.marginTop = '1rem';
      const canvas = DOM.create('canvas', '');
      canvas.id = 'reportsTaskCompletion';
      canvas.height = 250;
      chartCard.appendChild(canvas);
      card.appendChild(chartCard);
  
      card.dataset.months = JSON.stringify(months);
      card.dataset.rates = JSON.stringify(completionRates);
  
      return card;
    },
  
    renderProductivityTrends() {
      const card = DOM.create('div', 'card');
      card.appendChild(DOM.create('h2', 'section-title', 'Productivity Trends'));
      
      const { start, end } = this.getDateRange();
      const tasks = AppState.tasks.filter(t => {
        if (!t.endDate) return false;
        const taskDate = new Date(t.endDate);
        return taskDate >= start && taskDate <= end;
      });
  
      // Group by week
      const weeklyData = {};
      tasks.forEach(task => {
        if (!task.endDate) return;
        const date = new Date(task.endDate);
        const weekStart = new Date(date);
        weekStart.setDate(date.getDate() - date.getDay());
        const weekKey = `${weekStart.getFullYear()}-W${String(Math.ceil((weekStart.getDate() + (7 - weekStart.getDay())) / 7)).padStart(2, '0')}`;
        
        if (!weeklyData[weekKey]) {
          weeklyData[weekKey] = { completed: 0, created: 0 };
        }
        if (task.status === 'completed') {
          weeklyData[weekKey].completed++;
        }
        weeklyData[weekKey].created++;
      });
  
      const weeks = Object.keys(weeklyData).sort();
      const completed = weeks.map(w => weeklyData[w].completed);
      const created = weeks.map(w => weeklyData[w].created);
  
      const chartCard = DOM.create('div', 'finance-chart-card');
      chartCard.style.width = '100%';
      const canvas = DOM.create('canvas', '');
      canvas.id = 'reportsProductivity';
      canvas.height = 250;
      chartCard.appendChild(canvas);
      card.appendChild(chartCard);
  
      card.dataset.weeks = JSON.stringify(weeks);
      card.dataset.completed = JSON.stringify(completed);
      card.dataset.created = JSON.stringify(created);
  
      return card;
    },
  
    drawCharts() {
      requestAnimationFrame(async () => {
        if (typeof Chart === 'undefined') return;
        
        // Spending Trends Chart
        const spendingCard = document.querySelector('#reportsSpendingTrend')?.closest('.card');
        if (spendingCard) {
          const months = JSON.parse(spendingCard.dataset.months || '[]');
          const income = JSON.parse(spendingCard.dataset.income || '[]');
          const expenses = JSON.parse(spendingCard.dataset.expenses || '[]');
          const canvas = document.getElementById('reportsSpendingTrend');
          if (canvas && months.length > 0) {
            new Chart(canvas, {
              type: 'line',
              data: {
                labels: months,
                datasets: [
                  { label: 'Income', data: income, borderColor: '#10b981', backgroundColor: 'rgba(16, 185, 129, 0.2)', fill: true, tension: 0.4 },
                  { label: 'Expenses', data: expenses, borderColor: '#ef4444', backgroundColor: 'rgba(239, 68, 68, 0.2)', fill: true, tension: 0.4 }
                ]
              },
              options: {
                responsive: true,
                plugins: { legend: { position: 'bottom' } },
                scales: { y: { beginAtZero: true } }
              }
            });
          }
        }
  
        // Category Breakdown Chart
        const categoryCard = document.querySelector('#reportsCategoryBreakdown')?.closest('.card');
        if (categoryCard) {
          const categories = JSON.parse(categoryCard.dataset.categories || '[]');
          const amounts = JSON.parse(categoryCard.dataset.amounts || '[]');
          const canvas = document.getElementById('reportsCategoryBreakdown');
          if (canvas && categories.length > 0) {
            new Chart(canvas, {
              type: 'bar',
              data: {
                labels: categories,
                datasets: [{
                  label: 'Amount (MAD)',
                  data: amounts,
                  backgroundColor: '#6366f1'
                }]
              },
              options: {
                responsive: true,
                plugins: { legend: { display: false } },
                scales: { y: { beginAtZero: true } }
              }
            });
          }
        }
  
        // Task Completion Chart
        const taskCard = document.querySelector('#reportsTaskCompletion')?.closest('.card');
        if (taskCard) {
          const months = JSON.parse(taskCard.dataset.months || '[]');
          const rates = JSON.parse(taskCard.dataset.rates || '[]');
          const canvas = document.getElementById('reportsTaskCompletion');
          if (canvas && months.length > 0) {
            new Chart(canvas, {
              type: 'line',
              data: {
                labels: months,
                datasets: [{
                  label: 'Completion Rate %',
                  data: rates,
                  borderColor: '#6366f1',
                  backgroundColor: 'rgba(99, 102, 241, 0.2)',
                  fill: true,
                  tension: 0.4
                }]
              },
              options: {
                responsive: true,
                plugins: { legend: { position: 'bottom' } },
                scales: { y: { beginAtZero: true, max: 100 } }
              }
            });
          }
        }
  
        // Productivity Chart
        const productivityCard = document.querySelector('#reportsProductivity')?.closest('.card');
        if (productivityCard) {
          const weeks = JSON.parse(productivityCard.dataset.weeks || '[]');
          const completed = JSON.parse(productivityCard.dataset.completed || '[]');
          const created = JSON.parse(productivityCard.dataset.created || '[]');
          const canvas = document.getElementById('reportsProductivity');
          if (canvas && weeks.length > 0) {
            new Chart(canvas, {
              type: 'bar',
              data: {
                labels: weeks,
                datasets: [
                  { label: 'Completed', data: completed, backgroundColor: '#10b981' },
                  { label: 'Created', data: created, backgroundColor: '#6366f1' }
                ]
              },
              options: {
                responsive: true,
                plugins: { legend: { position: 'bottom' } },
                scales: { y: { beginAtZero: true } }
              }
            });
          }
        }
      });
    }
  };
  
  // Notes & Journal Page
  const NotesPage = {
    render() {
      const container = DOM.create('div', '');
      
      const header = DOM.create('div', 'page-header');
      header.style.display = 'flex';
      header.style.justifyContent = 'space-between';
      header.style.alignItems = 'center';
      header.appendChild(DOM.create('h1', 'page-title', 'Notes & Journal'));
      
      const addBtn = DOM.create('button', 'btn btn-primary');
      addBtn.textContent = '+ New Note';
      addBtn.onclick = () => NoteModal.show();
      header.appendChild(addBtn);
      container.appendChild(header);
  
      // Subject/Topic tabs
      const subjectTabs = DOM.create('div', 'reference-tabs');
      subjectTabs.style.marginBottom = '1.5rem';
      const subjects = this.getSubjects();
      const currentSubject = AppState.notesSubject || 'all';
      
      const allTab = DOM.create('button', 'reference-tab');
      allTab.textContent = 'All Notes';
      if (currentSubject === 'all') allTab.classList.add('active');
      allTab.onclick = () => {
        AppState.notesSubject = 'all';
        Router.render();
      };
      subjectTabs.appendChild(allTab);
  
      subjects.forEach(subject => {
        const tab = DOM.create('button', 'reference-tab');
        tab.textContent = subject;
        if (currentSubject === subject) tab.classList.add('active');
        tab.onclick = () => {
          AppState.notesSubject = subject;
          Router.render();
        };
        subjectTabs.appendChild(tab);
      });
  
      const addSubjectBtn = DOM.create('button', 'reference-tab');
      addSubjectBtn.textContent = '+ Add Subject';
      addSubjectBtn.style.borderStyle = 'dashed';
      addSubjectBtn.onclick = () => {
        const subject = prompt('Enter subject/topic name:');
        if (subject && subject.trim()) {
          if (!AppState.notesSubjects) AppState.notesSubjects = [];
          if (!AppState.notesSubjects.includes(subject.trim())) {
            AppState.notesSubjects.push(subject.trim());
            Router.render();
          }
        }
      };
      subjectTabs.appendChild(addSubjectBtn);
      container.appendChild(subjectTabs);
  
      // Notes list
      const notesCard = DOM.create('div', 'card');
      const filteredNotes = this.getFilteredNotes();
      
      if (filteredNotes.length === 0) {
        const empty = DOM.create('div', 'empty-state');
        empty.textContent = 'No notes yet. Click "+ New Note" to create one.';
        notesCard.appendChild(empty);
      } else {
        const notesList = DOM.create('div', 'finance-daily-list');
        filteredNotes.forEach(note => {
          const noteRow = DOM.create('div', 'finance-record');
          const details = DOM.create('div', 'finance-record-details');
          const title = DOM.create('div', 'finance-record-title', note.title);
          const meta = DOM.create('div', 'finance-record-meta',
            `${note.subject || 'Uncategorized'} • ${note.date || 'No date'}`
          );
          const description = note.description
            ? DOM.create('div', 'finance-record-meta', note.description)
            : null;
          details.appendChild(title);
          details.appendChild(meta);
          if (description) details.appendChild(description);
          
          const actions = DOM.create('div', 'finance-record-actions');
          if (note.docLink) {
            const openBtn = DOM.create('button', 'btn btn-xs btn-primary');
            openBtn.textContent = 'Open link';
            openBtn.onclick = () => window.open(note.docLink, '_blank');
            actions.appendChild(openBtn);
          }
          const editBtn = DOM.create('button', 'btn btn-xs btn-secondary');
          editBtn.textContent = 'Edit';
          editBtn.onclick = () => NoteModal.show(note);
          const deleteBtn = DOM.create('button', 'btn btn-xs btn-danger');
          deleteBtn.textContent = 'Delete';
          deleteBtn.onclick = () => this.deleteNote(note.id);
          actions.appendChild(editBtn);
          actions.appendChild(deleteBtn);
          
          noteRow.appendChild(details);
          noteRow.appendChild(actions);
          notesList.appendChild(noteRow);
        });
        notesCard.appendChild(notesList);
      }
      container.appendChild(notesCard);
  
      return container;
    },
  
    getSubjects() {
      if (!AppState.notesSubjects) AppState.notesSubjects = [];
      return AppState.notesSubjects;
    },
  
    getFilteredNotes() {
      const notes = AppState.notes || [];
      const subject = AppState.notesSubject || 'all';
      if (subject === 'all') return notes;
      return notes.filter(n => n.subject === subject);
    },
  
    async deleteNote(noteId) {
      if (!confirm('Delete this note?')) return;
      
      const operationId = `delete-note-${noteId}`;
      await SaveManager.saveWithOptimisticUpdate(
        operationId,
        () => {
          AppState.notes = AppState.notes.filter(n => n.id !== noteId);
        },
        async () => {
          await API.deleteNote(noteId);
          await DataStore.refresh();
        },
        () => {
          Toast.success('Note deleted');
          Router.render();
        },
        (error) => {
          Toast.error('Error deleting note');
          Router.render();
        }
      );
    }
  };
  
  // Recurring Bills & Subscriptions Page
  const RecurringBillsPage = {
    render() {
      const container = DOM.create('div', '');
      
      // Header with add button
      const header = DOM.create('div', '');
      header.style.display = 'flex';
      header.style.justifyContent = 'space-between';
      header.style.alignItems = 'center';
      header.style.marginBottom = '1.5rem';
      
      const addBtn = DOM.create('button', 'btn btn-primary');
      addBtn.textContent = '+ New Recurring Bill';
      addBtn.onclick = () => RecurringBillModal.show();
      header.appendChild(addBtn);
      container.appendChild(header);
  
      // Summary
      const summaryCard = DOM.create('div', 'card');
      summaryCard.appendChild(DOM.create('h3', 'section-title', 'Monthly Recurring Expenses'));
      const totals = AppState.recurringBills?.reduce((acc, bill) => {
        if (bill.status === 'active') {
          acc.total += Number(bill.amount) || 0;
          if (bill.type === 'subscription') acc.subscriptions += Number(bill.amount) || 0;
          else acc.bills += Number(bill.amount) || 0;
        }
        return acc;
      }, { total: 0, bills: 0, subscriptions: 0 }) || { total: 0, bills: 0, subscriptions: 0 };
  
      const summaryGrid = DOM.create('div', 'dashboard-finance-summary');
      summaryGrid.innerHTML = `
        <div>
          <div class="dashboard-finance-label">Total Monthly</div>
          <div class="dashboard-finance-value expense">${totals.total.toFixed(2)} MAD</div>
        </div>
        <div>
          <div class="dashboard-finance-label">Bills</div>
          <div class="dashboard-finance-value">${totals.bills.toFixed(2)} MAD</div>
        </div>
        <div>
          <div class="dashboard-finance-label">Subscriptions</div>
          <div class="dashboard-finance-value">${totals.subscriptions.toFixed(2)} MAD</div>
        </div>
      `;
      summaryCard.appendChild(summaryGrid);
      container.appendChild(summaryCard);
  
      // Bills list
      const listCard = DOM.create('div', 'card');
      listCard.appendChild(DOM.create('h3', 'section-title', 'All Recurring Bills'));
      
      const billsList = DOM.create('div', 'finance-daily-list');
      const bills = AppState.recurringBills || [];
      
      if (bills.length === 0) {
        const empty = DOM.create('div', 'empty-state');
        empty.textContent = 'No recurring bills yet. Click "+ New Recurring Bill" to create one.';
        billsList.appendChild(empty);
      } else {
        bills.sort((a, b) => {
          const dateA = a.nextDueDate ? new Date(a.nextDueDate) : new Date(0);
          const dateB = b.nextDueDate ? new Date(b.nextDueDate) : new Date(0);
          return dateA - dateB;
        }).forEach(bill => {
          const billRow = DOM.create('div', 'finance-record');
          const details = DOM.create('div', 'finance-record-details');
          const title = DOM.create('div', 'finance-record-title', bill.name);
          const meta = DOM.create('div', 'finance-record-meta', 
            `${bill.type === 'subscription' ? 'Subscription' : 'Bill'} • ${bill.frequency} • Next: ${bill.nextDueDate || 'Not set'}`
          );
          if (bill.description) {
            details.appendChild(DOM.create('div', 'finance-record-meta', bill.description));
          }
          const statusLabel = bill.status === 'active' ? 'Active' : 'Inactive';
          const status = DOM.create('span', 'finance-record-tag', statusLabel);
          details.appendChild(title);
          details.appendChild(meta);
          details.appendChild(status);
          
          const amount = DOM.create('div', 'finance-record-amount expense');
          amount.textContent = `${bill.amount.toFixed(2)} MAD`;
          
          const actions = DOM.create('div', 'finance-record-actions');
          const editBtn = DOM.create('button', 'btn btn-xs btn-secondary');
          editBtn.textContent = 'Edit';
          editBtn.onclick = () => RecurringBillModal.show(bill);
          const deleteBtn = DOM.create('button', 'btn btn-xs btn-danger');
          deleteBtn.textContent = 'Delete';
          deleteBtn.onclick = () => this.deleteBill(bill.id);
          actions.appendChild(editBtn);
          actions.appendChild(deleteBtn);
          
          billRow.appendChild(details);
          billRow.appendChild(amount);
          billRow.appendChild(actions);
          billsList.appendChild(billRow);
        });
      }
      listCard.appendChild(billsList);
      container.appendChild(listCard);
  
      return container;
    },
  
    async deleteBill(billId) {
      if (!confirm('Delete this recurring bill?')) return;
      
      const operationId = `delete-recurring-bill-${billId}`;
      await SaveManager.saveWithOptimisticUpdate(
        operationId,
        () => {
          AppState.recurringBills = AppState.recurringBills.filter(b => b.id !== billId);
        },
        async () => {
          await API.deleteRecurringBill(billId);
          await DataStore.refresh();
        },
        () => {
          Toast.success('Recurring bill deleted');
          Router.render();
        },
        (error) => {
          Toast.error('Error deleting recurring bill');
          Router.render();
        }
      );
    }
  };
  
  // Note Modal
  const NoteModal = {
    show(note = null) {
      const overlay = DOM.create('div', 'modal-overlay active');
      overlay.onclick = (e) => {
        if (e.target === overlay) this.hide();
      };
  
      const modal = DOM.create('div', 'modal');
      const header = DOM.create('div', 'modal-header');
      header.appendChild(DOM.create('h2', 'modal-title', note ? 'Edit Note' : 'New Note'));
      const closeBtn = DOM.create('button', 'modal-close');
      closeBtn.innerHTML = DOM.getIconSVG('close');
      closeBtn.onclick = () => this.hide();
      header.appendChild(closeBtn);
      modal.appendChild(header);
  
      const form = DOM.create('form', '');
      
      const titleGroup = DOM.create('div', 'form-group');
      titleGroup.appendChild(DOM.create('label', 'form-label', 'Title *'));
      const titleInput = DOM.create('input', 'form-input');
      titleInput.type = 'text';
      titleInput.name = 'title';
      titleInput.value = note?.title || '';
      titleInput.required = true;
      titleInput.placeholder = 'Note title';
      titleGroup.appendChild(titleInput);
      form.appendChild(titleGroup);
  
      const subjectGroup = DOM.create('div', 'form-group');
      subjectGroup.appendChild(DOM.create('label', 'form-label', 'Subject/Topic'));
      
      // Get existing subjects from both AppState.notesSubjects and existing notes
      const subjectsFromList = NotesPage.getSubjects();
      const subjectsFromNotes = [...new Set((AppState.notes || [])
        .map(n => n.subject)
        .filter(s => s && s.trim() !== ''))];
      
      // Combine and deduplicate
      const allSubjects = [...new Set([...subjectsFromList, ...subjectsFromNotes])].sort();
      
      // Create select dropdown
      const subjectSelect = DOM.create('select', 'form-select');
      subjectSelect.name = 'subject';
      
      // Add empty option
      const emptyOption = DOM.create('option', '');
      emptyOption.value = '';
      emptyOption.textContent = 'Select or add a subject...';
      if (!note?.subject) {
        emptyOption.selected = true;
      }
      subjectSelect.appendChild(emptyOption);
      
      // Add existing subjects
      allSubjects.forEach(subject => {
        const option = DOM.create('option', '');
        option.value = subject;
        option.textContent = subject;
        if (note?.subject === subject) {
          option.selected = true;
        }
        subjectSelect.appendChild(option);
      });
      
      // Add option to create new subject
      const addNewOption = DOM.create('option', '');
      addNewOption.value = '__add_new__';
      addNewOption.textContent = '+ Add New Subject';
      subjectSelect.appendChild(addNewOption);
      
      // Handle subject selection
      let newSubjectInput = null;
      subjectSelect.onchange = () => {
        if (subjectSelect.value === '__add_new__') {
          // Remove the add new option temporarily
          subjectSelect.value = '';
          
          // Create input field for new subject
          if (!newSubjectInput) {
            newSubjectInput = DOM.create('input', 'form-input');
            newSubjectInput.type = 'text';
            newSubjectInput.name = 'newSubject';
            newSubjectInput.placeholder = 'Enter new subject name';
            newSubjectInput.style.marginTop = '0.5rem';
            subjectGroup.appendChild(newSubjectInput);
            
            // Add option to go back to dropdown
            const backOption = DOM.create('button', 'btn btn-sm btn-secondary');
            backOption.type = 'button';
            backOption.textContent = 'Cancel';
            backOption.style.marginTop = '0.5rem';
            backOption.onclick = () => {
              if (newSubjectInput) {
                newSubjectInput.remove();
                newSubjectInput = null;
              }
              if (backOption) backOption.remove();
              subjectSelect.value = '';
            };
            subjectGroup.appendChild(backOption);
          }
        } else {
          // Remove new subject input if it exists
          if (newSubjectInput) {
            newSubjectInput.remove();
            newSubjectInput = null;
            // Remove cancel button
            const cancelBtn = subjectGroup.querySelector('button');
            if (cancelBtn) cancelBtn.remove();
          }
        }
      };
      
      // If editing and subject doesn't exist in list, add it
      if (note?.subject && !allSubjects.includes(note.subject)) {
        const customOption = DOM.create('option', '');
        customOption.value = note.subject;
        customOption.textContent = note.subject;
        customOption.selected = true;
        subjectSelect.insertBefore(customOption, addNewOption);
      }
      
      subjectGroup.appendChild(subjectSelect);
      form.appendChild(subjectGroup);
  
      const dateGroup = DOM.create('div', 'form-group');
      dateGroup.appendChild(DOM.create('label', 'form-label', 'Date'));
      const dateInput = DOM.create('input', 'form-input');
      dateInput.type = 'date';
      dateInput.name = 'date';
      dateInput.value = note?.date || new Date().toISOString().split('T')[0];
      dateGroup.appendChild(dateInput);
      form.appendChild(dateGroup);
  
      const docLinkGroup = DOM.create('div', 'form-group');
      docLinkGroup.appendChild(DOM.create('label', 'form-label', 'Link (URL)'));
      const docLinkInput = DOM.create('input', 'form-input');
      docLinkInput.type = 'url';
      docLinkInput.name = 'docLink';
      docLinkInput.placeholder = 'https://example.com';
      docLinkInput.value = note?.docLink || '';
      docLinkGroup.appendChild(docLinkInput);
      form.appendChild(docLinkGroup);
  
      const descriptionGroup = DOM.create('div', 'form-group');
      descriptionGroup.appendChild(DOM.create('label', 'form-label', 'Description'));
      const descriptionInput = DOM.create('textarea', 'form-input');
      descriptionInput.name = 'description';
      descriptionInput.rows = 4;
      descriptionInput.placeholder = 'Add a short description or summary';
      descriptionInput.value = note?.description || '';
      descriptionGroup.appendChild(descriptionInput);
      form.appendChild(descriptionGroup);
  
      form.onsubmit = (e) => {
        e.preventDefault();
        this.save(note, new FormData(form));
      };
  
      modal.appendChild(form);
  
      const footer = DOM.create('div', 'modal-footer');
      const saveBtn = DOM.create('button', 'btn btn-primary');
      saveBtn.type = 'submit';
      saveBtn.textContent = 'Save';
      saveBtn.onclick = () => form.requestSubmit();
      footer.appendChild(saveBtn);
      
      const cancelBtn = DOM.create('button', 'btn btn-secondary');
      cancelBtn.textContent = 'Cancel';
      cancelBtn.onclick = () => this.hide();
      footer.appendChild(cancelBtn);
      
      modal.appendChild(footer);
      overlay.appendChild(modal);
      document.body.appendChild(overlay);
    },
  
    hide() {
      const overlay = document.querySelector('.modal-overlay');
      if (overlay) overlay.remove();
    },
  
    async save(note, formData) {
      // Get subject from either dropdown or new subject input
      let subject = formData.get('subject')?.trim() || '';
      const newSubject = formData.get('newSubject')?.trim() || '';
      
      // If new subject was entered, use that instead
      if (newSubject) {
        subject = newSubject;
      }
      
      const noteData = {
        id: note?.id || Date.now(),
        title: formData.get('title').trim(),
        subject: subject,
        date: formData.get('date') || '',
        docLink: (formData.get('docLink') || '').trim(),
        description: (formData.get('description') || '').trim()
      };
  
      if (!noteData.title) {
        Toast.error('Note title is required');
        return;
      }
  
      // Add subject to subjects list if new
      if (noteData.subject && !AppState.notesSubjects.includes(noteData.subject)) {
        if (!AppState.notesSubjects) AppState.notesSubjects = [];
        AppState.notesSubjects.push(noteData.subject);
      }
  
      const operationId = note ? `update-note-${note.id}` : `create-note-${Date.now()}`;
      const saveButton = document.querySelector('.modal-footer .btn-primary');
      
      if (saveButton) {
        saveButton.classList.add('loading');
        saveButton.disabled = true;
        saveButton.textContent = 'Saving...';
      }
  
      await SaveManager.saveWithOptimisticUpdate(
        operationId,
        () => {
          if (note) {
            const index = AppState.notes.findIndex(n => n.id === note.id);
            if (index >= 0) {
              AppState.notes[index] = { ...noteData };
            }
          } else {
            // Add note with temporary ID
            AppState.notes.push({ ...noteData });
          }
        },
        async () => {
          try {
            if (note) {
              await API.updateNote(noteData);
            } else {
              const result = await API.addNote(noteData);
              if (result && result.id) {
                // Update the note with the correct ID from backend
                const tempIndex = AppState.notes.findIndex(n => n.id === noteData.id);
                if (tempIndex >= 0) {
                  AppState.notes[tempIndex].id = result.id;
                  if (result.docLink) {
                    AppState.notes[tempIndex].docLink = result.docLink;
                  }
                }
              }
            }
            await DataStore.refresh();
          } catch (error) {
            console.error('Error saving note:', error);
            throw error;
          }
        },
        () => {
          if (saveButton) {
            saveButton.classList.remove('loading');
            saveButton.textContent = 'Save';
            saveButton.disabled = false;
          }
          this.hide();
          Toast.success(note ? 'Note updated' : 'Note created');
          Router.render();
        },
        (error) => {
          console.error('Note save error:', error);
          if (saveButton) {
            saveButton.classList.remove('loading');
            saveButton.textContent = 'Save';
            saveButton.disabled = false;
          }
          Toast.error('Error saving note: ' + (error.message || 'Unknown error'));
        }
      );
    }
  };
  
  // Recurring Bill Modal
  const RecurringBillModal = {
    show(bill = null) {
      const overlay = DOM.create('div', 'modal-overlay active');
      overlay.onclick = (e) => {
        if (e.target === overlay) this.hide();
      };
  
      const modal = DOM.create('div', 'modal');
      const header = DOM.create('div', 'modal-header');
      header.appendChild(DOM.create('h2', 'modal-title', bill ? 'Edit Recurring Bill' : 'New Recurring Bill'));
      const closeBtn = DOM.create('button', 'modal-close');
      closeBtn.innerHTML = DOM.getIconSVG('close');
      closeBtn.onclick = () => this.hide();
      header.appendChild(closeBtn);
      modal.appendChild(header);
  
      const form = DOM.create('form', '');
      
      const nameGroup = DOM.create('div', 'form-group');
      nameGroup.appendChild(DOM.create('label', 'form-label', 'Name *'));
      const nameInput = DOM.create('input', 'form-input');
      nameInput.type = 'text';
      nameInput.name = 'name';
      nameInput.value = bill?.name || '';
      nameInput.required = true;
      nameInput.placeholder = 'e.g., Netflix, Rent, Internet';
      nameGroup.appendChild(nameInput);
      form.appendChild(nameGroup);
  
      const typeGroup = DOM.create('div', 'form-group');
      typeGroup.appendChild(DOM.create('label', 'form-label', 'Type *'));
      const typeSelect = DOM.create('select', 'form-select');
      typeSelect.name = 'type';
      typeSelect.required = true;
      const billOption = DOM.create('option', '', 'Bill');
      billOption.value = 'bill';
      if (bill?.type === 'bill' || !bill) billOption.selected = true;
      const subOption = DOM.create('option', '', 'Subscription');
      subOption.value = 'subscription';
      if (bill?.type === 'subscription') subOption.selected = true;
      typeSelect.appendChild(billOption);
      typeSelect.appendChild(subOption);
      typeGroup.appendChild(typeSelect);
      form.appendChild(typeGroup);
  
      const amountGroup = DOM.create('div', 'form-group');
      amountGroup.appendChild(DOM.create('label', 'form-label', 'Amount (MAD) *'));
      const amountInput = DOM.create('input', 'form-input');
      amountInput.type = 'number';
      amountInput.step = '0.01';
      amountInput.required = true;
      amountInput.value = bill?.amount || '';
      amountInput.name = 'amount';
      amountGroup.appendChild(amountInput);
      form.appendChild(amountGroup);
  
      const frequencyGroup = DOM.create('div', 'form-group');
      frequencyGroup.appendChild(DOM.create('label', 'form-label', 'Frequency *'));
      const frequencySelect = DOM.create('select', 'form-select');
      frequencySelect.name = 'frequency';
      frequencySelect.required = true;
      ['monthly', 'yearly', 'weekly'].forEach(freq => {
        const option = DOM.create('option', '', freq.charAt(0).toUpperCase() + freq.slice(1));
        option.value = freq;
        if ((bill?.frequency || 'monthly') === freq) option.selected = true;
        frequencySelect.appendChild(option);
      });
      frequencyGroup.appendChild(frequencySelect);
      form.appendChild(frequencyGroup);
  
      const nextDueGroup = DOM.create('div', 'form-group');
      nextDueGroup.appendChild(DOM.create('label', 'form-label', 'Next Due Date *'));
      const nextDueInput = DOM.create('input', 'form-input');
      nextDueInput.type = 'date';
      nextDueInput.name = 'nextDueDate';
      nextDueInput.value = bill?.nextDueDate || '';
      nextDueInput.required = true;
      nextDueGroup.appendChild(nextDueInput);
      form.appendChild(nextDueGroup);
  
      const categoryGroup = DOM.create('div', 'form-group');
      categoryGroup.appendChild(DOM.create('label', 'form-label', 'Category *'));
      const categorySelect = DOM.create('select', 'form-select');
      categorySelect.name = 'category';
      categorySelect.required = true;
      
      // Find Subscription category or use it as default
      const subscriptionCat = AppState.financeCategories.find(c => c.name === 'Subscription');
      const defaultCategory = bill?.category || (subscriptionCat ? 'Subscription' : '');
      
      AppState.financeCategories.forEach(cat => {
        const option = DOM.create('option', '', cat.name);
        option.value = cat.name;
        if (defaultCategory === cat.name) option.selected = true;
        categorySelect.appendChild(option);
      });
      
      // Auto-update category when type changes
      typeSelect.onchange = () => {
        if (typeSelect.value === 'subscription') {
          const subOption = Array.from(categorySelect.options).find(opt => opt.value === 'Subscription');
          if (subOption) {
            categorySelect.value = 'Subscription';
          }
        }
      };
      
      categoryGroup.appendChild(categorySelect);
      form.appendChild(categoryGroup);
  
      const descGroup = DOM.create('div', 'form-group');
      descGroup.appendChild(DOM.create('label', 'form-label', 'Description'));
      const descInput = DOM.create('textarea', 'form-input');
      descInput.name = 'description';
      descInput.value = bill?.description || '';
      descInput.rows = 3;
      descGroup.appendChild(descInput);
      form.appendChild(descGroup);
  
      const statusGroup = DOM.create('div', 'form-group');
      statusGroup.appendChild(DOM.create('label', 'form-label', 'Status'));
      const statusSelect = DOM.create('select', 'form-select');
      statusSelect.name = 'status';
      const activeOption = DOM.create('option', '', 'Active');
      activeOption.value = 'active';
      if ((bill?.status || 'active') === 'active') activeOption.selected = true;
      const inactiveOption = DOM.create('option', '', 'Inactive');
      inactiveOption.value = 'inactive';
      if (bill?.status === 'inactive') inactiveOption.selected = true;
      statusSelect.appendChild(activeOption);
      statusSelect.appendChild(inactiveOption);
      statusGroup.appendChild(statusSelect);
      form.appendChild(statusGroup);
  
      form.onsubmit = (e) => {
        e.preventDefault();
        this.save(bill, new FormData(form));
      };
  
      modal.appendChild(form);
  
      const footer = DOM.create('div', 'modal-footer');
      const saveBtn = DOM.create('button', 'btn btn-primary');
      saveBtn.type = 'submit';
      saveBtn.textContent = 'Save';
      saveBtn.onclick = () => form.requestSubmit();
      footer.appendChild(saveBtn);
      
      const cancelBtn = DOM.create('button', 'btn btn-secondary');
      cancelBtn.textContent = 'Cancel';
      cancelBtn.onclick = () => this.hide();
      footer.appendChild(cancelBtn);
      
      modal.appendChild(footer);
      overlay.appendChild(modal);
      document.body.appendChild(overlay);
    },
  
    hide() {
      const overlay = document.querySelector('.modal-overlay');
      if (overlay) overlay.remove();
    },
  
    async save(bill, formData) {
      const billData = {
        id: bill?.id || Date.now(),
        name: formData.get('name').trim(),
        amount: parseFloat(formData.get('amount')) || 0,
        type: formData.get('type'),
        frequency: formData.get('frequency'),
        nextDueDate: formData.get('nextDueDate'),
        category: formData.get('category') || 'Subscription',
        status: formData.get('status') || 'active',
        description: formData.get('description') || ''
      };
  
      const operationId = bill ? `update-recurring-bill-${bill.id}` : `create-recurring-bill-${Date.now()}`;
      const saveButton = document.querySelector('.modal-footer .btn-primary');
      
      if (saveButton) {
        saveButton.classList.add('loading');
        saveButton.disabled = true;
        saveButton.textContent = 'Saving...';
      }
  
      await SaveManager.saveWithOptimisticUpdate(
        operationId,
        () => {
          if (bill) {
            const index = AppState.recurringBills.findIndex(b => b.id === bill.id);
            if (index >= 0) {
              AppState.recurringBills[index] = billData;
            }
          } else {
            AppState.recurringBills.push(billData);
          }
        },
        async () => {
          if (bill) {
            await API.updateRecurringBill(billData);
          } else {
            await API.addRecurringBill(billData);
          }
          await DataStore.refresh();
        },
        () => {
          if (saveButton) {
            saveButton.classList.remove('loading');
            saveButton.textContent = 'Save';
            saveButton.disabled = false;
          }
          this.hide();
          Toast.success(bill ? 'Recurring bill updated' : 'Recurring bill created');
          Router.render();
        },
        (error) => {
          if (saveButton) {
            saveButton.classList.remove('loading');
            saveButton.textContent = 'Save';
            saveButton.disabled = false;
          }
          Toast.error('Error saving recurring bill');
        }
      );
    }
  };
  
  // Start app when DOM is ready
  if (document.readyState === 'loading') {
    document.addEventListener('DOMContentLoaded', init);
  } else {
    init();
  }
  </script>
  